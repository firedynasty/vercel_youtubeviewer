<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube Viewer (Looper)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #FF6B35 0%, #F7931E 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 25px;
            padding: 35px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.2);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 25px;
            font-size: 2.5rem;
            background: linear-gradient(45deg, #FF6B35, #F7931E);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .section {
            background: rgba(255, 255, 255, 0.6);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            border: 2px solid rgba(255, 107, 53, 0.2);
        }

        .section-title {
            font-size: 1.3rem;
            color: #FF6B35;
            margin-bottom: 15px;
            font-weight: 700;
            text-align: center;
        }

        .paste-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }

        .paste-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(76, 175, 80, 0.4);
        }

        .youtube-container {
            position: relative;
            width: 100%;
            height: 0;
            padding-bottom: 56.25%;
            border-radius: 10px;
            overflow: hidden;
            background: #000;
        }

        .youtube-container iframe,
        .youtube-container #youtube-player {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 10px;
        }

        .media-container {
            position: relative;
            width: 100%;
            border-radius: 10px;
            overflow: hidden;
            background: #000;
            display: none;
        }

        .media-container video,
        .media-container audio {
            width: 100%;
            border-radius: 10px;
        }

        .media-container audio {
            height: 60px;
        }

        .time-offset-control {
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.1), rgba(255, 152, 0, 0.1));
            border: 1px solid rgba(255, 193, 7, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 1rem 0;
            text-align: center;
        }

        .time-offset-control h4 {
            color: #FFC107;
            margin: 0 0 10px 0;
            font-size: 1.1rem;
        }

        .time-input {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            border: 2px solid rgba(255, 193, 7, 0.5);
            border-radius: 8px;
            font-size: 1rem;
            width: 80px;
            text-align: center;
            font-family: monospace;
        }

        .time-input:focus {
            outline: none;
            border-color: #FFC107;
            box-shadow: 0 0 5px rgba(255, 193, 7, 0.3);
        }

        .jump-btn {
            padding: 8px 16px;
            background: linear-gradient(45deg, #FF5722, #E64A19);
            color: white;
            border: none;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-left: 10px;
        }

        .jump-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 87, 34, 0.4);
        }

        .time-btn {
            padding: 6px 12px;
            color: white;
            border: none;
            border-radius: 15px;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .time-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
        }

        .time-btn.active {
            border: 3px solid #FFD700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
        }

        .current-time-display {
            background: transparent;
            border: none;
            border-radius: 0;
            padding: 4px 0;
            margin-top: 3px;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            font-weight: 600;
            display: none;
        }

        .time-label {
            color: #4CAF50;
            margin-right: 6px;
        }

        .time-value {
            color: #4CAF50;
            background: transparent;
            padding: 0;
            border-radius: 0;
            border: none;
            min-width: 60px;
            display: inline-block;
            font-weight: 700;
        }

        .status-display {
            text-align: center;
            padding: 10px;
            margin: 10px 0;
            border-radius: 8px;
            font-weight: 600;
            display: none;
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid #4CAF50;
            color: #4CAF50;
        }

        #loopTimerStatus {
            display: none;
            text-align: center;
            margin-top: 10px;
            padding: 10px;
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid #4CAF50;
            border-radius: 8px;
            color: #4CAF50;
            font-family: monospace;
            font-weight: 600;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .container {
                padding: 20px;
            }
        }

        /* Memorize Component Styles */
        .memorize-container {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            color: #333;
        }

        .memorize-btn-row {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .memorize-btn {
            padding: 10px 16px;
            font-family: inherit;
            font-size: 13px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: opacity 0.2s, transform 0.2s;
            font-weight: 600;
        }
        .memorize-btn:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }
        .memorize-btn-primary { background: linear-gradient(45deg, #FF6B35, #F7931E); color: #fff; }
        .memorize-btn-secondary { background: #666; color: #fff; }
        .memorize-btn-success { background: linear-gradient(45deg, #4CAF50, #45a049); color: #fff; }
        .memorize-btn-warning { background: linear-gradient(45deg, #ff9800, #e68900); color: #fff; }
        .memorize-btn-danger { background: linear-gradient(45deg, #f44336, #d32f2f); color: #fff; }

        .memorize-info-bar {
            display: flex;
            justify-content: space-between;
            padding: 10px 15px;
            background: #e8e8e8;
            border-radius: 6px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }

        .memorize-input-group {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .memorize-input {
            padding: 10px 15px;
            font-size: 14px;
            font-family: inherit;
            background: #fff;
            border: 2px solid #ddd;
            color: #333;
            border-radius: 6px;
            width: 150px;
        }
        .memorize-input:focus {
            outline: none;
            border-color: #FF6B35;
        }

        .memorize-content-display {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 15px;
            max-height: 250px;
            overflow-y: auto;
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 15px;
            margin-top: 15px;
        }
        .memorize-content-display.full {
            max-height: 400px;
        }

        .memorize-line {
            display: flex;
            padding: 3px 0;
        }
        .memorize-line-num {
            color: #999;
            min-width: 35px;
            text-align: right;
            margin-right: 12px;
            user-select: none;
        }
        .memorize-line-text {
            flex: 1;
            white-space: pre-wrap;
            word-break: break-word;
        }
        .memorize-line.highlighted {
            background: #e3f2fd;
            border-left: 3px solid #2196F3;
            padding-left: 10px;
            margin-left: -10px;
        }

        .memorize-selected-text {
            background: #e3f2fd;
            border-radius: 6px;
            padding: 15px;
            margin-top: 15px;
            font-size: 16px;
            line-height: 1.8;
            min-height: 80px;
        }
        .memorize-selected-text .memorize-line {
            padding: 4px 0;
        }

        .memorize-commands {
            background: #e8e8e8;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 11px;
            color: #666;
        }
        .memorize-commands code {
            color: #FF6B35;
            background: #fff;
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: 600;
        }

        .memorize-hidden { display: none; }

        .memorize-toggle-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .memorize-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }
        .memorize-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .memorize-slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #4CAF50;
            transition: .3s;
            border-radius: 24px;
        }
        .memorize-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .memorize-switch input:checked + .memorize-slider {
            background-color: #ff6b6b;
        }
        .memorize-switch input:checked + .memorize-slider:before {
            transform: translateX(20px);
        }
        .memorize-toggle-label {
            font-size: 12px;
            color: #666;
            font-weight: 600;
        }

        .memorize-speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .memorize-speed-control label {
            color: #666;
            font-size: 12px;
        }
        .memorize-select {
            padding: 6px 10px;
            font-family: inherit;
            font-size: 12px;
            background: #fff;
            border: 2px solid #ddd;
            color: #333;
            border-radius: 5px;
            cursor: pointer;
        }
        .memorize-select:focus {
            outline: none;
            border-color: #FF6B35;
        }

        .memorize-status {
            text-align: center;
            padding: 10px;
            background: #e3f2fd;
            border-radius: 6px;
            margin-top: 10px;
            color: #1976D2;
            font-weight: 600;
        }

        /* Toggle Slider Switch */
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider-toggle {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ddd;
            transition: .4s;
            border-radius: 26px;
        }

        .slider-toggle:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        input:checked + .slider-toggle {
            background: linear-gradient(45deg, #FF5722, #E64A19);
        }

        input:checked + .slider-toggle:before {
            transform: translateX(24px);
        }

        .toggle-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .toggle-label {
            font-size: 0.9em;
            color: #495057;
            font-weight: 500;
        }

        /* Compact Metronome */
        .metronome-section {
            background: #2f2f2f;
            border-radius: 8px;
            padding: 10px 15px;
            margin-top: 10px;
        }

        .metronome-section .counter {
            text-align: center;
            padding: 8px 0;
            background: #404040;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .metronome-section .counter .dot {
            width: 12px;
            height: 12px;
            display: inline-block;
            margin: 0 6px;
            background: #FFF;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
        }

        .metronome-section .counter .dot.active {
            background: #5ec2ff;
        }

        .metronome-section .controls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
            color: #FFF;
            font-size: 12px;
        }

        .metronome-section .controls label {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .metronome-section .controls input[type="text"] {
            width: 40px;
            border: 0;
            text-align: center;
            padding: 4px;
            background: #FFF;
            color: #222;
            border-radius: 3px;
            font-size: 12px;
        }

        .metronome-section .controls .bpm-minus,
        .metronome-section .controls .bpm-plus {
            cursor: pointer;
            padding: 0 5px;
            color: #222;
        }

        .metronome-section .controls .bpm-minus:hover,
        .metronome-section .controls .bpm-plus:hover {
            color: #FA6900;
        }

        .metronome-section .controls .bpm-wrapper {
            background: #FFF;
            padding: 2px 5px;
            border-radius: 3px;
            display: flex;
            align-items: center;
        }

        .metronome-section .play-btn,
        .metronome-section .tap-btn {
            padding: 6px 15px;
            border: 0;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            min-width: auto;
            flex: none;
        }

        .metronome-section .play-btn {
            background: #D6E26D;
            color: #3d430d;
        }

        .metronome-section .play-btn:hover {
            background: #e8efad;
        }

        .metronome-section .tap-btn {
            background: #888;
            color: #fbfbfb;
        }

        .metronome-section .tap-btn:hover {
            background: #959595;
        }

        .metronome-section .timer-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .metronome-section .timer-group input[type="checkbox"] {
            display: none;
        }

        .metronome-section .timer-group input[type="checkbox"] + label {
            display: inline-block;
            height: 12px;
            width: 12px;
            background: #FFF;
            cursor: pointer;
            position: relative;
        }

        .metronome-section .timer-group input[type="checkbox"]:checked + label:before {
            content: "";
            display: inline-block;
            width: 3px;
            height: 6px;
            background: #F38630;
            position: absolute;
            top: 0;
            left: 2px;
            transform: skewX(30deg);
        }

        .metronome-section .timer-group input[type="checkbox"]:checked + label:after {
            content: "";
            display: inline-block;
            width: 3px;
            height: 10px;
            background: #F38630;
            position: absolute;
            top: 0;
            left: 6px;
            transform: skewX(-30deg);
        }

        /* Link Pagination Navbar */
        .link-pagination-navbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            gap: 12px;
            z-index: 9999;
            padding: 0 20px;
            border-bottom: 3px solid #FF6B35;
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.5);
        }
        .link-pagination-navbar.active {
            display: flex;
        }
        .link-nav-btn {
            width: 36px;
            height: 36px;
            background: linear-gradient(45deg, #FF6B35, #F7931E);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            color: white;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .link-nav-btn:hover:not(:disabled) {
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.5);
        }
        .link-nav-btn:disabled {
            background: #555;
            opacity: 0.5;
            cursor: not-allowed;
        }
        .link-label-display {
            width: 450px;
            padding: 10px 20px;
            background: linear-gradient(45deg, #FF6B35, #F7931E);
            color: white;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .link-counter {
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            font-weight: bold;
            min-width: 50px;
            text-align: center;
        }
        .link-go-btn {
            padding: 8px 20px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            color: white;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s ease;
            margin-left: 10px;
        }
        .link-go-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.5);
        }
        .link-close-btn {
            width: 32px;
            height: 32px;
            background: #e74c3c;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            color: white;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 10px;
        }
        .link-close-btn:hover {
            background: #c0392b;
            transform: scale(1.1);
        }
        .pagination-auto-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: 15px;
            padding: 6px 12px;
            background: rgba(50, 50, 50, 0.9);
            border-radius: 20px;
            border: 1px solid rgba(255, 107, 53, 0.3);
        }
        .pagination-auto-label {
            font-size: 12px;
            color: #aaa;
            font-weight: 500;
        }
        .pagination-timer {
            font-size: 13px;
            color: #4CAF50;
            font-weight: bold;
            min-width: 40px;
            text-align: center;
        }
        .pagination-timer.active {
            color: #FF6B35;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        body.pagination-active {
            padding-top: 70px;
        }
        /* Saved Times Table Styles */
        #savedTimesTable {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 8px;
            background: rgba(30, 30, 30, 0.95);
            border-radius: 8px;
            overflow: hidden;
        }
        #savedTimesTable th {
            background: rgba(255, 193, 7, 0.2);
            color: #FFC107;
            padding: 8px 12px;
            text-align: left;
            font-weight: 600;
            font-size: 12px;
        }
        #savedTimesTable td {
            padding: 8px 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 13px;
        }
        #savedTimesTable tbody tr {
            cursor: pointer;
            transition: background 0.15s;
        }
        #savedTimesTable tbody tr:hover {
            background: rgba(255, 193, 7, 0.15);
        }
        .active-time-row {
            background: rgba(255, 193, 7, 0.3) !important;
        }
        .delete-time-btn {
            background: none;
            border: none;
            color: #f44336;
            cursor: pointer;
            font-size: 14px;
            padding: 2px 6px;
            border-radius: 4px;
            transition: background 0.15s;
        }
        .delete-time-btn:hover {
            background: rgba(244, 67, 54, 0.15);
        }
        /* Saved Videos Sidebar */
        .saved-videos-sidebar {
            position: fixed;
            left: 0;
            top: 0;
            width: 300px;
            height: 100vh;
            background: #1a1a2e;
            border-right: 1px solid #333;
            z-index: 1002;
            display: flex;
            flex-direction: column;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
        }
        .saved-videos-sidebar.open {
            transform: translateX(0);
        }
        .sidebar-header {
            padding: 15px;
            font-size: 14px;
            font-weight: bold;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #0d0d1a;
            color: #FFC107;
        }
        .sidebar-close-btn {
            background: transparent;
            border: none;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            padding: 5px 10px;
        }
        .sidebar-close-btn:hover {
            color: #f44336;
        }
        .sidebar-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
        .sidebar-item {
            padding: 12px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border-left: 3px solid transparent;
        }
        .sidebar-item:hover {
            background: rgba(255, 193, 7, 0.15);
            border-left-color: #FFC107;
        }
        .sidebar-item.active {
            background: rgba(255, 193, 7, 0.25);
            border-left-color: #FFC107;
        }
        .sidebar-item-url {
            font-size: 12px;
            color: #aaa;
            word-break: break-all;
            margin-bottom: 5px;
        }
        .sidebar-item-count {
            font-size: 11px;
            color: #FFC107;
            font-weight: 600;
        }
        .sidebar-item-delete {
            float: right;
            background: none;
            border: none;
            color: #f44336;
            cursor: pointer;
            font-size: 14px;
            opacity: 0.6;
        }
        .sidebar-item-delete:hover {
            opacity: 1;
        }
        .sidebar-toggle-btn {
            position: fixed;
            left: 10px;
            top: 10px;
            z-index: 1001;
            background: linear-gradient(45deg, #FFC107, #FF9800);
            border: none;
            color: #000;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 13px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        .sidebar-toggle-btn:hover {
            transform: scale(1.05);
        }
        .sidebar-empty {
            text-align: center;
            color: #666;
            padding: 20px;
            font-size: 13px;
        }
        .sidebar-save-btn {
            margin: 10px;
            padding: 10px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            border: none;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
        }
        .sidebar-save-btn:hover {
            opacity: 0.9;
        }
        .sidebar-access-code {
            padding: 10px;
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .sidebar-access-code input {
            width: 80px;
            padding: 8px 12px;
            font-size: 14px;
            border: 2px solid #FF9800;
            border-radius: 6px;
            background: #2a2a2a;
            color: white;
            outline: none;
        }
        .sidebar-access-code span {
            color: #888;
            font-size: 12px;
        }
        /* Audio Recording Controls */
        .record-btn {
            width: 40px;
            height: 40px;
            background: rgba(239, 68, 68, 0.9);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .record-btn:hover:not(:disabled) {
            background: rgba(220, 38, 38, 1);
            transform: scale(1.1);
        }

        .record-btn:disabled {
            background: rgba(100, 100, 100, 0.5);
            cursor: not-allowed;
        }

        .record-btn.recording {
            background: rgba(239, 68, 68, 1);
            animation: pulse-record 1s infinite;
        }

        @keyframes pulse-record {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
            }
            50% {
                box-shadow: 0 0 0 10px rgba(239, 68, 68, 0);
            }
        }

        .recording-indicator {
            color: #ef4444;
            font-size: 12px;
            font-weight: bold;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .processing-indicator {
            color: #fbbf24;
            font-size: 12px;
            font-weight: bold;
        }

        /* Dropbox Sidebar Styles */
        .dbx-sidebar {
            position: fixed;
            right: 0;
            top: 0;
            width: 280px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            border-left: 1px solid #333;
            z-index: 1001;
            background: #1a1a2e;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .dbx-sidebar.open {
            transform: translateX(0);
        }

        .dbx-sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 10px;
            font-size: 14px;
            font-weight: bold;
            border-bottom: 1px solid #333;
            color: #4da6ff;
        }

        .dbx-sidebar-header button {
            background: transparent;
            border: none;
            color: #888;
            font-size: 18px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .dbx-sidebar-header button:hover {
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
        }

        .dbx-sidebar-file-list {
            flex: 1;
            overflow-y: auto;
            padding: 0 5px;
        }

        .dbx-app-key-row {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .dbx-app-key-row input {
            flex: 1;
            padding: 10px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 14px;
            outline: none;
        }

        .dbx-app-key-row input:focus {
            border-color: #4da6ff;
        }

        .dbx-app-key-row button {
            padding: 10px 16px;
            background: #0061FF;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
        }

        .dbx-app-key-row button:hover {
            background: #0052d4;
        }

        .dbx-search-row {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .dbx-search-row input {
            flex: 1;
            padding: 10px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 14px;
            outline: none;
        }

        .dbx-search-row input:focus {
            border-color: #4da6ff;
        }

        .dbx-search-row button {
            padding: 10px 16px;
            background: #0061FF;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
        }

        .dbx-search-row button:hover {
            background: #0052d4;
        }

        .dbx-result-item.selected {
            background: rgba(77, 166, 255, 0.2);
            border-left: 3px solid #4da6ff;
        }

        .dbx-show-all-btn {
            background: transparent;
            border: none;
            color: #4da6ff;
            font-size: 12px;
            cursor: pointer;
            padding: 4px 8px;
        }

        .dbx-show-all-btn:hover {
            text-decoration: underline;
        }

        .dbx-breadcrumb {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            padding: 6px 10px;
            font-size: 12px;
            color: #888;
            gap: 2px;
        }

        .dbx-breadcrumb-link {
            color: #4da6ff;
            cursor: pointer;
            background: none;
            border: none;
            font-size: 12px;
            padding: 0;
        }

        .dbx-breadcrumb-link:hover {
            text-decoration: underline;
        }

        .dbx-breadcrumb-sep {
            color: #666;
            margin: 0 2px;
        }

        .dbx-result-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .dbx-result-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .dbx-result-icon {
            font-size: 18px;
            flex-shrink: 0;
        }

        .dbx-result-info {
            flex: 1;
            min-width: 0;
        }

        .dbx-result-name {
            font-size: 14px;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .dbx-result-path {
            font-size: 11px;
            color: #888;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .dbx-sign-out-btn {
            width: calc(100% - 20px);
            margin: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: #f87171;
            border: 1px solid rgba(248, 113, 113, 0.3);
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
        }

        .dbx-sign-out-btn:hover {
            background: rgba(248, 113, 113, 0.15);
        }

        .dbx-status {
            font-size: 12px;
            color: #888;
            margin-bottom: 10px;
            min-height: 18px;
        }

        .dbx-save-btn {
            background: #0061FF;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
        }

        .dbx-save-btn:hover {
            background: #0052d4;
        }

        #dbxContentTextarea {
            width: 100%;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 13px;
            padding: 12px;
            border: 2px solid rgba(255, 107, 53, 0.3);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.9);
            resize: vertical;
            outline: none;
            line-height: 1.5;
        }

        #dbxContentTextarea:focus {
            border-color: #0061FF;
        }

        .dbx-content-toolbar {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .dbx-content-toolbar button {
            padding: 5px 10px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            color: white;
            background: rgba(0, 0, 0, 0.15);
        }

        .dbx-content-toolbar button:hover {
            background: rgba(0, 0, 0, 0.25);
        }

        .dbx-content-toolbar .dbx-toggle-view-btn {
            background: #0061FF;
        }

        .dbx-content-toolbar .dbx-toggle-view-btn:hover {
            background: #0052d4;
        }

        #dbxContentView {
            display: none;
            max-height: 20lh;
            overflow-y: auto;
            padding: 12px;
            border: 2px solid rgba(255, 107, 53, 0.3);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.9);
            font-size: 13px;
            line-height: 1.7;
            color: #333;
        }

        #dbxContentView p {
            margin-bottom: 0.6em;
        }

        #dbxContentView p:last-child {
            margin-bottom: 0;
        }
    </style>
</head>
<body>
    <!-- Saved Videos Sidebar -->
    <div id="savedVideosSidebar" class="saved-videos-sidebar">
        <div class="sidebar-header">
            <span>üìº Saved Videos</span>
            <button class="sidebar-close-btn" onclick="toggleSavedVideosSidebar()">&times;</button>
        </div>
        <div class="sidebar-access-code">
            <input type="text" id="sidebarAccessCode" placeholder="123" autocomplete="off">
            <span>Access code</span>
        </div>
        <button class="sidebar-save-btn" onclick="saveCurrentVideoToSidebar()">üíæ Save Current Video</button>
        <div id="sidebarList" class="sidebar-list">
            <div class="sidebar-empty">No saved videos yet</div>
        </div>
    </div>
    <button class="sidebar-toggle-btn" onclick="toggleSavedVideosSidebar()">üìº Saved</button>

    <!-- Dropbox Sidebar -->
    <div class="dbx-sidebar" id="dbxSidebar">
        <div class="dbx-sidebar-header">
            <span>DROPBOX</span>
            <button id="dbxCloseBtn">&#10005;</button>
        </div>
        <!-- Sign-in (shown when not authenticated) -->
        <div id="dbxSignInSection" style="padding: 15px;">
            <div class="dbx-app-key-row" id="dbxAppKeyRow" style="display: none;">
                <input type="text" id="dbxAppKeyInput" placeholder="Dropbox App Key">
            </div>
            <div class="dbx-app-key-row">
                <button id="dbxSignInBtn" style="flex: 1;">Sign In</button>
            </div>
        </div>
        <!-- File browsing (shown when authenticated) -->
        <div id="dbxSearchSection" style="display: none; flex-direction: column; flex: 1; overflow: hidden;">
            <div class="dbx-status" id="dbxStatus" style="padding: 5px 10px 0;"></div>
            <div class="dbx-search-row" style="padding: 5px 10px 10px;">
                <input type="text" id="dbxSearchInput" placeholder="Search files...">
                <button id="dbxSearchBtn">Go</button>
                <button id="dbxCreateTxtBtn">+ txt</button>
            </div>
            <div class="dbx-breadcrumb" id="dbxBreadcrumb"></div>
            <div class="dbx-sidebar-file-list" id="dbxResults"></div>
            <button id="dbxSignOutBtn" class="dbx-sign-out-btn">Sign Out</button>
        </div>
    </div>

    <!-- Link Pagination Navbar -->
    <div id="linkPaginationNavbar" class="link-pagination-navbar">
        <button id="linkNextBtn" class="link-nav-btn" onclick="paginationNext()">‚ñ∂</button>
        <button id="linkPrevBtn" class="link-nav-btn" onclick="paginationPrev()">‚óÄ</button>
        <div id="linkLabelDisplay" class="link-label-display">Link Name</div>
        <span id="linkCounter" class="link-counter">1/1</span>
        <button class="link-go-btn" onclick="goAutoplayPending = true; loadCurrentPaginationLink()">Go</button>
        <button id="navbarLoopBtn" class="link-go-btn" style="background:linear-gradient(45deg,#9C27B0,#7B1FA2);margin-left:5px;padding:8px 14px;" onclick="toggleNavbarLoop(this)">üîÅ 3</button>
        <button class="link-go-btn" style="background:linear-gradient(45deg,#1565C0,#0D47A1);margin-left:5px;padding:8px 14px;" onclick="window.open('https://cdpn.io/pen/debug/KwVxmKR','_blank')">üîó reader</button>
        <!-- Auto-play toggle -->
        <div class="pagination-auto-group">
            <span class="pagination-auto-label">Auto</span>
            <label class="switch">
                <input type="checkbox" id="paginationAutoPlay">
                <span class="slider-toggle"></span>
            </label>
            <span id="paginationTimer" class="pagination-timer"></span>
        </div>
        <button class="link-close-btn" onclick="closePagination()">‚úï</button>
    </div>

    <div class="container">
        <h1>Youtube Viewer (and Looper)</h1>

        <!-- Clipboard Button -->
        <div style="text-align: center; margin-bottom: 20px; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; align-items: center;">
            <button id="loadDefaultBtn" class="jump-btn" style="display: none; background: linear-gradient(45deg, #4CAF50, #45a049); font-size: 13px; padding: 10px 19px;">üé¨ Load Default</button>
            <input type="text" id="accessCodeInput" placeholder="123" autocomplete="off" value="" style="width: 80px; padding: 8px 12px; font-size: 14px; border: 2px solid rgb(255, 152, 0); border-radius: 6px; background: rgb(42, 42, 42); color: white; outline: none;">
            <button id="loadYouTubeClipboardBtn" class="jump-btn" style="background: linear-gradient(45deg, #FF9800, #F57C00); font-size: 13px; padding: 10px 19px;">üìã Paste Media + Times</button>
            <button id="loadPasteFromCloudBtn" class="jump-btn" style="background: linear-gradient(45deg, #2196F3, #1976D2); font-size: 13px; padding: 10px 19px;">‚òÅÔ∏è Load Paste</button>
            <a id="textProcessorLink" href="https://cdpn.io/pen/debug/KwVxmKR" class="jump-btn" style="background: linear-gradient(45deg, #E91E63, #C2185B); font-size: 13px; padding: 10px 19px; text-decoration: none; color: white;">üìñ Bible Audio</a>
            <button id="cloudNotesToggleBtn" class="jump-btn" style="background: linear-gradient(45deg, #607D8B, #455A64); font-size: 13px; padding: 10px 19px;">‚òÅÔ∏è Cloud Notes</button>
            <button id="recordBtn" class="record-btn" title="Start Recording">üéôÔ∏è</button>
            <span id="recordingIndicator" class="recording-indicator" style="display:none;">REC</span>
            <span id="processingIndicator" class="processing-indicator" style="display:none;">Saving...</span>
        </div>

        <!-- Inline Cloud Notes Section -->
        <div id="cloudNotesSection" style="display:none; margin-bottom: 20px; padding: 15px; background: #1a1a2e; border-radius: 8px; border: 1px solid #333;">
            <div style="display: flex; gap: 10px; margin-bottom: 10px; align-items: center; flex-wrap: wrap;">
                <button id="cloudNotesLoadBtn" class="jump-btn" style="background: linear-gradient(45deg, #2196F3, #1976D2); font-size: 12px; padding: 8px 16px;">üì• Load</button>
                <button id="cloudNotesSaveBtn" class="jump-btn" style="background: linear-gradient(45deg, #4CAF50, #45a049); font-size: 12px; padding: 8px 16px;">üíæ Save</button>
                <span id="cloudNotesStatus" style="font-size: 13px; color: #888;"></span>
            </div>
            <textarea id="cloudNotesTextarea" placeholder="Your cloud notes..." style="width: 100%; min-height: 150px; padding: 12px; font-size: 14px; border: 2px solid #333; border-radius: 6px; background: #2a2a2a; color: #fff; resize: vertical; outline: none; font-family: inherit; line-height: 1.5; box-sizing: border-box;"></textarea>
        </div>

        <!-- Time Controls -->
        <div class="time-offset-control">
            <h4>‚è∞ Time Controls</h4>
            <div style="display: flex; align-items: center; justify-content: center; gap: 10px; flex-wrap: wrap; margin-bottom: 15px;">
                <label for="customTimesInput" style="color: #FFC107; font-weight: 600;">Add Media + Times:</label>
                <input type="text" id="customTimesInput" class="time-input" placeholder="URL (YouTube/Dropbox/etc), 1:15,2:00,3:10" style="width: 280px;">
                <button id="addTimesBtn" class="jump-btn" style="background: linear-gradient(45deg, #2196F3, #1976D2);">‚ûï Add</button>
                <button id="clearTimesBtn" class="jump-btn" style="display: none; background: linear-gradient(45deg, #f44336, #d32f2f); font-size: 12px; padding: 8px 16px;">üóëÔ∏è Clear All</button>
                <button id="copyCurrentStateBtn" class="jump-btn" style="background: linear-gradient(45deg, #8BC34A, #689F38); font-size: 12px; padding: 8px 16px;">üìã Copy URL+Times</button>
            </div>
        </div>

        <!-- Saved Times Section (directly above video) -->
        <div style="margin-bottom: 5px; padding: 10px; background: rgba(255, 193, 7, 0.05); border-radius: 10px;">
            <div style="display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 8px; flex-wrap: wrap;">
                <label style="color: #FFC107; font-weight: 600; font-size: 1rem; margin: 0;">‚ö° Saved Times:</label>
                <input type="text" id="savedTimeInput" class="time-input" placeholder="1:15" style="width: 70px; text-align: center; font-size: 12px; padding: 4px 6px;">
                <input type="text" id="savedTimeComment" class="time-input" placeholder="Comment" style="width: 120px; font-size: 12px; padding: 4px 6px;">
                <button id="addSingleTimeBtn" class="time-btn" style="background: linear-gradient(45deg, #4CAF50, #45a049); padding: 4px 10px; font-size: 10px;">+ Add</button>
                <button id="addCurrentTimeBtn" class="time-btn" style="background: linear-gradient(45deg, #2196F3, #1976D2); padding: 4px 10px; font-size: 10px;">+ Current</button>
                <button id="saveSavedTimesBtn" class="time-btn" style="display:none; background: linear-gradient(45deg, #FF9800, #F57C00); padding: 4px 10px; font-size: 10px;">üíæ Save</button>
                <button id="clearSavedTimesBtn" class="time-btn" style="background: linear-gradient(45deg, #f44336, #d32f2f); padding: 4px 10px; font-size: 10px;">üóëÔ∏è Clear</button>
            </div>
            <table id="savedTimesTable" style="display: none;">
                <thead>
                    <tr>
                        <th style="width: 30px;">#</th>
                        <th>Name</th>
                        <th style="width: 70px;">Time</th>
                        <th style="width: 40px;"></th>
                    </tr>
                </thead>
                <tbody id="savedTimesTableBody">
                </tbody>
            </table>
            <div id="savedTimesButtons" style="display: flex; justify-content: center; gap: 8px; flex-wrap: wrap;">
                <!-- Color buttons rendered dynamically -->
            </div>
        </div>

        <!-- YouTube Video Section -->
        <div class="youtube-section">
            <div class="youtube-container" id="youtubeContainer">
                <div id="youtube-player"></div>
            </div>

            <!-- HTML5 Media Player (for Dropbox videos/audio) -->
            <div class="media-container" id="mediaContainer">
                <video id="html5-player" controls controlsList="nodownload">
                    Your browser does not support the video tag.
                </video>
            </div>

            <div class="media-container" id="audioContainer">
                <audio id="audio-player" controls controlsList="nodownload">
                    Your browser does not support the audio tag.
                </audio>
            </div>

            <!-- Current Time Display (below video players) -->
            <div class="current-time-display" id="currentTimeDisplay" style="display: none; flex-wrap: wrap;">
                <button id="loopTimeMinus15" class="jump-btn" style="background: linear-gradient(45deg, #9E9E9E, #757575); padding: 4px 8px; font-size: 11px; margin-right: 4px;">‚àí15s</button>
                <input type="text" id="loopStartTime" class="time-input" placeholder="0:01" value="0:01" style="width: 65px; text-align: center; font-size: 12px; padding: 4px 6px; display: none;">
                <button id="jumpToZeroBtn" class="jump-btn" style="background: linear-gradient(45deg, #607D8B, #455A64); padding: 4px 8px; font-size: 11px;">0</button>
                <button id="loopTimePlus30" class="jump-btn" style="background: linear-gradient(45deg, #9E9E9E, #757575); padding: 4px 8px; font-size: 11px; margin-left: 4px;">+30s</button>
                <span class="time-value" id="currentTimeValue" style="margin-left: 15px;">--:--</span>
                <span class="time-label" style="margin-left: 15px;">playback</span>
                <span class="time-value" id="playbackTimeValue" style="color: #FFC107; font-weight: 700;">0:01</span>
                <button id="dropboxBtn" onclick="toggleDropboxSidebar()" style="margin-left: 15px; padding: 4px 12px; border: none; border-radius: 6px; background: linear-gradient(45deg, #0061FF, #0052d4); color: white; cursor: pointer; font-size: 11px; font-weight: 700;">DB</button>
                <button id="clipboardTimeBtn" onclick="jumpToClipboardTime()" style="margin-left: 8px; padding: 4px 12px; border: none; border-radius: 6px; background: linear-gradient(45deg, #E91E63, #C2185B); color: white; cursor: pointer; font-size: 11px; font-weight: 700;">üìãTime</button>
                <button id="clipboardPasteMediaBtn" onclick="pasteMediaOrTimes()" style="margin-left: 8px; padding: 4px 12px; border: none; border-radius: 6px; background: linear-gradient(45deg, #FF9800, #F57C00); color: white; cursor: pointer; font-size: 11px; font-weight: 700;">üìãc Link</button>
                <div style="width: 100%; display: flex; align-items: center; gap: 6px; margin-top: 6px;">
                    <button id="timer15sBtn" class="jump-btn" style="background: linear-gradient(45deg, #7E57C2, #5E35B1); padding: 6px 12px; font-size: 12px;">‚è±Ô∏è 15s</button>
                    <button id="timer30sBtn" class="jump-btn" style="background: linear-gradient(45deg, #00BCD4, #0097A7); padding: 6px 12px; font-size: 12px;">‚è±Ô∏è 30s</button>
                    <button id="timer3minBtn" class="jump-btn" style="background: linear-gradient(45deg, #FF9800, #F57C00); padding: 6px 12px; font-size: 12px;">‚è±Ô∏è 3m</button>
                    <select id="timerCustomSelect" style="display: none; padding: 5px 8px; font-size: 12px; border-radius: 6px; border: 2px solid #9C27B0; background: linear-gradient(45deg, #E1BEE7, #CE93D8); cursor: pointer; font-weight: 600;">
                        <option value="">‚è±Ô∏è Custom</option>
                        <option value="35">35s</option>
                        <option value="40">40s</option>
                        <option value="45">45s</option>
                        <option value="50">50s</option>
                    </select>
                </div>
                <span style="display: none;">
                    <label style="margin-left: 8px; cursor: pointer; font-size: 12px;">
                        <input type="radio" name="timerRepeat" value="40" style="cursor: pointer;"> 40 times
                    </label>
                    <label style="margin-left: 10px; cursor: pointer; font-size: 12px;">
                        <input type="radio" name="timerRepeat" value="8" style="cursor: pointer;"> 8 times
                    </label>
                    <label style="margin-left: 10px; cursor: pointer; font-size: 12px;">
                        <input type="radio" name="timerRepeat" value="30" checked style="cursor: pointer;"> 30 times
                    </label>
                    <label style="margin-left: 10px; cursor: pointer; font-size: 12px;">
                        <input type="radio" name="timerRepeat" value="80" style="cursor: pointer;"> 80 times
                    </label>
                </span>
            </div>

            <!-- Dropbox Content Textarea -->
            <div id="dbxContentSection" style="display: none; margin-top: 10px;">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 6px;">
                    <span id="dbxFileLabel" style="color: #0061FF; font-size: 13px; font-weight: 600;"></span>
                    <button id="dbxSaveBtn" class="dbx-save-btn" style="display: none;">Save &#8593; DB</button>
                    <div class="dbx-content-toolbar">
                        <button class="dbx-toggle-view-btn" id="dbxToggleViewBtn">View</button>
                        <button id="dbxFontPlus">A+</button>
                        <button id="dbxFontMinus">A-</button>
                    </div>
                </div>
                <textarea id="dbxContentTextarea" rows="13" placeholder="Dropbox file content will appear here..."></textarea>
                <div id="dbxContentView"></div>
            </div>

            <!-- Large +30s Playback Jump Button -->
            <button id="jumpPlus30Large" onclick="jumpPlayback(30); document.getElementById('timer15sBtn')?.focus();" style="width: 100%; padding: 15px; background: linear-gradient(45deg, #9E9E9E, #757575); color: white; border: none; border-radius: 12px; font-size: 18px; font-weight: 700; cursor: pointer; transition: all 0.3s ease; margin-top: 8px;">+30s</button>

            <!-- Next Saved Time Button -->
            <button id="nextSavedTimeBtn" onclick="goToNextSavedTime()" style="width: 100%; padding: 15px; background: linear-gradient(45deg, #7E57C2, #5E35B1); color: white; border: none; border-radius: 12px; font-size: 18px; font-weight: 700; cursor: pointer; transition: all 0.3s ease; margin-top: 6px;">Next Saved Time ‚ñ∂</button>

            <!-- URL History Navbar -->
            <div id="urlHistoryNavbar" style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; margin-top: 8px; background: rgba(0,0,0,0.05); border-radius: 10px; flex-wrap: wrap; font-size: 12px;">
                <span style="color: #9C27B0; font-weight: 600;">History:</span>
                <button id="urlHistPrevBtn" onclick="urlHistPrev()" style="padding: 4px 10px; border: none; border-radius: 6px; background: linear-gradient(45deg, #9C27B0, #7B1FA2); color: white; cursor: pointer; font-size: 12px; font-weight: 600;">&#9664;</button>
                <button id="urlHistNextBtn" onclick="urlHistNext()" style="padding: 4px 10px; border: none; border-radius: 6px; background: linear-gradient(45deg, #9C27B0, #7B1FA2); color: white; cursor: pointer; font-size: 12px; font-weight: 600;">&#9654;</button>
                <span id="urlHistLabel" style="flex: 1; color: #555; font-weight: 500; min-width: 100px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">No history</span>
                <span id="urlHistCounter" style="color: #9C27B0; font-weight: 600;">0/0</span>
                <button onclick="loadUrlHistCurrent()" style="padding: 4px 12px; border: none; border-radius: 6px; background: linear-gradient(45deg, #4CAF50, #45a049); color: white; cursor: pointer; font-size: 12px; font-weight: 600;">Go</button>
                <button onclick="clearUrlHistory()" style="padding: 4px 8px; border: none; border-radius: 6px; background: linear-gradient(45deg, #f44336, #d32f2f); color: white; cursor: pointer; font-size: 12px; font-weight: 600;">&#10005;</button>
            </div>
        </div>

        <!-- Status Display -->
        <div class="status-display" id="statusDisplay"></div>

        <!-- Keyboard Shortcuts Info -->
        <div style="background: linear-gradient(135deg, #673ab7 0%, #512da8 100%); color: white; padding: 10px 15px; border-radius: 8px; margin-bottom: 10px; font-size: 11px; line-height: 1.6;">
            <div style="font-weight: bold; margin-bottom: 6px; font-size: 12px;">‚å®Ô∏è Keyboard Shortcuts</div>
            <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                <div>
                    <span style="opacity: 0.9;">Timers:</span> <code style="background: rgba(255,255,255,0.2); padding: 2px 5px; border-radius: 3px;">q</code>=15s
                </div>
                <div>
                    <span style="opacity: 0.9;">¬±15s:</span> <code style="background: rgba(255,255,255,0.2); padding: 2px 5px; border-radius: 3px;">[</code> <code style="background: rgba(255,255,255,0.2); padding: 2px 5px; border-radius: 3px;">]</code>
                </div>
                <div>
                    <span style="opacity: 0.9;">Match:</span> <code style="background: rgba(255,255,255,0.2); padding: 2px 5px; border-radius: 3px;">\</code>
                </div>
                <div>
                    <span style="opacity: 0.9;">Focus:</span> <code style="background: rgba(255,255,255,0.2); padding: 2px 5px; border-radius: 3px;">Esc</code>
                </div>
                <div>
                    <span style="opacity: 0.9;">Calc:</span> <code style="background: rgba(255,255,255,0.2); padding: 2px 5px; border-radius: 3px;">2:01+10</code>=2:11
                </div>
            </div>
        </div>

        <!-- Birds Audio Player -->
        <div id="birdsAudioSection" style="background: linear-gradient(135deg, #4CAF50 0%, #2E7D32 100%); color: white; padding: 12px 15px; border-radius: 8px; margin-bottom: 10px;">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                <span style="font-weight: bold;">üê¶ Birds Chirping</span>
                <button id="birdsPlayBtn" onclick="toggleBirdsAudio()" style="background: rgba(255,255,255,0.2); border: 1px solid white; color: white; padding: 5px 12px; border-radius: 4px; cursor: pointer;">‚ñ∂ Play</button>
            </div>
            <audio id="birdsAudioElement" preload="metadata" controls style="width: 100%; height: 35px;"
                src="https://www.dropbox.com/scl/fi/2jzvla2xykyz2auqvcrcv/birds_chirping_23mins.mp3?rlkey=re6qjmobia9cr2ttf8nkmwkv1&st=96hl9yvs&raw=1">
            </audio>
        </div>

        <!-- Compact Metronome -->
        <div class="metronome-section">
            <div class="counter" id="metronomeCounter">
                <div class="dot active"></div>
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
            </div>
            <div class="controls">
                <label>BPM:
                    <span class="bpm-wrapper">
                        <span class="bpm-minus">‚àí</span>
                        <input type="text" value="60" class="bpm-input" id="metronomeBpm">
                        <span class="bpm-plus">+</span>
                    </span>
                </label>
                <label>Beat: <input type="text" value="4" class="ts-top" id="metronomeBeat"></label>
                <div class="timer-group">
                    <input type="checkbox" id="metronome-timer-check">
                    <label for="metronome-timer-check"></label>
                    Timer: <input type="text" value="60" class="timer" id="metronomeTimer">
                </div>
                <button class="tap-btn" id="metronomeTap">Tap</button>
                <button class="play-btn" id="metronomePlay">Play</button>
            </div>
        </div>

        <!-- Quick Links -->
        <div class="section" style="margin-top: 30px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <h3 class="section-title" style="margin: 0;">Quick Links</h3>
                <button id="toggleQuickLinksBtn" onclick="toggleQuickLinks()" style="padding: 4px 12px; border: none; border-radius: 6px; background: linear-gradient(45deg, #607D8B, #455A64); color: white; cursor: pointer; font-size: 12px; font-weight: 600;">‚ñº Minimize</button>
            </div>
            <div id="quickLinksContent">
                <button class="paste-btn" onclick="pasteQuickLinks()" style="margin-bottom: 15px; background: linear-gradient(45deg, #8B5CF6, #7C3AED);">üìã Paste Links from Clipboard</button>
                <div class="toggle-group">
                    <label class="switch">
                        <input type="checkbox" id="autoTimerToggle">
                        <span class="slider-toggle"></span>
                    </label>
                    <span class="toggle-label" id="autoTimerLabel">Normal Mode</span>
                </div>
                <div id="text-section" style="background: #f5f5f5; padding: 15px; border-radius: 8px; font-size: 1em; line-height: 1.6; white-space: pre-wrap;"></div>
            </div>
        </div>

        <!-- Cloud Links Section -->
        <div class="section" style="margin-top: 30px;">
            <h3 class="section-title">Cloud Links</h3>
            <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-bottom: 15px; align-items: center;">
                <button id="loadCloudBtn" class="paste-btn" onclick="loadLinksFromCloud()" style="background: linear-gradient(45deg, #2196F3, #1976D2);">‚òÅÔ∏è Load Cloud</button>
                <button id="saveCloudBtn" class="paste-btn" onclick="saveLinksToCloud()" style="background: linear-gradient(45deg, #4CAF50, #45a049);">üíæ Save to Cloud</button>
                <button id="sortCloudBtn" class="paste-btn" onclick="sortCloudLinks()" style="background: linear-gradient(45deg, #FF9800, #F57C00);">üî§ Sort A-Z</button>
                <button id="getYTTitleBtn" class="paste-btn" onclick="getAndAppendYouTubeTitle()" style="display: none; background: linear-gradient(45deg, #E91E63, #C2185B);">üé¨ Get YT Title</button>
            </div>
            <div id="cloud-section" style="background: #2a2a2a; color: #fff; padding: 15px; border-radius: 8px; font-size: 1em; line-height: 1.6; white-space: pre-wrap; min-height: 100px;"></div>

            <!-- Show Formatted Links Button -->
            <div style="margin-top: 15px; text-align: center;">
                <button id="toggleFormattedLinksBtn" class="paste-btn" onclick="toggleFormattedLinks()" style="background: linear-gradient(45deg, #9C27B0, #7B1FA2);">üìã Show Formatted Links</button>
            </div>

            <!-- Formatted Links Display (hidden by default) -->
            <div id="formatted-links-container" style="display: none; margin-top: 15px; position: relative;">
                <div style="background: #1e1e1e; color: #d4d4d4; padding: 15px; padding-top: 40px; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 0.9em; line-height: 1.5; white-space: pre-wrap; border: 1px solid #444; position: relative;">
                    <button id="copyFormattedLinksBtn" onclick="copyFormattedLinks()" style="position: absolute; top: 8px; right: 8px; padding: 6px 10px; border: none; border-radius: 4px; background: #2196F3; color: white; cursor: pointer; font-size: 14px; display: flex; align-items: center; gap: 5px;" title="Copy to clipboard">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                        </svg>
                        <span>Copy</span>
                    </button>
                    <div id="formatted-links-content"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- YouTube IFrame Player API -->
    <script src="https://www.youtube.com/iframe_api"></script>
    <!-- Template data loaded from external file for easy editing -->
    <script src="template_data.js"></script>
    <script>
        // ============================================
        // LINK PAGINATION SYSTEM
        // ============================================
        let allPaginationLinks = [];  // Array of {name, url}
        let currentPaginationIndex = 0;
        let paginationSource = null;  // 'text' or 'cloud'
        let goAutoplayPending = false; // Flag: Go button was clicked, play after embed + 500ms

        // Parse links from text-section template (with inline times support)
        function parseTextSectionLinks() {
            const lines = template_for_copy_and_paste.split('\n').map(l => l.trim()).filter(l => l);
            const entries = [];
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (line.startsWith('http://') || line.startsWith('https://')) {
                    entries.push(parseInlineTimes(line, ''));
                } else if (i + 1 < lines.length) {
                    const nextLine = lines[i + 1];
                    if (nextLine.startsWith('http://') || nextLine.startsWith('https://')) {
                        entries.push(parseInlineTimes(nextLine, line));
                        i++;
                    }
                }
            }
            return entries;
        }

        // Extract inline times from a URL (e.g. ...?v=xxx?1:00,2:00,3:00)
        function parseInlineTimes(rawUrl, name) {
            if (isYouTubeURL(rawUrl)) {
                const parts = rawUrl.split('?');
                if (parts.length >= 3) {
                    const timePart = parts[parts.length - 1];
                    const urlPart = parts.slice(0, -1).join('?');
                    if (/^\d/.test(timePart)) {
                        const times = timePart.split(',').map(t => t.trim()).filter(t => t);
                        return { name: name, url: urlPart, inlineTimes: times };
                    }
                }
            }
            return { name: name, url: rawUrl, inlineTimes: [] };
        }

        // Parse links from clipboard text (multi-line: markdown, YouTube with ?times, plain URLs, local paths)
        function parseClipboardLinks(text) {
            const lines = text.split('\n').map(l => l.trim()).filter(l => l);
            const entries = [];
            const markdownRe = /^!\[([^\]]*)\]\(([^)]+)\)$/;
            const mediaExtensions = ['.mp4', '.webm', '.mov', '.avi', '.mkv', '.m4v', '.mp3', '.wav', '.ogg', '.m4a', '.aac', '.flac'];

            for (const line of lines) {
                // Skip label lines like "link 2 :"
                if (/^link\s+\d+\s*:/i.test(line)) continue;

                // Markdown: ![name](url)
                const mdMatch = line.match(markdownRe);
                if (mdMatch) {
                    entries.push({ name: mdMatch[1], url: mdMatch[2], inlineTimes: [] });
                    continue;
                }

                // "Name, URL" or "Name, URL?times" format (e.g. "Edge, https://...?1:00,2:00")
                const nameUrlMatch = line.match(/^([^,]+),\s*(https?:\/\/.+)$/);
                if (nameUrlMatch && !nameUrlMatch[1].trim().startsWith('http')) {
                    const name = nameUrlMatch[1].trim();
                    const urlWithTimes = nameUrlMatch[2].trim();

                    if (isYouTubeURL(urlWithTimes)) {
                        const parts = urlWithTimes.split('?');
                        if (parts.length >= 3) {
                            const timePart = parts[parts.length - 1];
                            const urlPart = parts.slice(0, -1).join('?');
                            if (/^\d/.test(timePart)) {
                                const times = timePart.split(',').map(t => t.trim()).filter(t => t);
                                entries.push({ name: name, url: urlPart, inlineTimes: times });
                            } else {
                                entries.push({ name: name, url: urlWithTimes, inlineTimes: [] });
                            }
                        } else {
                            entries.push({ name: name, url: urlWithTimes, inlineTimes: [] });
                        }
                    } else {
                        entries.push({ name: name, url: urlWithTimes, inlineTimes: [] });
                    }
                    continue;
                }

                // YouTube URL with inline ?times (e.g. ...?v=xxx?3:55,4:39)
                // The second ? separates times from the URL
                if (isYouTubeURL(line)) {
                    const parts = line.split('?');
                    if (parts.length >= 3) {
                        // URL is everything up to the last ? segment, times are in the last segment
                        const timePart = parts[parts.length - 1];
                        const urlPart = parts.slice(0, -1).join('?');
                        // Check if the last segment looks like times (contains digits and colons/commas)
                        if (/^\d/.test(timePart)) {
                            const times = timePart.split(',').map(t => t.trim()).filter(t => t);
                            entries.push({ name: '', url: urlPart, inlineTimes: times });
                        } else {
                            entries.push({ name: '', url: line, inlineTimes: [] });
                        }
                    } else {
                        entries.push({ name: '', url: line, inlineTimes: [] });
                    }
                    continue;
                }

                // Plain URL (http/https)
                if (line.startsWith('http://') || line.startsWith('https://')) {
                    entries.push({ name: '', url: line, inlineTimes: [] });
                    continue;
                }

                // Relative path with media extension
                const lowerLine = line.toLowerCase();
                if (mediaExtensions.some(ext => lowerLine.endsWith(ext))) {
                    entries.push({ name: '', url: line, inlineTimes: [] });
                    continue;
                }
            }
            return entries;
        }

        // Activate pagination from clipboard links
        function activatePaginationFromClipboard(links) {
            allPaginationLinks = links;
            paginationSource = 'clipboard';
            currentPaginationIndex = 0;
            showPagination();
            loadCurrentPaginationLink();
            loadTimesForCurrentVideo();
        }

        // Activate pagination from text-section
        function activatePaginationFromText(clickedUrl) {
            allPaginationLinks = parseTextSectionLinks();
            paginationSource = 'text';
            // Store inline times into allSavedTimes for links that have them
            for (const link of allPaginationLinks) {
                if (link.inlineTimes && link.inlineTimes.length > 0) {
                    let key = null;
                    if (isYouTubeURL(link.url)) {
                        key = extractVideoId(link.url);
                    } else {
                        key = btoa(link.url).replace(/[/+=]/g, '_');
                    }
                    if (key) {
                        const timesData = link.inlineTimes.map(t => ({ time: t.trim(), name: '' }));
                        allSavedTimes[key] = timesData;
                    }
                }
            }
            // Match by clean URL or raw URL (clickedUrl may still have inline times)
            let index = allPaginationLinks.findIndex(l => l.url === clickedUrl);
            if (index < 0) {
                // clickedUrl has times appended ‚Äî match by checking if clickedUrl starts with the clean url
                index = allPaginationLinks.findIndex(l => clickedUrl.startsWith(l.url));
            }
            currentPaginationIndex = index >= 0 ? index : 0;
            showPagination();
            loadCurrentPaginationLink();
        }

        // Activate pagination from cloud-section
        function activatePaginationFromCloud(clickedUrl) {
            allPaginationLinks = parseCloudLinks();
            paginationSource = 'cloud';
            // Store inline times into allSavedTimes for links that have them
            for (const link of allPaginationLinks) {
                if (link.inlineTimes && link.inlineTimes.length > 0) {
                    let key = null;
                    if (isYouTubeURL(link.url)) {
                        key = extractVideoId(link.url);
                    } else {
                        key = btoa(link.url).replace(/[/+=]/g, '_');
                    }
                    if (key) {
                        const timesData = link.inlineTimes.map(t => ({ time: t.trim(), name: '' }));
                        allSavedTimes[key] = timesData;
                    }
                }
            }
            // Match by clean URL or raw URL
            let index = allPaginationLinks.findIndex(l => l.url === clickedUrl);
            if (index < 0) {
                index = allPaginationLinks.findIndex(l => clickedUrl.startsWith(l.url));
            }
            currentPaginationIndex = index >= 0 ? index : 0;
            showPagination();
            loadCurrentPaginationLink();
        }

        // Show the pagination navbar
        function showPagination() {
            const navbar = document.getElementById('linkPaginationNavbar');
            navbar.classList.add('active');
            document.body.classList.add('pagination-active');
            updatePaginationDisplay();
            // Start auto-play timer if enabled
            const toggle = document.getElementById('paginationAutoPlay');
            if (toggle && toggle.checked) {
                startAutoPlayTimer();
            }
        }

        // Close pagination
        function closePagination() {
            const navbar = document.getElementById('linkPaginationNavbar');
            navbar.classList.remove('active');
            document.body.classList.remove('pagination-active');
            allPaginationLinks = [];
            currentPaginationIndex = 0;
            stopAutoPlayTimer();
        }

        // Update the pagination display
        function updatePaginationDisplay() {
            if (allPaginationLinks.length === 0) return;
            const current = allPaginationLinks[currentPaginationIndex];
            const labelDisplay = document.getElementById('linkLabelDisplay');
            const counter = document.getElementById('linkCounter');
            const prevBtn = document.getElementById('linkPrevBtn');
            const nextBtn = document.getElementById('linkNextBtn');

            labelDisplay.textContent = current.name || current.url;
            labelDisplay.title = current.url;
            counter.textContent = `${currentPaginationIndex + 1}/${allPaginationLinks.length}`;
            prevBtn.disabled = currentPaginationIndex === 0;
            nextBtn.disabled = currentPaginationIndex === allPaginationLinks.length - 1;
        }

        // Navigate to previous link (display only, no embed)
        function paginationPrev() {
            if (currentPaginationIndex > 0) {
                currentPaginationIndex--;
                updatePaginationDisplay();
                resetAutoPlayTimer();
            }
        }

        // Navigate to next link (display only, no embed)
        function paginationNext() {
            if (currentPaginationIndex < allPaginationLinks.length - 1) {
                currentPaginationIndex++;
                updatePaginationDisplay();
                resetAutoPlayTimer();
            }
        }

        // Load the current pagination link (auto-embed)
        // autoplay: if true, video will start playing automatically
        function loadCurrentPaginationLink(autoplay = false) {
            if (allPaginationLinks.length === 0) return;
            const current = allPaginationLinks[currentPaginationIndex];
            loadMediaFromUrl(current.url, autoplay);
            loadTimesForCurrentVideo();
        }

        function toggleNavbarLoop(buttonElement) {
            // If this timer is already running, cancel it
            if (timerTimeout && timerButtonRef === buttonElement) {
                clearTimeout(timerTimeout);
                timerTimeout = null;
                timerLoopsRemaining = 0;
                buttonElement.textContent = 'üîÅ 3';
                buttonElement.style.background = 'linear-gradient(45deg, #9C27B0, #7B1FA2)';
                showStatus('Navbar loop cancelled', 'info');
                return;
            }

            // If another timer is running, cancel it first
            if (timerTimeout) {
                clearTimeout(timerTimeout);
                resetTimerButton();
            }

            // Set repeat radio to 8
            const radio8 = document.querySelector('input[name="timerRepeat"][value="8"]');
            if (radio8) radio8.checked = true;

            // Setup 3-minute timer with 8 repeats
            timerLabel = 'üîÅ 3';
            timerDefaultBg = 'linear-gradient(45deg, #9C27B0, #7B1FA2)';
            timerDurationMs = 180000;
            timerTotalLoops = 8;
            timerLoopsRemaining = 8;
            timerButtonRef = buttonElement;
            timerAdvanceEvery = 0;
            timerAdvanceSeconds = 0;

            // Get start time from loopStartTime input
            const loopStartTimeInput = document.getElementById('loopStartTime');
            const timeStr = loopStartTimeInput.value.trim();
            timerStartTime = parseTimeToSeconds(timeStr);
            if (timerStartTime === null) timerStartTime = 0;

            // Jump to start and begin looping
            jumpToYouTubeTime(timerStartTime);
            startTimerLoop();
        }

        // ============ AUTO-PLAY TIMER ============
        const AUTO_ADVANCE_SECONDS = 180; // 3 minutes
        const FADE_OUT_SECONDS = 3; // Start fading 3 seconds before switch
        let autoPlayTimerId = null;
        let autoPlayTimeRemaining = AUTO_ADVANCE_SECONDS;
        let isFadingOut = false;
        let fadeIntervalId = null;

        // Load saved preference
        function loadAutoPlayPreference() {
            const saved = localStorage.getItem('paginationAutoPlay');
            const toggle = document.getElementById('paginationAutoPlay');
            if (toggle && saved === 'true') {
                toggle.checked = true;
                startAutoPlayTimer();
            }
        }

        // Format time as M:SS
        function formatAutoPlayTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Fade out volume over duration (in ms)
        function fadeOutVolume(duration = 2500, callback) {
            if (isFadingOut) return;
            isFadingOut = true;

            let currentVolume = 100;
            const steps = 25;
            const stepTime = duration / steps;
            const volumeStep = 100 / steps;

            // Try to get current volume from YouTube player
            if (player && typeof player.getVolume === 'function') {
                try {
                    currentVolume = player.getVolume();
                } catch (e) {}
            }

            const initialVolume = currentVolume;

            fadeIntervalId = setInterval(() => {
                currentVolume -= (initialVolume / steps);
                if (currentVolume <= 0) {
                    currentVolume = 0;
                    clearInterval(fadeIntervalId);
                    fadeIntervalId = null;
                    isFadingOut = false;
                    if (callback) callback();
                }

                // Set volume on YouTube player
                if (player && typeof player.setVolume === 'function') {
                    try {
                        player.setVolume(Math.max(0, currentVolume));
                    } catch (e) {}
                }

                // Set volume on HTML5 video/audio
                const html5Video = document.querySelector('#html5Container video');
                const html5Audio = document.querySelector('#html5Container audio');
                if (html5Video) html5Video.volume = Math.max(0, currentVolume / 100);
                if (html5Audio) html5Audio.volume = Math.max(0, currentVolume / 100);
            }, stepTime);
        }

        // Reset volume to full
        function resetVolume() {
            if (fadeIntervalId) {
                clearInterval(fadeIntervalId);
                fadeIntervalId = null;
            }
            isFadingOut = false;

            if (player && typeof player.setVolume === 'function') {
                try {
                    player.setVolume(100);
                } catch (e) {}
            }
        }

        // Update timer display
        function updateTimerDisplay() {
            const timerEl = document.getElementById('paginationTimer');
            const toggle = document.getElementById('paginationAutoPlay');
            if (!timerEl) return;

            if (toggle && toggle.checked && currentPaginationIndex < allPaginationLinks.length - 1) {
                timerEl.textContent = formatAutoPlayTime(autoPlayTimeRemaining);
                timerEl.classList.add('active');
            } else {
                timerEl.textContent = '';
                timerEl.classList.remove('active');
            }
        }

        // Start the auto-play timer
        function startAutoPlayTimer() {
            stopAutoPlayTimer();
            autoPlayTimeRemaining = AUTO_ADVANCE_SECONDS;
            updateTimerDisplay();
            resetVolume();

            const toggle = document.getElementById('paginationAutoPlay');
            if (!toggle || !toggle.checked) return;
            if (currentPaginationIndex >= allPaginationLinks.length - 1) return;

            autoPlayTimerId = setInterval(() => {
                autoPlayTimeRemaining--;
                updateTimerDisplay();

                // Start fading out volume 3 seconds before switch
                if (autoPlayTimeRemaining === FADE_OUT_SECONDS && !isFadingOut) {
                    fadeOutVolume(2500);
                }

                if (autoPlayTimeRemaining <= 0) {
                    // Time's up - advance to next and load it with autoplay
                    paginationNext();
                    loadCurrentPaginationLink(true); // true = autoplay
                    autoPlayTimeRemaining = AUTO_ADVANCE_SECONDS;
                    resetVolume();

                    // Stop if we reached the last link
                    if (currentPaginationIndex >= allPaginationLinks.length - 1) {
                        stopAutoPlayTimer();
                    }
                }
            }, 1000);
        }

        // Stop the auto-play timer
        function stopAutoPlayTimer() {
            if (autoPlayTimerId) {
                clearInterval(autoPlayTimerId);
                autoPlayTimerId = null;
            }
            if (fadeIntervalId) {
                clearInterval(fadeIntervalId);
                fadeIntervalId = null;
            }
            isFadingOut = false;
            updateTimerDisplay();
        }

        // Reset timer when navigating
        function resetAutoPlayTimer() {
            const toggle = document.getElementById('paginationAutoPlay');
            if (toggle && toggle.checked) {
                startAutoPlayTimer();
            }
        }

        // Auto-play toggle event listener
        document.addEventListener('DOMContentLoaded', function() {
            const toggle = document.getElementById('paginationAutoPlay');
            if (toggle) {
                toggle.addEventListener('change', function() {
                    localStorage.setItem('paginationAutoPlay', this.checked.toString());
                    if (this.checked) {
                        startAutoPlayTimer();
                    } else {
                        stopAutoPlayTimer();
                    }
                });
            }
            loadAutoPlayPreference();
        });
        // ============ END AUTO-PLAY TIMER ============

        // Keyboard navigation for pagination - REMOVED to avoid conflicts with timer controls
        // ============================================

        // Populate text-section with clickable URLs
        function toggleQuickLinks() {
            const content = document.getElementById('quickLinksContent');
            const btn = document.getElementById('toggleQuickLinksBtn');
            if (content.style.display === 'none') {
                content.style.display = '';
                btn.textContent = '‚ñº Minimize';
            } else {
                content.style.display = 'none';
                btn.textContent = '‚ñ∂ Show';
            }
        }

        function populateQuickLinks() {
            const container = document.getElementById('text-section');
            const lines = template_for_copy_and_paste.split('\n');

            container.innerHTML = ''; // Clear existing content
            let lastLabel = '';

            lines.forEach((line, index) => {
                const trimmedLine = line.trim();

                // Check if the line is a URL
                if (trimmedLine.startsWith('http://') || trimmedLine.startsWith('https://')) {
                    // Create clickable span for URL
                    const span = document.createElement('span');
                    span.textContent = trimmedLine;
                    span.style.cssText = 'cursor: pointer; color: #2196F3; text-decoration: underline; transition: all 0.2s ease;';
                    span.dataset.url = trimmedLine;
                    span.dataset.label = lastLabel;

                    // Hover effects
                    span.addEventListener('mouseenter', function() {
                        this.style.color = '#FF6B35';
                        this.style.background = 'rgba(255, 107, 53, 0.1)';
                    });
                    span.addEventListener('mouseleave', function() {
                        this.style.color = '#2196F3';
                        this.style.background = 'transparent';
                    });

                    // Click to activate pagination and load video
                    span.addEventListener('click', function() {
                        const url = this.dataset.url;
                        const title = this.dataset.label || url;
                        const tMatch = url.match(/[?&]t=(\d+)s?/);
                        const autoTimerToggle = document.getElementById('autoTimerToggle');

                        // Save to URL history
                        saveToUrlHistory(url, title);

                        // Visual feedback
                        const originalText = this.textContent;
                        const originalColor = this.style.color;
                        this.textContent = '‚úÖ Loading...';
                        this.style.color = '#4CAF50';

                        setTimeout(() => {
                            this.textContent = originalText;
                            this.style.color = originalColor;
                        }, 1500);

                        // Activate pagination and load video
                        activatePaginationFromText(url);

                        // Check if Auto Timer mode is ON
                        if (autoTimerToggle && autoTimerToggle.checked) {
                            // Select the 80 times radio button
                            const radio80 = document.querySelector('input[name="timerRepeat"][value="80"]');
                            if (radio80) {
                                radio80.checked = true;
                            }

                            // Extract timestamp from URL (e.g., &t=958s or ?t=505s)
                            let startSeconds = 0;
                            const timeMatch = url.match(/[?&]t=(\d+)s?/);
                            if (timeMatch) {
                                startSeconds = parseInt(timeMatch[1], 10);
                            }

                            // Wait for video to load, then seek to timestamp and start timer
                            setTimeout(() => {
                                // Jump to the extracted timestamp and update loop start time
                                if (startSeconds > 0) {
                                    const mins = Math.floor(startSeconds / 60);
                                    const secs = startSeconds % 60;
                                    const timeStr = `${mins}:${secs.toString().padStart(2, '0')}`;
                                    document.getElementById('loopStartTime').value = timeStr;
                                    document.getElementById('playbackTimeValue').textContent = timeStr;
                                    jumpToYouTubeTime(startSeconds);
                                }

                                // Trigger the 15s timer button after a short delay
                                setTimeout(() => {
                                    const timer15sBtn = document.getElementById('timer15sBtn');
                                    if (timer15sBtn) {
                                        timer15sBtn.click();
                                    }
                                }, 500);
                            }, 1500);
                        }
                    });

                    container.appendChild(span);
                } else {
                    // Regular text (label)
                    lastLabel = trimmedLine;
                    const textNode = document.createTextNode(trimmedLine);
                    container.appendChild(textNode);
                }

                // Add line break after each line (except the last)
                if (index < lines.length - 1) {
                    container.appendChild(document.createElement('br'));
                }
            });
        }

        // Initialize quick links on page load
        populateQuickLinks();

        // Auto Timer toggle event listener
        const autoTimerToggle = document.getElementById('autoTimerToggle');
        if (autoTimerToggle) {
            autoTimerToggle.addEventListener('change', function() {
                const label = document.getElementById('autoTimerLabel');
                if (this.checked) {
                    label.textContent = 'Auto Timer Mode (50x)';
                    label.style.color = '#FF5722';
                    label.style.fontWeight = '600';
                } else {
                    label.textContent = 'Normal Mode';
                    label.style.color = '#495057';
                    label.style.fontWeight = '500';
                }
            });
        }

        // Paste quick links from clipboard (format: "name, url" or "name,url")
        function pasteQuickLinks() {
            navigator.clipboard.readText()
                .then(text => {
                    if (!text.trim()) {
                        alert('Clipboard is empty. Please copy some links first.');
                        return;
                    }

                    const lines = text.split('\n');
                    let parsedContent = '';
                    let linkCount = 0;

                    lines.forEach(line => {
                        const trimmedLine = line.trim();

                        // Skip empty lines
                        if (!trimmedLine) return;

                        // Check if line contains a URL (has http:// or https://)
                        if (trimmedLine.includes('http://') || trimmedLine.includes('https://')) {
                            // Try to parse "name, url" or "name,url" format
                            const commaIndex = trimmedLine.indexOf(',');
                            if (commaIndex > 0) {
                                const name = trimmedLine.substring(0, commaIndex).trim();
                                const url = trimmedLine.substring(commaIndex + 1).trim();

                                if (url.startsWith('http://') || url.startsWith('https://')) {
                                    parsedContent += name + '\n' + url + '\n';
                                    linkCount++;
                                }
                            } else if (trimmedLine.startsWith('http://') || trimmedLine.startsWith('https://')) {
                                // Just a URL without a name
                                parsedContent += trimmedLine + '\n';
                                linkCount++;
                            }
                        }
                        // Skip lines that don't contain URLs (treat as notes)
                    });

                    if (linkCount === 0) {
                        alert('No valid links found. Expected format: "name, url" (e.g., "notion, https://www.notion.so")');
                        return;
                    }

                    // Update the template and re-populate
                    template_for_copy_and_paste = parsedContent.trim();
                    populateQuickLinks();

                    console.log(`Loaded ${linkCount} links from clipboard`);
                })
                .catch(err => {
                    console.error('Failed to read clipboard contents:', err);
                    alert('Unable to access clipboard. Please check browser permissions or paste manually.');
                });
        }

        // ============================================
        // CLOUD STORAGE FUNCTIONS (Vercel Blob)
        // ============================================

        const CLOUD_LINKS_FILENAME = 'youtube_quick_links.txt';
        const PASTE_MEDIA_FILENAME = 'youtube_paste_media.txt';
        let cloudLinksContent = '';

        // Populate cloud-section with clickable URLs (similar to text-section)
        // Parse cloud content into array of {name, url, inlineTimes, rawUrl} objects
        function parseCloudLinks() {
            const lines = cloudLinksContent.split('\n').map(l => l.trim()).filter(l => l);
            const entries = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (line.startsWith('http://') || line.startsWith('https://')) {
                    const parsed = parseInlineTimes(line, '');
                    parsed.rawUrl = line;
                    entries.push(parsed);
                } else if (i + 1 < lines.length) {
                    const nextLine = lines[i + 1];
                    if (nextLine.startsWith('http://') || nextLine.startsWith('https://')) {
                        const parsed = parseInlineTimes(nextLine, line);
                        parsed.rawUrl = nextLine;
                        entries.push(parsed);
                        i++;
                    }
                }
            }
            return entries;
        }

        // Rebuild cloud content from entries array (preserves inline times via rawUrl)
        function rebuildCloudContent(entries) {
            return entries.map(e => {
                const url = e.rawUrl || e.url;
                return e.name ? `${e.name}\n${url}` : url;
            }).join('\n');
        }

        function populateCloudLinks() {
            const container = document.getElementById('cloud-section');
            if (!cloudLinksContent.trim()) {
                container.innerHTML = '<span style="color: #888;">No cloud links. Load from cloud or paste & save.</span>';
                return;
            }

            const entries = parseCloudLinks();
            container.innerHTML = '';

            entries.forEach((entry, index) => {
                // Create row container
                const row = document.createElement('div');
                row.style.cssText = 'display: flex; align-items: center; gap: 8px; padding: 8px; margin-bottom: 5px; background: rgba(255,255,255,0.05); border-radius: 6px; flex-wrap: wrap;';
                row.dataset.index = index;

                // Name span (editable on click)
                const nameSpan = document.createElement('span');
                nameSpan.textContent = entry.name || '(no name)';
                nameSpan.style.cssText = 'color: #FFC107; font-weight: 600; min-width: 100px; cursor: pointer;';
                nameSpan.title = 'Click to edit name';
                nameSpan.addEventListener('click', function() {
                    const newName = prompt('Edit name:', entry.name);
                    if (newName !== null) {
                        entry.name = newName;
                        cloudLinksContent = rebuildCloudContent(parseCloudLinks().map((e, i) => i === index ? entry : e));
                        populateCloudLinks();
                        // Auto-save if access code present
                        const accessCode = document.getElementById('accessCodeInput').value.trim();
                        if (accessCode) saveLinksToCloud();
                    }
                });

                // URL span (clickable to load video)
                const displayUrl = entry.rawUrl || entry.url;
                const urlSpan = document.createElement('span');
                urlSpan.textContent = displayUrl.length > 50 ? displayUrl.substring(0, 50) + '...' : displayUrl;
                urlSpan.style.cssText = 'flex: 1; color: #64B5F6; text-decoration: underline; cursor: pointer; min-width: 150px;';
                urlSpan.title = displayUrl;
                urlSpan.addEventListener('click', function() {
                    // Save to URL history
                    saveToUrlHistory(entry.url, entry.name || entry.url);

                    // Visual feedback
                    urlSpan.textContent = '‚úÖ Loading...';
                    urlSpan.style.color = '#4CAF50';

                    // Activate pagination and load video
                    activatePaginationFromCloud(entry.url);

                    setTimeout(() => {
                        urlSpan.textContent = displayUrl.length > 50 ? displayUrl.substring(0, 50) + '...' : displayUrl;
                        urlSpan.style.color = '#64B5F6';
                    }, 1500);
                });
                urlSpan.addEventListener('mouseenter', function() {
                    this.style.color = '#FF6B35';
                    this.style.background = 'rgba(255, 107, 53, 0.2)';
                });
                urlSpan.addEventListener('mouseleave', function() {
                    this.style.color = '#64B5F6';
                    this.style.background = 'transparent';
                });

                // Edit name button
                const editNameBtn = document.createElement('button');
                editNameBtn.textContent = '‚úèÔ∏è';
                editNameBtn.style.cssText = 'padding: 4px 8px; border: none; border-radius: 4px; background: #2196F3; color: white; cursor: pointer; font-size: 12px;';
                editNameBtn.title = 'Edit name';
                editNameBtn.addEventListener('click', function() {
                    const newName = prompt('Edit name:', entry.name);
                    if (newName !== null) {
                        const allEntries = parseCloudLinks();
                        allEntries[index].name = newName;
                        cloudLinksContent = rebuildCloudContent(allEntries);
                        populateCloudLinks();
                        const accessCode = document.getElementById('accessCodeInput').value.trim();
                        if (accessCode) saveLinksToCloud();
                    }
                });

                // Edit URL button
                const editUrlBtn = document.createElement('button');
                editUrlBtn.textContent = 'üîó';
                editUrlBtn.style.cssText = 'padding: 4px 8px; border: none; border-radius: 4px; background: #FF9800; color: white; cursor: pointer; font-size: 12px;';
                editUrlBtn.title = 'Edit URL (add times with ?1:00,2:00,3:00)';
                editUrlBtn.addEventListener('click', function() {
                    const currentRaw = entry.rawUrl || entry.url;
                    const newUrl = prompt('Edit URL (add times like ?1:00,2:00,3:00):', currentRaw);
                    if (newUrl !== null && newUrl.trim()) {
                        const allEntries = parseCloudLinks();
                        const parsed = parseInlineTimes(newUrl.trim(), allEntries[index].name);
                        parsed.rawUrl = newUrl.trim();
                        allEntries[index] = parsed;
                        cloudLinksContent = rebuildCloudContent(allEntries);
                        populateCloudLinks();
                        const accessCode = document.getElementById('accessCodeInput').value.trim();
                        if (accessCode) saveLinksToCloud();
                    }
                });

                // Delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'üóëÔ∏è';
                deleteBtn.style.cssText = 'padding: 4px 8px; border: none; border-radius: 4px; background: #f44336; color: white; cursor: pointer; font-size: 12px;';
                deleteBtn.title = 'Delete entry';
                deleteBtn.addEventListener('click', function() {
                    if (confirm(`Delete "${entry.name || entry.url}"?`)) {
                        const allEntries = parseCloudLinks();
                        // Delete by URL match instead of index (safer)
                        const filtered = allEntries.filter(e => e.url !== entry.url);
                        cloudLinksContent = rebuildCloudContent(filtered);
                        populateCloudLinks();
                        const accessCode = document.getElementById('accessCodeInput').value.trim();
                        if (accessCode) saveLinksToCloud();
                    }
                });

                row.appendChild(nameSpan);
                row.appendChild(urlSpan);
                row.appendChild(editNameBtn);
                row.appendChild(editUrlBtn);
                row.appendChild(deleteBtn);
                container.appendChild(row);
            });
        }

        // Load links from Vercel Blob
        async function loadLinksFromCloud() {
            const loadBtn = document.getElementById('loadCloudBtn');
            loadBtn.textContent = '‚è≥ Loading...';
            loadBtn.disabled = true;

            try {
                const response = await fetch('/api/files');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                const files = data.files || {};

                if (files[CLOUD_LINKS_FILENAME]) {
                    cloudLinksContent = files[CLOUD_LINKS_FILENAME];
                    populateCloudLinks();
                    loadBtn.textContent = '‚úì Loaded!';
                    loadBtn.style.background = 'linear-gradient(45deg, #4CAF50, #45a049)';
                    console.log('‚úì Loaded cloud links');
                } else {
                    cloudLinksContent = '';
                    populateCloudLinks();
                    loadBtn.textContent = '‚òÅÔ∏è No file';
                    console.log('No cloud links file found');
                }

                setTimeout(() => {
                    loadBtn.textContent = '‚òÅÔ∏è Load Cloud';
                    loadBtn.style.background = 'linear-gradient(45deg, #2196F3, #1976D2)';
                    loadBtn.disabled = false;
                }, 2000);

            } catch (error) {
                console.error('Error loading from cloud:', error);
                loadBtn.textContent = '‚ùå Error';
                setTimeout(() => {
                    loadBtn.textContent = '‚òÅÔ∏è Load Cloud';
                    loadBtn.style.background = 'linear-gradient(45deg, #2196F3, #1976D2)';
                    loadBtn.disabled = false;
                }, 2000);
            }
        }

        // Save links to Vercel Blob
        async function saveLinksToCloud() {
            const accessCode = document.getElementById('accessCodeInput').value.trim();
            if (!accessCode) {
                alert('Please enter access code');
                return false;
            }

            const saveBtn = document.getElementById('saveCloudBtn');
            saveBtn.textContent = '‚è≥ Saving...';
            saveBtn.disabled = true;

            try {
                const response = await fetch('/api/files', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        filename: CLOUD_LINKS_FILENAME,
                        content: cloudLinksContent,
                        accessCode: accessCode
                    })
                });

                const data = await response.json();

                if (!response.ok) {
                    if (response.status === 401) {
                        alert('Invalid access code');
                        saveBtn.textContent = '‚ùå Invalid Code';
                    } else {
                        throw new Error(data.error || 'Failed to save');
                    }
                } else {
                    saveBtn.textContent = '‚úì Saved!';
                    saveBtn.style.background = 'linear-gradient(45deg, #4CAF50, #45a049)';
                    console.log('‚úì Saved cloud links');
                }

                setTimeout(() => {
                    saveBtn.textContent = 'üíæ Save to Cloud';
                    saveBtn.style.background = 'linear-gradient(45deg, #4CAF50, #45a049)';
                    saveBtn.disabled = false;
                }, 2000);

                return response.ok;

            } catch (error) {
                console.error('Error saving to cloud:', error);
                saveBtn.textContent = '‚ùå Error';
                setTimeout(() => {
                    saveBtn.textContent = 'üíæ Save to Cloud';
                    saveBtn.style.background = 'linear-gradient(45deg, #4CAF50, #45a049)';
                    saveBtn.disabled = false;
                }, 2000);
                return false;
            }
        }

        // Save paste media text to cloud (silent background save)
        async function savePasteToCloud(rawText) {
            if (!rawText || !rawText.trim()) return;

            try {
                const response = await fetch('/api/files', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        filename: PASTE_MEDIA_FILENAME,
                        content: rawText,
                        accessCode: '123'
                    })
                });
                if (response.ok) {
                    console.log('‚òÅÔ∏è Paste media saved to cloud');
                } else {
                    console.error('‚òÅÔ∏è Failed to save paste media:', response.status);
                }
            } catch (error) {
                console.error('‚òÅÔ∏è Error saving paste media to cloud:', error);
            }
        }

        // Load paste media text from cloud
        async function loadPasteFromCloud() {
            const btn = document.getElementById('loadPasteFromCloudBtn');
            const originalText = btn.textContent;
            btn.textContent = '‚è≥ Loading...';
            btn.disabled = true;

            try {
                const response = await fetch('/api/files');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                const files = data.files || {};

                if (files[PASTE_MEDIA_FILENAME]) {
                    const rawText = files[PASTE_MEDIA_FILENAME];
                    document.getElementById('pasteMediaTextarea').value = rawText;

                    const success = processClipboardText(rawText);
                    if (success) {
                        btn.textContent = '‚úÖ Loaded!';
                        btn.style.background = 'linear-gradient(45deg, #4CAF50, #45a049)';
                        console.log('‚òÅÔ∏è Loaded paste media from cloud');
                    } else {
                        btn.textContent = '‚ùå Invalid';
                    }
                } else {
                    btn.textContent = '‚òÅÔ∏è No file';
                    console.log('No paste media file found in cloud');
                }

                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = 'linear-gradient(45deg, #2196F3, #1976D2)';
                    btn.disabled = false;
                }, 2000);

            } catch (error) {
                console.error('Error loading paste media from cloud:', error);
                btn.textContent = '‚ùå Error';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = 'linear-gradient(45deg, #2196F3, #1976D2)';
                    btn.disabled = false;
                }, 2000);
            }
        }

        // Sort cloud links alphabetically by name
        async function sortCloudLinks() {
            const sortBtn = document.getElementById('sortCloudBtn');
            sortBtn.textContent = '‚è≥ Sorting...';
            sortBtn.disabled = true;

            try {
                const entries = parseCloudLinks();

                // Sort alphabetically by name (case-insensitive)
                // Entries without names go to the end
                entries.sort((a, b) => {
                    const nameA = (a.name || '').toLowerCase();
                    const nameB = (b.name || '').toLowerCase();

                    // If both have no name, maintain order
                    if (!nameA && !nameB) return 0;
                    // No name goes to end
                    if (!nameA) return 1;
                    if (!nameB) return -1;
                    // Alphabetical sort
                    return nameA.localeCompare(nameB);
                });

                cloudLinksContent = rebuildCloudContent(entries);
                populateCloudLinks();

                sortBtn.textContent = '‚úì Sorted!';
                sortBtn.style.background = 'linear-gradient(45deg, #4CAF50, #45a049)';

                // Auto-save to cloud if access code present
                const accessCode = document.getElementById('accessCodeInput').value.trim();
                if (accessCode) {
                    await saveLinksToCloud();
                }

                setTimeout(() => {
                    sortBtn.textContent = 'üî§ Sort A-Z';
                    sortBtn.style.background = 'linear-gradient(45deg, #FF9800, #F57C00)';
                    sortBtn.disabled = false;
                }, 2000);

            } catch (error) {
                console.error('Error sorting cloud links:', error);
                sortBtn.textContent = '‚ùå Error';
                setTimeout(() => {
                    sortBtn.textContent = 'üî§ Sort A-Z';
                    sortBtn.style.background = 'linear-gradient(45deg, #FF9800, #F57C00)';
                    sortBtn.disabled = false;
                }, 2000);
            }
        }

        // Append current video + title to cloud links and auto-save
        async function appendToCloudAndSave(title, url) {
            const accessCode = document.getElementById('accessCodeInput').value.trim();
            if (!accessCode) return; // Only append if access code is present

            // Append to cloud content
            const newEntry = title + '\n' + url;
            if (cloudLinksContent.trim()) {
                cloudLinksContent = cloudLinksContent.trim() + '\n' + newEntry;
            } else {
                cloudLinksContent = newEntry;
            }

            // Update the UI
            populateCloudLinks();

            // Auto-save to cloud
            await saveLinksToCloud();
        }

        // Get YouTube video title using IFrame API and append to cloud
        async function getAndAppendYouTubeTitle() {
            if (!player || !playerReady || typeof player.getVideoData !== 'function') {
                showStatus('No YouTube video loaded', 'error');
                return;
            }

            const videoData = player.getVideoData();
            const title = videoData.title || 'Untitled';
            const videoId = videoData.video_id;
            const url = `https://www.youtube.com/watch?v=${videoId}`;

            // Copy to clipboard
            const entry = title + '\n' + url;
            try {
                await navigator.clipboard.writeText(entry);
                showStatus(`Copied: ${title}`, 'success');
            } catch (err) {
                console.error('Failed to copy:', err);
            }

            // Append to cloud and save
            await appendToCloudAndSave(title, url);
        }

        // ============================================
        // FORMATTED LINKS DISPLAY FUNCTIONS
        // ============================================

        // Generate formatted text from cloud links content
        function generateFormattedLinks() {
            if (!cloudLinksContent.trim()) {
                return '(No links available)';
            }

            const entries = parseCloudLinks();
            const formatted = entries.map(entry => {
                if (entry.name) {
                    return `${entry.name}\n${entry.url}`;
                }
                return entry.url;
            }).join('\n');

            return formatted;
        }

        // Toggle the formatted links display
        function toggleFormattedLinks() {
            const container = document.getElementById('formatted-links-container');
            const content = document.getElementById('formatted-links-content');
            const btn = document.getElementById('toggleFormattedLinksBtn');

            if (container.style.display === 'none') {
                // Show the formatted links
                const formatted = generateFormattedLinks();
                content.textContent = formatted;
                container.style.display = 'block';
                btn.textContent = 'üìã Hide Formatted Links';
                btn.style.background = 'linear-gradient(45deg, #E91E63, #C2185B)';
            } else {
                // Hide the formatted links
                container.style.display = 'none';
                btn.textContent = 'üìã Show Formatted Links';
                btn.style.background = 'linear-gradient(45deg, #9C27B0, #7B1FA2)';
            }
        }

        // Copy formatted links to clipboard
        async function copyFormattedLinks() {
            const content = document.getElementById('formatted-links-content');
            const copyBtn = document.getElementById('copyFormattedLinksBtn');
            const originalHTML = copyBtn.innerHTML;

            try {
                await navigator.clipboard.writeText(content.textContent);
                copyBtn.innerHTML = '<span>‚úì Copied!</span>';
                copyBtn.style.background = '#4CAF50';

                setTimeout(() => {
                    copyBtn.innerHTML = originalHTML;
                    copyBtn.style.background = '#2196F3';
                }, 2000);
            } catch (err) {
                console.error('Failed to copy:', err);
                copyBtn.innerHTML = '<span>‚ùå Error</span>';
                copyBtn.style.background = '#f44336';

                setTimeout(() => {
                    copyBtn.innerHTML = originalHTML;
                    copyBtn.style.background = '#2196F3';
                }, 2000);
            }
        }

        // Auto-load cloud links on page load
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                loadLinksFromCloud();
            }, 1000);
        });

        // ===== Birds Audio Player (LG TV compatible) =====
        function toggleBirdsAudio() {
            const audio = document.getElementById('birdsAudioElement');
            const btn = document.getElementById('birdsPlayBtn');

            if (audio.paused) {
                // LG TV fix: force load before playing
                audio.load();
                audio.volume = 0.3;
                audio.muted = false;

                audio.play().then(() => {
                    btn.textContent = '‚è∏ Pause';
                }).catch(err => {
                    console.error('Audio play failed:', err);
                    // Try reload on error
                    audio.load();
                    setTimeout(() => {
                        audio.play();
                        btn.textContent = '‚è∏ Pause';
                    }, 500);
                });
            } else {
                audio.pause();
                btn.textContent = '‚ñ∂ Play';
            }
        }

        // Initialize birds audio on page load (LG TV fix)
        document.addEventListener('DOMContentLoaded', function() {
            const birdsAudio = document.getElementById('birdsAudioElement');
            if (birdsAudio) {
                // Force initial load for LG TV compatibility
                birdsAudio.load();
                birdsAudio.volume = 0.3;
                birdsAudio.muted = false;

                // Sync button state with audio events
                birdsAudio.addEventListener('play', () => {
                    document.getElementById('birdsPlayBtn').textContent = '‚è∏ Pause';
                });
                birdsAudio.addEventListener('pause', () => {
                    document.getElementById('birdsPlayBtn').textContent = '‚ñ∂ Play';
                });
                birdsAudio.addEventListener('ended', () => {
                    document.getElementById('birdsPlayBtn').textContent = '‚ñ∂ Play';
                });
            }
        });
    </script>
    <script>
        // ===== IndexedDB Wrapper Class =====
        class IndexedDBWrapper {
            constructor() {
                this.dbConnections = new Map();
                this.availableKeys = new Set();
                this.DB_VERSION = 1;
                this.STORE_NAME = 'content';
            }

            async openDatabase(databaseName) {
                if (this.dbConnections.has(databaseName)) {
                    return this.dbConnections.get(databaseName);
                }

                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(databaseName, this.DB_VERSION);

                    request.onerror = () => reject(new Error(`Failed to open database: ${request.error?.message}`));

                    request.onsuccess = () => {
                        const db = request.result;
                        this.dbConnections.set(databaseName, db);

                        db.onclose = () => this.dbConnections.delete(databaseName);
                        db.onerror = (event) => console.error(`Database error for ${databaseName}:`, event);

                        resolve(db);
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;

                        if (!db.objectStoreNames.contains(this.STORE_NAME)) {
                            const store = db.createObjectStore(this.STORE_NAME, { keyPath: 'key' });
                            store.createIndex('timestamp', 'timestamp', { unique: false });
                            store.createIndex('dataType', 'dataType', { unique: false });
                        }
                    };
                });
            }

            async set(databaseName, key, data) {
                const db = await this.openDatabase(databaseName);

                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([this.STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(this.STORE_NAME);

                    const record = {
                        key,
                        data,
                        timestamp: Date.now(),
                        dataType: typeof data,
                        lastModified: new Date().toISOString()
                    };

                    const request = store.put(record);
                    request.onsuccess = () => {
                        console.log(`‚úì Saved: ${databaseName}/${key}`);
                        resolve();
                    };
                    request.onerror = () => reject(new Error(`Save failed: ${request.error?.message}`));
                });
            }

            async get(databaseName, key) {
                const db = await this.openDatabase(databaseName);

                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([this.STORE_NAME], 'readonly');
                    const store = transaction.objectStore(this.STORE_NAME);
                    const request = store.get(key);

                    request.onsuccess = () => {
                        const result = request.result;

                        resolve({
                            exists: () => !!result,
                            val: () => result ? result.data : null,
                            key: () => key,
                            ref: { key }
                        });
                    };

                    request.onerror = () => reject(new Error(`Get failed: ${request.error?.message}`));
                });
            }

            async delete(databaseName, key) {
                const db = await this.openDatabase(databaseName);

                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([this.STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(this.STORE_NAME);
                    const request = store.delete(key);

                    request.onsuccess = () => {
                        console.log(`‚úì Deleted: ${databaseName}/${key}`);
                        resolve();
                    };
                    request.onerror = () => reject(new Error(`Delete failed: ${request.error?.message}`));
                });
            }

            async getAllKeys(databaseName) {
                const db = await this.openDatabase(databaseName);

                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([this.STORE_NAME], 'readonly');
                    const store = transaction.objectStore(this.STORE_NAME);
                    const request = store.getAllKeys();

                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(new Error(`Get keys failed: ${request.error?.message}`));
                });
            }
        }

        // Initialize IndexedDB wrapper
        const indexedDBWrapper = new IndexedDBWrapper();
        const DB_NAME = 'basketballStorage';
        const SAVED_TIMES_KEY = 'youtubelichess';

        // Extract YouTube video ID from URL
        function extractVideoId(url) {
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
            const match = url.match(regExp);
            return (match && match[2].length === 11) ? match[2] : null;
        }

        // Default basketball tutorial video with times
        const defaultVideo = "https://www.youtube.com/watch?v=DYM8HNXMq-A, 1:15, 2:30, 4:45, 6:00";

        // Player state
        let player = null;
        let playerReady = false;
        let currentVideoId = null;
        let timeUpdateInterval = null;
        let lastKnownTime = 0;
        let seekDetectionThreshold = 1.5; // If time jumps more than 1.5 seconds, it's a seek
        let skipSeekDetection = false; // Flag to skip seek detection during timer rewinds
        let lastClickedTime = null; // Track the last clicked timestamp
        let currentTimeIndex = -1; // Track current position in saved times for cycling

        // Media player state (for HTML5 video/audio)
        let playerType = 'youtube'; // 'youtube', 'video', or 'audio'
        let html5Player = null;
        let audioPlayer = null;
        let currentMediaUrl = null;

        // Saved Times cloud persistence
        const SAVED_TIMES_FILENAME = 'saved-times.json';
        let allSavedTimes = {}; // { videoId: [{time, name}, ...], ... }
        let savedTimesData = []; // Current video's times (reference into allSavedTimes)

        // Get the current media key (YouTube video ID or base64-encoded URL)
        function getCurrentMediaKey() {
            if (playerType === 'youtube' && currentVideoId) {
                return currentVideoId;
            } else if ((playerType === 'video' || playerType === 'audio') && currentMediaUrl) {
                return btoa(currentMediaUrl).replace(/[/+=]/g, '_');
            }
            return null;
        }

        // Loop Timer variables
        let loopTimerActive = false;
        let loopTimerInterval = null;
        let loopResetInterval = null;
        let loopTimerEndTime = null;
        let loopBaseTime = null;
        let loopNextResetTime = null;
        let loopIntervalSeconds = 13;
        let currentLoopButton = null;
        const originalPageTitle = document.title;

        // Beep sound for timer completion
        const beepSound = new Audio('https://assets.codepen.io/1075762/beep1.mp3');

        // ============ CONFIG: Text Processor Link ============
        const TEXT_PROCESSOR_URL = "https://cdpn.io/pen/debug/KwVxmKR";  // Bible Audio
        // =====================================================

        // Set the Text Processor link to open in new tab
        const textProcessorLink = document.getElementById('textProcessorLink');
        if (textProcessorLink) {
            textProcessorLink.addEventListener('click', function(e) {
                e.preventDefault();
                window.open(TEXT_PROCESSOR_URL, '_blank');
            });
        }



        // Store last cleaned transcript for restore functionality
        let lastCleanedTranscript = null;

        // Check URL parameters on page load
        function checkUrlParameters() {
            // Get everything after the ? in the URL
            const queryString = window.location.search;

            if (!queryString || queryString.length <= 1) return null;

            // Remove the leading '?' and decode the URL
            const param = decodeURIComponent(queryString.substring(1));

            // The parameter should be the full URL + times string
            // Example: ?https://www.youtube.com/watch?v=m0e43ItU8oo,3:10,3:40,1:10

            // Clean up any extra whitespace
            const cleanParam = param.trim();

            console.log('üé¨ URL parameter found (original):', param);
            console.log('üé¨ URL parameter found (cleaned):', cleanParam);
            return cleanParam;
        }

        // Check for timer parameter in URL (e.g., &timer=25)
        function checkTimerParameter() {
            const queryString = window.location.search;
            if (!queryString) return null;

            // Look for &timer=X or timer=X in the URL
            const timerMatch = queryString.match(/[&?]timer=(\d+)/);
            if (timerMatch) {
                return parseInt(timerMatch[1]);
            }
            return null;
        }

        // Auto-trigger timer based on URL parameter
        function autoTriggerTimer() {
            const timerMinutes = checkTimerParameter();
            if (timerMinutes === 5) {
                console.log('üîÑ Auto-triggering 5min timer from URL parameter');
                const btn = document.getElementById('loopTimer5minBtn');
                if (btn) btn.click();
            } else if (timerMinutes === 25) {
                console.log('üîÑ Auto-triggering 25min timer from URL parameter');
                const btn = document.getElementById('loopTimer25minBtn');
                if (btn) btn.click();
            }
        }

        // ============================================
        // URL HISTORY (last 5 URLs with pagination)
        // ============================================
        let urlHistoryArr = [];
        let urlHistoryIndex = -1;
        const URL_HISTORY_MAX = 10;

        function saveToUrlHistory(url, title) {
            if (!url) return;
            title = title || url;
            // Remove duplicate if exists
            urlHistoryArr = urlHistoryArr.filter(item => item.url !== url);
            // Add to end (most recent)
            urlHistoryArr.push({ url: url, title: title });
            // Enforce max 5 (FIFO - remove oldest)
            if (urlHistoryArr.length > URL_HISTORY_MAX) {
                urlHistoryArr.shift();
            }
            // Point to newest entry
            urlHistoryIndex = urlHistoryArr.length - 1;
            // Save to localStorage
            localStorage.setItem('urlHistory', JSON.stringify(urlHistoryArr));
            localStorage.setItem('lastLoadedVideo', url);
            updateUrlHistNavbar();
        }

        function loadUrlHistory() {
            try {
                const saved = localStorage.getItem('urlHistory');
                if (saved) {
                    urlHistoryArr = JSON.parse(saved);
                    if (urlHistoryArr.length > 0) {
                        urlHistoryIndex = urlHistoryArr.length - 1;
                    }
                }
            } catch (e) {
                console.error('Failed to load URL history:', e);
                urlHistoryArr = [];
            }
            updateUrlHistNavbar();
        }

        function urlHistNext() {
            if (urlHistoryArr.length === 0) return;
            urlHistoryIndex = (urlHistoryIndex + 1) % urlHistoryArr.length;
            updateUrlHistNavbar();
        }

        function urlHistPrev() {
            if (urlHistoryArr.length === 0) return;
            urlHistoryIndex = (urlHistoryIndex - 1 + urlHistoryArr.length) % urlHistoryArr.length;
            updateUrlHistNavbar();
        }

        function loadUrlHistCurrent() {
            if (urlHistoryArr.length === 0 || urlHistoryIndex < 0) return;
            const entry = urlHistoryArr[urlHistoryIndex];
            loadMediaFromUrl(entry.url);
            localStorage.setItem('lastLoadedVideo', entry.url);
            showStatus('Loaded from history: ' + entry.title, 'success');
        }

        function updateUrlHistNavbar() {
            const label = document.getElementById('urlHistLabel');
            const counter = document.getElementById('urlHistCounter');
            if (urlHistoryArr.length === 0) {
                label.textContent = 'No history';
                counter.textContent = '0/0';
            } else {
                const entry = urlHistoryArr[urlHistoryIndex];
                label.textContent = entry.title || entry.url;
                label.title = entry.url;
                counter.textContent = (urlHistoryIndex + 1) + '/' + urlHistoryArr.length;
            }
        }

        function clearUrlHistory() {
            urlHistoryArr = [];
            urlHistoryIndex = -1;
            localStorage.removeItem('urlHistory');
            updateUrlHistNavbar();
            showStatus('URL history cleared', 'success');
        }

        // YouTube API ready callback
        function onYouTubeIframeAPIReady() {
            console.log('üé¨ YouTube IFrame API ready');

            // Check if URL parameter exists
            const urlParam = checkUrlParameters();

            if (urlParam) {
                // Load from URL parameter with a delay to ensure API is ready
                console.log('üé¨ Loading from URL parameter:', urlParam);

                // Remove timer parameter from the URL param before processing
                const cleanUrlParam = urlParam.replace(/&timer=\d+/g, '');

                // Wait a bit for the API to be fully ready
                setTimeout(async () => {
                    try {
                        // Check if URL parameter includes times (has commas)
                        const hasTimes = cleanUrlParam.includes(',');

                        // Save to IndexedDB only if URL includes times
                        processVideoAndTimes(cleanUrlParam, hasTimes);

                        // If URL doesn't have times, load saved times from IndexedDB
                        if (!hasTimes) {
                            const savedTimes = await loadSavedTimesFromIndexedDB();
                            if (savedTimes && savedTimes.length > 0) {
                                renderSavedTimes(savedTimes);
                                console.log('üíæ Loaded saved times from IndexedDB (URL had no times)');
                            }
                        }

                        showStatus('Loaded from URL!', 'success');

                        // Auto-trigger timer after video loads (with extra delay for player ready)
                        setTimeout(() => {
                            autoTriggerTimer();
                        }, 2000);
                    } catch (error) {
                        console.error('üé¨ Error loading from URL:', error);
                        showStatus('Error loading from URL, loading default', 'error');
                        loadDefaultVideo();
                    }
                }, 500);
            } else {
                // Try to load saved times from IndexedDB
                loadSavedTimesFromIndexedDB().then(savedTimes => {
                    if (savedTimes && savedTimes.length > 0) {
                        // Load saved times from IndexedDB
                        renderSavedTimes(savedTimes);
                        console.log('üíæ Loaded saved times from IndexedDB on page load');
                    } else {
                        // Try last loaded video from localStorage, else default
                        const lastVideo = localStorage.getItem('lastLoadedVideo');
                        if (lastVideo) {
                            console.log('üé¨ Restoring last loaded video:', lastVideo);
                            loadMediaFromUrl(lastVideo);
                        } else {
                            loadDefaultVideo();
                        }
                    }
                });
            }
        }

        // YouTube player ready callback
        function onPlayerReady(event) {
            console.log('üé¨ YouTube Player ready');
            console.log('üé¨ DEBUG: Player object:', event.target);
            playerReady = true;
            player = event.target;

            // Go button: delay 500ms then auto-play
            if (goAutoplayPending) {
                goAutoplayPending = false;
                setTimeout(() => {
                    if (player && typeof player.playVideo === 'function') {
                        player.playVideo();
                    }
                }, 500);
            }

            startTimeUpdates();
            document.getElementById('currentTimeDisplay').style.display = 'flex';

            // Auto-append to cloud if access code is present
            const accessCode = document.getElementById('accessCodeInput');
            if (accessCode && accessCode.value.trim()) {
                setTimeout(async () => {
                    try {
                        const videoData = player.getVideoData();
                        const title = videoData.title || 'Untitled';
                        const videoId = videoData.video_id;
                        const url = `https://www.youtube.com/watch?v=${videoId}`;

                        // Check if this URL already exists in cloud content
                        if (!cloudLinksContent.includes(url)) {
                            await appendToCloudAndSave(title, url);
                            showStatus(`Auto-saved: ${title}`, 'success');
                        }
                    } catch (err) {
                        console.error('Auto-append failed:', err);
                    }
                }, 1500); // Wait for video data to be available
            }
        }

        // YouTube player state change callback
        function onPlayerStateChange(event) {
            console.log('üé¨ YouTube Player state changed:', event.data);

            if (event.data === YT.PlayerState.PLAYING) {
                startTimeUpdates();
            } else if (event.data === YT.PlayerState.PAUSED || event.data === YT.PlayerState.ENDED) {
                stopTimeUpdates();
            }
        }

        // Load default video
        function loadDefaultVideo() {
            console.log('üé¨ DEBUG: Loading defaultVideo:', defaultVideo);

            // Process the default video string (same format as addCustomTimes)
            processVideoAndTimes(defaultVideo);

            showStatus('Default video loaded!', 'success');
        }

        // Shared function to process "URL, time1, time2, ..." format
        function processVideoAndTimes(inputString, saveToCloud = false) {
            console.log('üé¨ DEBUG processVideoAndTimes called with:', inputString);

            // Clear saved times and reset index
            savedTimesData = [];
            currentTimeIndex = -1;

            // Split by comma and process each entry
            const entries = inputString.split(',').map(t => t.trim()).filter(t => t);

            console.log('üé¨ DEBUG entries after split:', entries);

            if (entries.length === 0) {
                console.log('üé¨ DEBUG no entries found');
                return;
            }

            // Check if the first element is a media URL
            const firstEntry = entries[0];
            let timeEntries = entries;

            console.log('üé¨ DEBUG firstEntry:', firstEntry);

            // Detect media type
            const mediaType = detectMediaType(firstEntry);

            console.log('üé¨ DEBUG mediaType detected:', mediaType);

            if (mediaType) {
                // It's a valid media URL - load it
                if (mediaType === 'youtube') {
                    // YouTube URL - use YouTube player
                    const videoId = extractVideoId(firstEntry);

                    console.log('üé¨ DEBUG videoId extracted:', videoId);

                    if (videoId) {
                        currentVideoId = videoId;
                        switchToPlayer('youtube');

                        // Clear and recreate player
                        const youtubeContainer = document.getElementById('youtubeContainer');
                        youtubeContainer.innerHTML = '<div id="youtube-player"></div>';

                        const initPlayer = () => {
                            if (typeof YT !== 'undefined' && YT.Player) {
                                player = new YT.Player('youtube-player', {
                                    height: '100%',
                                    width: '100%',
                                    videoId: videoId,
                                    playerVars: {
                                        'enablejsapi': 1,
                                        'rel': 0,
                                        'modestbranding': 1,
                                        'iv_load_policy': 3
                                    },
                                    events: {
                                        'onReady': onPlayerReady,
                                        'onStateChange': onPlayerStateChange
                                    }
                                });

                                console.log('üé¨ YouTube video loaded:', firstEntry);
                            } else {
                                setTimeout(initPlayer, 500);
                            }
                        };

                        initPlayer();
                    }
                } else {
                    // Direct media URL (video or audio) - use HTML5 player
                    switchToPlayer(mediaType);
                    loadHTML5Media(firstEntry, mediaType);
                    console.log('üé¨ Media loaded:', firstEntry, 'type:', mediaType);
                }

                // Remove the URL from the entries, keep only the times
                timeEntries = entries.slice(1);
            }

            // Process time entries into savedTimesData
            timeEntries.forEach((timeEntry) => {
                const timeStr = timeEntry.trim();
                const seconds = parseTimeToSeconds(timeStr);
                if (seconds !== null) {
                    savedTimesData.push({ time: timeStr, name: '' });
                }
            });

            // Update allSavedTimes
            const key = getCurrentMediaKey();
            if (key) allSavedTimes[key] = savedTimesData;

            // Render the table
            renderSavedTimesTable();

            if (savedTimesData.length > 0 && saveToCloud) {
                saveSavedTimesToCloud();
            }
        }

        // Setup event listeners
        document.addEventListener('DOMContentLoaded', function() {
            // Load saved times from cloud on page init
            loadSavedTimesFromCloud();

            // Sync access code inputs (main page and sidebar)
            const mainAccessCode = document.getElementById('accessCodeInput');
            const sidebarAccessCode = document.getElementById('sidebarAccessCode');
            if (mainAccessCode && sidebarAccessCode) {
                mainAccessCode.addEventListener('input', () => {
                    sidebarAccessCode.value = mainAccessCode.value;
                });
                sidebarAccessCode.addEventListener('input', () => {
                    mainAccessCode.value = sidebarAccessCode.value;
                });
            }

            // Load URL history navbar
            loadUrlHistory();

            // Create metronome iframe
            const metronomeContainer = document.getElementById('metronomeIframeContainer');
            if (metronomeContainer) {
                const metronomeIframe = document.createElement('iframe');
                metronomeIframe.src = './metronome/dist/index.html';
                metronomeIframe.style.cssText = 'width: 100%; height: 400px; border: none; border-radius: 10px;';
                metronomeContainer.appendChild(metronomeIframe);
            }

            // Load default button
            document.getElementById('loadDefaultBtn').addEventListener('click', function() {
                loadDefaultVideo();
            });

            // YouTube clipboard button
            document.getElementById('loadYouTubeClipboardBtn').addEventListener('click', function() {
                loadYouTubeFromClipboard();
            });

            // Load Paste from Cloud button
            document.getElementById('loadPasteFromCloudBtn').addEventListener('click', function() {
                loadPasteFromCloud();
            });

            // Add custom times button
            document.getElementById('addTimesBtn').addEventListener('click', function() {
                addCustomTimes();
            });

            // Enter key support for custom times input
            document.getElementById('customTimesInput').addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    addCustomTimes();
                }
            });

            // Clear times button
            document.getElementById('clearTimesBtn').addEventListener('click', function() {
                clearAllTimes();
            });

            // Copy current state button
            document.getElementById('copyCurrentStateBtn').addEventListener('click', function() {
                copyCurrentStateToClipboard();
            });

            // Loop timer buttons
            const loopTimer5minBtn = document.getElementById('loopTimer5minBtn');
            if (loopTimer5minBtn) {
                loopTimer5minBtn.addEventListener('click', function() {
                    const intervalSeconds = getLoopInterval();
                    toggleLoopTimer(intervalSeconds, this, 5);
                });
            }

            const loopTimer25minBtn = document.getElementById('loopTimer25minBtn');
            if (loopTimer25minBtn) {
                loopTimer25minBtn.addEventListener('click', function() {
                    const intervalSeconds = getLoopInterval();
                    toggleLoopTimer(intervalSeconds, this, 25);
                });
            }

            // 15-second play button - plays 15s, pauses, rewinds 15s
            document.getElementById('timer15sBtn').addEventListener('click', function() {
                play15sThenRewind(this);
                document.getElementById('timer3minBtn').focus();
            });

            // 30-second play button - plays 30s, pauses, rewinds 30s
            document.getElementById('timer30sBtn').addEventListener('click', function() {
                play30sThenRewind(this);
            });

            // 3-minute play button - plays 3min, pauses, rewinds 3min
            document.getElementById('timer3minBtn').addEventListener('click', function() {
                play3minThenRewind(this);
            });

            // Custom timer dropdown - plays selected duration, pauses, rewinds
            document.getElementById('timerCustomSelect').addEventListener('change', function() {
                if (this.value) {
                    playCustomThenRewind(this, parseInt(this.value));
                }
            });

            // Auto-detect valid time in loopStartTime input
            document.getElementById('loopStartTime').addEventListener('input', function() {
                const value = this.value.trim();

                // Check for valid time formats
                const isTimeFormat = value.match(/^(\d{1,2}):(\d{2})$/);  // M:SS or MM:SS
                const isNumberFormat = value.match(/^\d+$/);  // Just numbers (e.g., "90")

                if (isTimeFormat || isNumberFormat) {
                    const newTime = parseTimeToSeconds(value);
                    if (newTime !== null) {
                        // Format as M:SS for display
                        const minutes = Math.floor(newTime / 60);
                        const seconds = newTime % 60;
                        const displayTime = `${minutes}:${seconds.toString().padStart(2, '0')}`;

                        // Update the playback time display
                        document.getElementById('playbackTimeValue').textContent = displayTime;

                        // If a loop timer is running, update loopBaseTime
                        if (loopTimerActive) {
                            loopBaseTime = newTime;
                        }
                        // If a duration timer is running, update timerStartTime
                        if (timerTimeout) {
                            timerStartTime = newTime;
                        }
                    }
                }
            });

            // Enter key in loopStartTime input - jump to that time or adjust time with +/-
            // Escape key - clear the input
            document.getElementById('loopStartTime').addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const timeStr = this.value.trim();

                    // Check for time+delta notation (e.g., "2:01+10" or "1:30-5")
                    const timeWithDeltaMatch = timeStr.match(/^(\d{1,2}:\d{2})([+-])(\d+)$/);
                    if (timeWithDeltaMatch) {
                        const baseTimeStr = timeWithDeltaMatch[1];
                        const operator = timeWithDeltaMatch[2];
                        const deltaSeconds = parseInt(timeWithDeltaMatch[3]);

                        const baseSeconds = parseTimeToSeconds(baseTimeStr);
                        if (baseSeconds !== null) {
                            const adjustment = operator === '+' ? deltaSeconds : -deltaSeconds;
                            const newSeconds = Math.max(0, baseSeconds + adjustment);

                            // Format back to time string
                            const minutes = Math.floor(newSeconds / 60);
                            const seconds = newSeconds % 60;
                            const resultTime = `${minutes}:${seconds.toString().padStart(2, '0')}`;

                            // Update input and playback time display
                            this.value = resultTime;
                            document.getElementById('playbackTimeValue').textContent = resultTime;

                            // Update timers if running
                            if (loopTimerActive) loopBaseTime = newSeconds;
                            if (timerTimeout) timerStartTime = newSeconds;

                            // Jump to the time
                            jumpToYouTubeTime(newSeconds);
                            showStatus(`Calculated: ${baseTimeStr} ${operator}${deltaSeconds}s = ${resultTime}`, 'success');
                            this.select();
                            return;
                        }
                    }

                    // Check for +/- notation (e.g., "+5" or "-10")
                    const deltaMatch = timeStr.match(/^([+-])(\d+)$/);
                    if (deltaMatch) {
                        const operator = deltaMatch[1];
                        const deltaSeconds = parseInt(deltaMatch[2]);
                        const adjustment = operator === '+' ? deltaSeconds : -deltaSeconds;

                        // Apply the adjustment
                        adjustLoopTime(adjustment);

                        // Focus stays on input for quick adjustments
                        this.select();
                        return;
                    }

                    // Otherwise, treat as a time to jump to
                    const seconds = parseTimeToSeconds(timeStr);
                    if (seconds !== null) {
                        // If a timer is running, update start time and restart from new position
                        if (timerTimeout && timerLoopsRemaining > 0) {
                            timerStartTime = seconds;
                            clearTimeout(timerTimeout);
                            startTimerLoop();
                        }
                        // Update loop timer state if active
                        if (loopTimerActive) {
                            loopBaseTime = seconds;
                        }
                        // Jump to the time
                        jumpToYouTubeTime(seconds);
                        showStatus('Jumped to ' + timeStr, 'success');
                    }
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    this.focus();
                    this.select();
                }
            });

            // Playback jump buttons (-15s and +15s) - only jump video, don't change loop start time
            document.getElementById('loopTimeMinus15').addEventListener('click', function() {
                jumpPlayback(-15);
                document.getElementById('timer15sBtn').focus();
            });
            document.getElementById('loopTimePlus30').addEventListener('click', function() {
                jumpPlayback(30);
                document.getElementById('timer15sBtn').focus();
            });
            // "0" button - jump to time 0:00
            document.getElementById('jumpToZeroBtn').addEventListener('click', function() {
                jumpToYouTubeTime(0);
                document.getElementById('playbackTimeValue').textContent = '0:00';
                document.getElementById('timer15sBtn').focus();
            });

            // Match button - set loop time to current playback time (kept for backward compatibility)
            const loopTimeMatchBtn = document.getElementById('loopTimeMatch');
            if (loopTimeMatchBtn) {
                loopTimeMatchBtn.addEventListener('click', function() {
                const currentTimeStr = document.getElementById('currentTimeValue').textContent.trim();
                const seconds = parseTimeToSeconds(currentTimeStr);
                if (seconds !== null) {
                    document.getElementById('loopStartTime').value = currentTimeStr;
                    // If a timer is running, update start time and restart from new position
                    if (timerTimeout && timerLoopsRemaining > 0) {
                        timerStartTime = seconds;
                        clearTimeout(timerTimeout);
                        startTimerLoop();
                    }
                    if (loopTimerActive) {
                        loopBaseTime = seconds;
                    }
                    showStatus('Loop time matched to ' + currentTimeStr, 'info');
                }
            });
            }

            // Clear Saved Times button (in the Saved Times section)
            document.getElementById('clearSavedTimesBtn').addEventListener('click', function() {
                clearAllTimes();
            });

            // Save Saved Times button
            document.getElementById('saveSavedTimesBtn').addEventListener('click', async function() {
                const btn = this;
                const originalText = btn.textContent;
                btn.textContent = '‚è≥ Saving...';
                await saveSavedTimesToCloud();
                btn.textContent = '‚úÖ Saved!';
                showStatus('Saved times to cloud', 'success');
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 1500);
            });

            // Add Single Time button
            document.getElementById('addSingleTimeBtn').addEventListener('click', function() {
                const timeInput = document.getElementById('savedTimeInput');
                const commentInput = document.getElementById('savedTimeComment');
                const timeStr = timeInput.value.trim();
                if (!timeStr) {
                    showStatus('Please enter a time', 'error');
                    return;
                }
                addTimeToTable(timeStr, commentInput.value);
                timeInput.value = '';
                commentInput.value = '';
            });

            // Add Current Time button
            document.getElementById('addCurrentTimeBtn').addEventListener('click', function() {
                let currentTime = null;
                if (playerType === 'youtube' && player && playerReady && typeof player.getCurrentTime === 'function') {
                    currentTime = player.getCurrentTime();
                } else if ((playerType === 'video' || playerType === 'audio') && playerReady) {
                    const activePlayer = getActivePlayer();
                    if (activePlayer && !isNaN(activePlayer.currentTime)) {
                        currentTime = activePlayer.currentTime;
                    }
                }
                if (currentTime === null) {
                    showStatus('No media playing', 'error');
                    return;
                }
                const timeStr = formatSecondsToTime(Math.floor(currentTime));
                const commentInput = document.getElementById('savedTimeComment');
                addTimeToTable(timeStr, commentInput.value);
                commentInput.value = '';
            });

            // Enter key on savedTimeInput
            document.getElementById('savedTimeInput').addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    document.getElementById('addSingleTimeBtn').click();
                }
            });

            // Enter key on savedTimeComment
            document.getElementById('savedTimeComment').addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    document.getElementById('addSingleTimeBtn').click();
                }
            });

            // Saved time buttons - jump directly to those times
            attachTimeButtonListeners();

            // Keyboard shortcuts for timer controls and navigation
            // ALL shortcuts work EVERYWHERE (even in inputs)
            document.addEventListener('keydown', function(e) {
                // Timer shortcut: q=15s
                if (e.key === 'q') {
                    e.preventDefault();
                    const btn15s = document.getElementById('timer15sBtn');
                    // Only click the button if it's not already the active timer
                    if (!(timerTimeout && timerButtonRef === btn15s)) {
                        btn15s?.click();
                    }
                    document.getElementById('loopStartTime')?.focus();
                    return;
                }

                // Pagination keys: [=down (-15s), ]=up (+15s) - jump playback only
                if (e.key === '[' || e.key === ']') {
                    e.preventDefault();
                    if (e.key === '[') {
                        jumpPlayback(-15);
                    } else if (e.key === ']') {
                        jumpPlayback(15);
                    }
                    document.getElementById('timer15sBtn')?.focus();
                    return;
                }

                // Match key: \ (backslash) - set loop time to current playback time
                if (e.key === '\\') {
                    e.preventDefault();
                    // Match functionality (inline since button was removed)
                    const currentTimeStr = document.getElementById('currentTimeValue').textContent.trim();
                    const seconds = parseTimeToSeconds(currentTimeStr);
                    if (seconds !== null) {
                        const loopStartInput = document.getElementById('loopStartTime');
                        loopStartInput.value = currentTimeStr;
                        // Trigger input event to update timer
                        loopStartInput.dispatchEvent(new Event('input', { bubbles: true }));
                        showStatus(`Loop time matched to ${currentTimeStr}`, 'success');
                    }
                    document.getElementById('loopStartTime')?.focus();
                    return;
                }

                // Cmd+Ctrl+1: trigger +30s loop time button
                if ((e.metaKey && e.ctrlKey) && e.key === '1') {
                    e.preventDefault();
                    document.getElementById('loopTimePlus30')?.click();
                    return;
                }
            });
        });

        // Attach click listeners to all saved time buttons
        function attachTimeButtonListeners() {
            document.querySelectorAll('.saved-time-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const time = this.dataset.time;

                    // Remove active class from all buttons
                    document.querySelectorAll('.saved-time-btn').forEach(b => b.classList.remove('active'));

                    // Add active class to clicked button
                    this.classList.add('active');

                    // Visual feedback on the button
                    this.style.transform = 'scale(1.15)';
                    this.style.boxShadow = '0 5px 20px rgba(255,255,255,0.6)';

                    // Parse and jump to the time
                    const seconds = parseTimeToSeconds(time);
                    if (seconds !== null) {
                        // Save the clicked timestamp before jumping
                        lastClickedTime = seconds;

                        // Update the loop start time input
                        const loopStartTimeInput = document.getElementById('loopStartTime');
                        if (loopStartTimeInput) {
                            loopStartTimeInput.value = time;
                        }

                        jumpToYouTubeTime(seconds);
                    }

                    // Reset button appearance (but keep the active class)
                    setTimeout(() => {
                        this.style.transform = '';
                        this.style.boxShadow = '';
                    }, 400);
                });
            });
        }


        // Add custom times as buttons
        function addCustomTimes() {
            const input = document.getElementById('customTimesInput');
            const inputValue = input.value.trim();

            if (!inputValue) {
                showStatus('Please enter URL and times: URL, 1:15,2:00,3:10', 'error');
                return;
            }

            // Check if it's a single time (not a URL, just one timestamp)
            const entries = inputValue.split(',').map(t => t.trim()).filter(t => t);
            const firstEntry = entries[0];
            const mediaType = detectMediaType(firstEntry);

            // If no media URL detected and it's just a single time, ADD to existing times
            if (!mediaType && entries.length === 1) {
                const timeStr = firstEntry;
                addTimeToTable(timeStr, '');
                input.value = ''; // Clear input
                return;
            }

            // Otherwise, use the normal behavior (clear and load new times)
            processVideoAndTimes(inputValue, false);

            showStatus('Media and times loaded!', 'success');
            input.value = ''; // Clear input
        }

        // Clear all time buttons
        async function clearAllTimes() {
            savedTimesData = [];
            currentTimeIndex = -1; // Reset cycle index

            // Remove video key from allSavedTimes and save to cloud
            const key = getCurrentMediaKey();
            if (key && allSavedTimes[key]) {
                delete allSavedTimes[key];
                saveSavedTimesToCloud();
            }

            renderSavedTimesTable();
            showStatus('All times cleared', 'info');
        }

        // Copy current URL + saved times to clipboard
        async function copyCurrentStateToClipboard() {
            // Get current URL
            let currentUrl = '';

            if (playerType === 'youtube' && currentVideoId) {
                // Reconstruct YouTube URL
                currentUrl = `https://www.youtube.com/watch?v=${currentVideoId}`;
            } else if ((playerType === 'video' || playerType === 'audio') && currentMediaUrl) {
                // Use the direct media URL
                currentUrl = currentMediaUrl;
            } else {
                showStatus('No media loaded', 'error');
                return;
            }

            // Get all saved times from savedTimesData
            if (!savedTimesData || savedTimesData.length === 0) {
                showStatus('No saved times available', 'error');
                return;
            }

            // Build the format: URL, time1, time2, time3, ...
            const times = savedTimesData.map(item => item.time);
            const formattedString = `${currentUrl}, ${times.join(', ')}`;

            // Copy to clipboard
            try {
                await navigator.clipboard.writeText(formattedString);
                showStatus('Copied to clipboard!', 'success');

                // Visual feedback on button
                const btn = document.getElementById('copyCurrentStateBtn');
                const originalText = btn.textContent;
                btn.textContent = '‚úÖ Copied!';
                btn.style.transform = 'scale(1.05)';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.transform = '';
                }, 2000);
            } catch (err) {
                console.error('Failed to copy:', err);
                showStatus('Failed to copy to clipboard', 'error');
            }
        }

        // Jump video playback by delta seconds from current position (doesn't change loop start time)
        function jumpPlayback(deltaSeconds) {
            const currentTimeStr = document.getElementById('currentTimeValue').textContent.trim();
            let currentSeconds = parseTimeToSeconds(currentTimeStr);
            if (currentSeconds === null) currentSeconds = 0;

            let newSeconds = Math.max(0, currentSeconds + deltaSeconds);

            const hours = Math.floor(newSeconds / 3600);
            const minutes = Math.floor((newSeconds % 3600) / 60);
            const seconds = Math.floor(newSeconds % 60);

            let timeStr;
            if (hours > 0) {
                timeStr = `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            } else {
                timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }

            document.getElementById('playbackTimeValue').textContent = timeStr;
            jumpToYouTubeTime(newSeconds);
        }

        // Adjust loop time by a given number of seconds
        function adjustLoopTime(deltaSeconds) {
            const loopStartTimeInput = document.getElementById('loopStartTime');
            const playbackTimeDisplay = document.getElementById('playbackTimeValue');

            // Always use the playback time display as the base
            const playbackTimeStr = playbackTimeDisplay.textContent.trim();
            let currentSeconds = parseTimeToSeconds(playbackTimeStr);
            if (currentSeconds === null) currentSeconds = 0;

            // Add delta, but don't go below 0
            let newSeconds = Math.max(0, currentSeconds + deltaSeconds);

            // Format back to time string
            const hours = Math.floor(newSeconds / 3600);
            const minutes = Math.floor((newSeconds % 3600) / 60);
            const seconds = Math.floor(newSeconds % 60);

            let timeStr;
            if (hours > 0) {
                timeStr = `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            } else {
                timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }

            loopStartTimeInput.value = timeStr;

            // Update the playback time display
            playbackTimeDisplay.textContent = timeStr;

            // If a timer is running, update start time and restart from new position
            if (timerTimeout && timerLoopsRemaining > 0) {
                timerStartTime = newSeconds;
                clearTimeout(timerTimeout);
                startTimerLoop();
            }

            // Update loop timer state if active
            if (loopTimerActive) {
                loopBaseTime = newSeconds;
            }

            // Show status with base time info
            const direction = deltaSeconds > 0 ? `+${deltaSeconds}` : deltaSeconds;
            showStatus(`Playback time: ${playbackTimeStr} ${direction}s = ${timeStr}`, 'success');

            // Jump to the new time
            jumpToYouTubeTime(newSeconds);
        }

        // Jump to time from clipboard text (e.g. "1:58 some text" or just "1:58")
        async function jumpToClipboardTime() {
            try {
                const text = (await navigator.clipboard.readText()).trim();
                if (!text) {
                    showStatus('Clipboard is empty', 'error');
                    return;
                }

                // Extract time from the beginning of the string (MM:SS, H:MM:SS, or just seconds)
                const timeMatch = text.match(/^(\d+:\d+:\d+|\d+:\d+|\d+)/);
                if (!timeMatch) {
                    showStatus('No time found in clipboard', 'error');
                    return;
                }

                const timeStr = timeMatch[1];
                const seconds = parseTimeToSeconds(timeStr);
                if (seconds === null) {
                    showStatus(`Invalid time: ${timeStr}`, 'error');
                    return;
                }

                // Update playback time display
                document.getElementById('playbackTimeValue').textContent = timeStr;
                document.getElementById('loopStartTime').value = timeStr;

                // Jump to the time
                jumpToYouTubeTime(seconds);
                showStatus(`Jumped to ${timeStr}`, 'success');
            } catch (err) {
                showStatus('Clipboard access denied', 'error');
            }
        }

        // Paste media URL + times or just times from clipboard
        async function pasteMediaOrTimes() {
            try {
                const text = (await navigator.clipboard.readText()).trim();
                if (!text) {
                    showStatus('Clipboard is empty', 'error');
                    return;
                }

                // Check if it contains a URL (starts with http or has youtube/dropbox patterns)
                const hasURL = /https?:\/\//.test(text) || isYouTubeURL(text);

                if (hasURL) {
                    // Treat like the main Paste Media + Times button
                    document.getElementById('pasteMediaTextarea').value = text;
                    const success = processClipboardText(text);
                    if (success) {
                        savePasteToCloud(text);
                        const btn = document.getElementById('clipboardPasteMediaBtn');
                        const originalText = btn.textContent;
                        btn.textContent = '‚úÖ Loaded!';
                        setTimeout(() => { btn.textContent = originalText; }, 2000);
                    }
                } else {
                    // Times only (e.g. "1:00,2:00,3:00,4:00")
                    const timeEntries = text.split(',').map(t => t.trim()).filter(t => t);
                    savedTimesData = [];
                    currentTimeIndex = -1;

                    timeEntries.forEach((timeEntry) => {
                        const seconds = parseTimeToSeconds(timeEntry);
                        if (seconds !== null) {
                            savedTimesData.push({ time: timeEntry, name: '' });
                        }
                    });

                    const key = getCurrentMediaKey();
                    if (key) allSavedTimes[key] = savedTimesData;
                    renderSavedTimesTable();

                    if (savedTimesData.length > 0) {
                        saveSavedTimesToCloud();
                        const btn = document.getElementById('clipboardPasteMediaBtn');
                        const originalText = btn.textContent;
                        btn.textContent = '‚úÖ Loaded!';
                        setTimeout(() => { btn.textContent = originalText; }, 2000);
                        showStatus(`Added ${savedTimesData.length} saved times`, 'success');
                    } else {
                        showStatus('No valid times found in clipboard', 'error');
                    }
                }
            } catch (err) {
                showStatus('Clipboard access denied', 'error');
            }
        }

        // Parse time string to seconds (supports "1:23" or "83")
        function parseTimeToSeconds(timeStr) {
            timeStr = timeStr.trim();

            // If it's just numbers, treat as seconds
            if (/^\d+$/.test(timeStr)) {
                return parseInt(timeStr);
            }

            // If it's in MM:SS format
            const timeMatch = timeStr.match(/^(\d+):(\d+)$/);
            if (timeMatch) {
                const minutes = parseInt(timeMatch[1]);
                const seconds = parseInt(timeMatch[2]);

                if (seconds >= 60) {
                    return null;
                }

                return (minutes * 60) + seconds;
            }

            // If it's in H:MM:SS format
            const longTimeMatch = timeStr.match(/^(\d+):(\d+):(\d+)$/);
            if (longTimeMatch) {
                const hours = parseInt(longTimeMatch[1]);
                const minutes = parseInt(longTimeMatch[2]);
                const seconds = parseInt(longTimeMatch[3]);

                if (minutes >= 60 || seconds >= 60) {
                    return null;
                }

                return (hours * 3600) + (minutes * 60) + seconds;
            }

            return null;
        }

        // Jump to specific time in any player (YouTube or HTML5)
        function jumpToYouTubeTime(seconds) {
            if (playerType === 'youtube') {
                if (!currentVideoId) {
                    showStatus('No video loaded', 'error');
                    return;
                }

                // Use YouTube Player API to seek to time
                if (player && playerReady && typeof player.seekTo === 'function') {
                    player.seekTo(seconds, true);
                }
            } else {
                // HTML5 video or audio player
                const activePlayer = getActivePlayer();
                if (!activePlayer || !currentMediaUrl) {
                    showStatus('No media loaded', 'error');
                    return;
                }

                activePlayer.currentTime = seconds;
            }

            // If a timer is running, update the timer start position to the new time
            if (timerTimeout && timerLoopsRemaining > 0) {
                timerStartTime = seconds;
                console.log('‚è±Ô∏è Timer start position updated via jump to:', seconds);
            }

            // Format time for display
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const remainingSeconds = seconds % 60;

            let timeStr;
            if (hours > 0) {
                timeStr = `${hours}:${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
            } else if (minutes > 0) {
                timeStr = `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
            } else {
                timeStr = `${remainingSeconds}s`;
            }

            showStatus(`Jumped to ${timeStr}`, 'success');
        }

        // Control functions
        function reloadVideo() {
            if (currentVideoId) {
                player.loadVideoById(currentVideoId);
                showStatus('Video reloaded', 'success');
            }
        }

        function clearVideo() {
            // Clear YouTube player
            if (player && typeof player.destroy === 'function') {
                player.destroy();
            }
            player = null;
            currentVideoId = null;

            // Clear HTML5 players
            if (html5Player) {
                html5Player.pause();
                html5Player.src = '';
            }
            if (audioPlayer) {
                audioPlayer.pause();
                audioPlayer.src = '';
            }
            currentMediaUrl = null;

            // Reset state
            playerReady = false;
            playerType = 'youtube';

            // Update UI
            document.getElementById('youtubeContainer').innerHTML = '<div style="color: #666; text-align: center; padding: 40px;">Video cleared</div>';
            document.getElementById('mediaContainer').style.display = 'none';
            document.getElementById('audioContainer').style.display = 'none';

            stopTimeUpdates();
            document.getElementById('currentTimeDisplay').style.display = 'none';
            document.getElementById('currentTimeValue').textContent = '--:--';

            showStatus('Media cleared', 'info');
        }

        // Show status message
        let statusTimeout = null;
        function showStatus(message, type = 'info', persistent = false) {
            const statusDisplay = document.getElementById('statusDisplay');
            statusDisplay.textContent = message;
            statusDisplay.className = `status-display ${type}`;
            statusDisplay.style.display = 'block';

            if (statusTimeout) {
                clearTimeout(statusTimeout);
                statusTimeout = null;
            }

            if (!persistent) {
                statusTimeout = setTimeout(() => {
                    statusDisplay.style.display = 'none';
                }, 3000);
            }
        }

        // Direct video loading function (bypasses clipboard)
        // autoplay parameter: if true, video will start playing automatically
        function loadMediaFromUrl(url, autoplay = false) {
            if (!url || !url.trim()) {
                showStatus('No URL provided', 'error');
                return;
            }

            const mediaType = detectMediaType(url);

            if (!mediaType) {
                showStatus('Not a valid media URL (YouTube, MP4, MP3, etc.)', 'error');
                return;
            }

            if (mediaType === 'youtube') {
                const videoId = extractVideoId(url);
                if (!videoId) {
                    showStatus('Could not extract YouTube video ID', 'error');
                    return;
                }

                currentVideoId = videoId;
                switchToPlayer('youtube');

                const container = document.getElementById('youtubeContainer');
                container.innerHTML = '<div id="youtube-player"></div>';

                const initPlayer = () => {
                    if (typeof YT !== 'undefined' && YT.Player) {
                        player = new YT.Player('youtube-player', {
                            height: '100%',
                            width: '100%',
                            videoId: videoId,
                            playerVars: {
                                'enablejsapi': 1,
                                'rel': 0,
                                'modestbranding': 1,
                                'iv_load_policy': 3,
                                'autoplay': autoplay ? 1 : 0
                            },
                            events: {
                                'onReady': onPlayerReady,
                                'onStateChange': onPlayerStateChange
                            }
                        });
                    } else {
                        setTimeout(initPlayer, 500);
                    }
                };

                initPlayer();
            } else {
                switchToPlayer(mediaType);
                loadHTML5Media(url, mediaType, autoplay);
            }

            console.log('üé¨ DEBUG: Loaded media directly:', url, 'type:', mediaType);
            showStatus(`${mediaType === 'audio' ? 'Audio' : 'Video'} loaded!`, 'success');
        }

        // Shared processing logic for clipboard/cloud paste media text
        // Returns true on success, false on failure
        function processClipboardText(text) {
            console.log('üé¨ DEBUG: Processing text:', text);

            if (!text.trim()) {
                showStatus('Text is empty', 'error');
                return false;
            }

            // Check for multi-link clipboard (2+ media links across lines)
            const clipboardLinks = parseClipboardLinks(text);
            if (clipboardLinks.length >= 2) {
                // Store inline times into allSavedTimes for links that have them
                for (const link of clipboardLinks) {
                    if (link.inlineTimes && link.inlineTimes.length > 0) {
                        let key = null;
                        if (isYouTubeURL(link.url)) {
                            key = extractVideoId(link.url);
                        } else {
                            key = btoa(link.url).replace(/[/+=]/g, '_');
                        }
                        if (key) {
                            const timesData = link.inlineTimes.map(t => ({ time: t.trim(), name: '' }));
                            allSavedTimes[key] = timesData;
                        }
                    }
                }
                activatePaginationFromClipboard(clipboardLinks);
                renderSavedVideosSidebar();
                showStatus(`Loaded ${clipboardLinks.length} links into pagination`, 'success');
                return true;
            }

            // Single named link (e.g. "Edge, https://...?1:00,2:00") ‚Äî normalize to "URL,time1,time2"
            if (clipboardLinks.length === 1) {
                const link = clipboardLinks[0];
                text = link.url;
                if (link.inlineTimes && link.inlineTimes.length > 0) {
                    text += ',' + link.inlineTimes.join(',');
                }
            }

            // Split by comma to check if there are times included
            const entries = text.split(',').map(t => t.trim()).filter(t => t);
            const firstEntry = entries[0];

            // Detect media type
            const mediaType = detectMediaType(firstEntry);

            if (!mediaType) {
                showStatus('Not a valid media URL (YouTube, MP4, MP3, etc.)', 'error');
                return false;
            }

            if (mediaType === 'youtube') {
                const videoId = extractVideoId(firstEntry);
                if (!videoId) {
                    showStatus('Could not extract YouTube video ID', 'error');
                    return false;
                }

                currentVideoId = videoId;
                switchToPlayer('youtube');

                const container = document.getElementById('youtubeContainer');
                container.innerHTML = '<div id="youtube-player"></div>';

                const initPlayer = () => {
                    if (typeof YT !== 'undefined' && YT.Player) {
                        player = new YT.Player('youtube-player', {
                            height: '100%',
                            width: '100%',
                            videoId: videoId,
                            playerVars: {
                                'enablejsapi': 1,
                                'rel': 0,
                                'modestbranding': 1,
                                'iv_load_policy': 3
                            },
                            events: {
                                'onReady': onPlayerReady,
                                'onStateChange': onPlayerStateChange
                            }
                        });
                    } else {
                        setTimeout(initPlayer, 500);
                    }
                };

                initPlayer();
            } else {
                switchToPlayer(mediaType);
                loadHTML5Media(firstEntry, mediaType);
            }

            // Check if there are times after the URL
            if (entries.length > 1) {
                const timeEntries = entries.slice(1);

                savedTimesData = [];
                currentTimeIndex = -1;

                timeEntries.forEach((timeEntry) => {
                    const timeStr = timeEntry.trim();
                    const seconds = parseTimeToSeconds(timeStr);
                    if (seconds !== null) {
                        savedTimesData.push({ time: timeStr, name: '' });
                    }
                });

                const key = getCurrentMediaKey();
                if (key) allSavedTimes[key] = savedTimesData;
                renderSavedTimesTable();

                if (savedTimesData.length > 0) {
                    saveSavedTimesToCloud();
                    console.log(`üé¨ DEBUG: Added ${savedTimesData.length} times`);
                }
            } else {
                loadTimesForCurrentVideo();
            }

            console.log('üé¨ DEBUG: Loaded media:', firstEntry, 'type:', mediaType);
            showStatus(`${mediaType === 'audio' ? 'Audio' : 'Video'} loaded!`, 'success');
            return true;
        }

        // Clipboard Loading Function (handles YouTube, Dropbox, and direct media URLs)
        async function loadYouTubeFromClipboard() {
            try {
                const text = await navigator.clipboard.readText();

                // Store in hidden textarea for reference
                document.getElementById('pasteMediaTextarea').value = text;

                const success = processClipboardText(text);
                if (success) {
                    // Auto-save to cloud
                    savePasteToCloud(text);

                    // Visual feedback
                    const btn = document.getElementById('loadYouTubeClipboardBtn');
                    const originalText = btn.textContent;
                    btn.textContent = '‚úÖ Loaded!';
                    btn.style.transform = 'scale(1.05)';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.transform = '';
                    }, 2000);
                }

            } catch (err) {
                console.error('üé¨ DEBUG: Failed to read clipboard:', err);
                showStatus('Failed to read clipboard. Please paste manually or grant permission.', 'error');
            }
        }

        // Helper function to check if URL is YouTube
        function isYouTubeURL(url) {
            const youtubePatterns = [
                /(?:https?:\/\/)?(?:www\.)?youtube\.com\/watch\?v=([a-zA-Z0-9_-]+)/,
                /(?:https?:\/\/)?(?:www\.)?youtube\.com\/embed\/([a-zA-Z0-9_-]+)/,
                /(?:https?:\/\/)?youtu\.be\/([a-zA-Z0-9_-]+)/,
                /(?:https?:\/\/)?(?:www\.)?youtube\.com\/shorts\/([a-zA-Z0-9_-]+)/
            ];

            return youtubePatterns.some(pattern => pattern.test(url));
        }

        // Helper function to check if URL is a Dropbox direct link
        function isDropboxURL(url) {
            return url.includes('dropbox.com') && url.includes('raw=1');
        }

        // Helper function to detect media type from URL
        function detectMediaType(url) {
            // Check for YouTube first
            if (isYouTubeURL(url)) {
                return 'youtube';
            }

            // Check for audio extensions
            const audioExtensions = ['.mp3', '.wav', '.ogg', '.m4a', '.aac', '.flac'];
            const hasAudioExt = audioExtensions.some(ext => url.toLowerCase().includes(ext));
            if (hasAudioExt) {
                return 'audio';
            }

            // Check for video extensions (including dropbox)
            const videoExtensions = ['.mp4', '.webm', '.mov', '.avi', '.mkv', '.m4v'];
            const hasVideoExt = videoExtensions.some(ext => url.toLowerCase().includes(ext));
            if (hasVideoExt || isDropboxURL(url)) {
                return 'video';
            }

            return null; // Unknown type
        }

        // Switch between player types
        function switchToPlayer(type) {
            const youtubeContainer = document.getElementById('youtubeContainer');
            const mediaContainer = document.getElementById('mediaContainer');
            const audioContainer = document.getElementById('audioContainer');

            // Hide all players
            youtubeContainer.style.display = 'none';
            mediaContainer.style.display = 'none';
            audioContainer.style.display = 'none';

            // Show the appropriate player
            if (type === 'youtube') {
                youtubeContainer.style.display = 'block';
                playerType = 'youtube';
            } else if (type === 'video') {
                mediaContainer.style.display = 'block';
                playerType = 'video';
                if (!html5Player) {
                    html5Player = document.getElementById('html5-player');
                }
            } else if (type === 'audio') {
                audioContainer.style.display = 'block';
                playerType = 'audio';
                if (!audioPlayer) {
                    audioPlayer = document.getElementById('audio-player');
                }
            }

            console.log('üé¨ Switched to', type, 'player');
        }

        // Get the current active player
        function getActivePlayer() {
            if (playerType === 'youtube') {
                return player;
            } else if (playerType === 'video') {
                return html5Player;
            } else if (playerType === 'audio') {
                return audioPlayer;
            }
            return null;
        }

        // Load HTML5 media (video or audio)
        function loadHTML5Media(url, type, autoplay = false) {
            const mediaElement = type === 'audio' ? audioPlayer : html5Player;

            if (!mediaElement) {
                console.error('Media element not found');
                return;
            }

            currentMediaUrl = url;
            mediaElement.src = url;

            // Setup time tracking for HTML5 media
            mediaElement.addEventListener('loadedmetadata', () => {
                playerReady = true;
                document.getElementById('currentTimeDisplay').style.display = 'flex';
                console.log('üé¨ Media loaded:', url);
                // Autoplay if requested
                if (autoplay) {
                    mediaElement.play().catch(e => console.log('Autoplay prevented:', e));
                }
            }, { once: true });

            mediaElement.addEventListener('play', () => {
                startTimeUpdates();
            });

            mediaElement.addEventListener('pause', () => {
                stopTimeUpdates();
            });

            mediaElement.addEventListener('ended', () => {
                stopTimeUpdates();
            });

            mediaElement.load();
        }


        // Time tracking functions
        function startTimeUpdates() {
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
            }

            timeUpdateInterval = setInterval(() => {
                try {
                    let currentTime = null;

                    if (playerType === 'youtube' && player && playerReady && typeof player.getCurrentTime === 'function') {
                        currentTime = player.getCurrentTime();
                    } else if ((playerType === 'video' || playerType === 'audio') && playerReady) {
                        const activePlayer = getActivePlayer();
                        if (activePlayer && !isNaN(activePlayer.currentTime)) {
                            currentTime = activePlayer.currentTime;
                        }
                    }

                    if (currentTime !== null) {
                        updateTimeDisplay(currentTime);
                    }
                } catch (error) {
                    console.log('üé¨ DEBUG: Error getting current time:', error);
                }
            }, 1000);
        }

        function stopTimeUpdates() {
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
                timeUpdateInterval = null;
            }
        }

        function updateTimeDisplay(currentTimeSeconds) {
            const timeValue = document.getElementById('currentTimeValue');
            const loopStartTimeInput = document.getElementById('loopStartTime');

            if (currentTimeSeconds !== undefined && currentTimeSeconds !== null) {
                const hours = Math.floor(currentTimeSeconds / 3600);
                const minutes = Math.floor((currentTimeSeconds % 3600) / 60);
                const seconds = Math.floor(currentTimeSeconds % 60);

                let timeStr;
                if (hours > 0) {
                    timeStr = `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                } else {
                    timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }

                timeValue.textContent = timeStr;

                // Detect user seeking (time jump greater than threshold)
                const timeDifference = Math.abs(currentTimeSeconds - lastKnownTime);
                if (timeDifference > seekDetectionThreshold && lastKnownTime > 0) {
                    document.getElementById('playbackTimeValue').textContent = timeStr;
                    if (!skipSeekDetection && loopStartTimeInput) {
                        loopStartTimeInput.value = timeStr;
                    }
                }

                lastKnownTime = currentTimeSeconds;
            } else {
                timeValue.textContent = '--:--';
            }
        }

        // Cloud functions for saved times (Vercel Blob)
        // Each video is saved as a separate file: "yt_VIDEO_ID.json" or "media_ENCODED.json"
        let cloudFiles = {}; // Store raw file data from API

        async function loadSavedTimesFromCloud() {
            try {
                const response = await fetch('/api/files');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                cloudFiles = data.files || {};

                // Parse video files (yt_*.json or media_*.json)
                allSavedTimes = {};
                Object.keys(cloudFiles).forEach(filename => {
                    if (filename.startsWith('yt_') || filename.startsWith('media_')) {
                        try {
                            const parsed = JSON.parse(cloudFiles[filename]);
                            // Extract key from filename
                            const key = filename.replace(/^(yt_|media_)/, '').replace(/\.json$/, '');
                            allSavedTimes[key] = parsed.times || [];
                            // Store URL for display
                            if (parsed.url) {
                                allSavedTimes[key].url = parsed.url;
                            }
                        } catch (e) {
                            console.error('Error parsing', filename, e);
                        }
                    }
                });

                console.log('‚òÅÔ∏è Loaded saved times from cloud:', Object.keys(allSavedTimes).length, 'videos');
                renderSavedVideosSidebar();
                // Render saved times buttons for the currently playing video (if any)
                loadTimesForCurrentVideo();
            } catch (error) {
                console.error('‚òÅÔ∏è Error loading saved times from cloud:', error);
                allSavedTimes = {};
            }
        }

        function getAccessCode() {
            const mainAccessCode = document.getElementById('accessCodeInput')?.value?.trim();
            const sidebarAccessCode = document.getElementById('sidebarAccessCode')?.value?.trim();
            return mainAccessCode || sidebarAccessCode || '';
        }

        async function saveSavedTimesToCloud() {
            const accessCode = getAccessCode();
            if (!accessCode) {
                console.log('‚òÅÔ∏è No access code - skipping cloud save');
                return;
            }

            const key = getCurrentMediaKey();
            if (!key || !savedTimesData || savedTimesData.length === 0) {
                console.log('‚òÅÔ∏è No data to save');
                return;
            }

            // Determine filename prefix based on media type
            const prefix = (playerType === 'youtube') ? 'yt_' : 'media_';
            const filename = `${prefix}${key}.json`;

            // Build URL for reference
            let url = '';
            if (playerType === 'youtube' && currentVideoId) {
                url = `https://www.youtube.com/watch?v=${currentVideoId}`;
            } else if (currentMediaUrl) {
                url = currentMediaUrl;
            }

            try {
                const response = await fetch('/api/files', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        filename: filename,
                        content: JSON.stringify({ url: url, times: savedTimesData }, null, 2),
                        accessCode: accessCode
                    })
                });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                console.log('‚òÅÔ∏è Saved times to cloud:', filename);

                // Reload to refresh sidebar
                await loadSavedTimesFromCloud();
            } catch (error) {
                console.error('‚òÅÔ∏è Error saving times to cloud:', error);
            }
        }

        async function deleteVideoFromCloud(key) {
            const accessCode = getAccessCode();
            if (!accessCode) {
                showStatus('Enter access code to delete', 'error');
                return;
            }

            // Determine filename
            const ytFilename = `yt_${key}.json`;
            const mediaFilename = `media_${key}.json`;
            const filename = cloudFiles[ytFilename] ? ytFilename : mediaFilename;

            try {
                const response = await fetch(`/api/files?filename=${encodeURIComponent(filename)}`, {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ accessCode: accessCode })
                });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                console.log('‚òÅÔ∏è Deleted from cloud:', filename);

                // Reload to refresh sidebar
                await loadSavedTimesFromCloud();
            } catch (error) {
                console.error('‚òÅÔ∏è Error deleting from cloud:', error);
            }
        }

        function loadTimesForCurrentVideo() {
            const key = getCurrentMediaKey();
            if (key && allSavedTimes[key]) {
                const data = allSavedTimes[key];
                // Handle both array format and object with times property
                savedTimesData = Array.isArray(data) ? data : (data || []);
            } else {
                savedTimesData = [];
            }
            renderSavedTimesTable();
            renderSavedVideosSidebar();
        }

        // ============================================
        // SAVED VIDEOS SIDEBAR FUNCTIONS
        // ============================================

        function toggleSavedVideosSidebar() {
            const sidebar = document.getElementById('savedVideosSidebar');
            sidebar.classList.toggle('open');
        }

        function renderSavedVideosSidebar() {
            const list = document.getElementById('sidebarList');
            const keys = Object.keys(allSavedTimes).filter(k => {
                const data = allSavedTimes[k];
                return data && (Array.isArray(data) ? data.length > 0 : true);
            });

            if (keys.length === 0) {
                list.innerHTML = '<div class="sidebar-empty">No saved videos yet</div>';
                return;
            }

            const currentKey = getCurrentMediaKey();

            list.innerHTML = keys.map(key => {
                const data = allSavedTimes[key];
                const times = Array.isArray(data) ? data : [];
                const storedUrl = data.url || '';
                const isActive = key === currentKey;

                // Use stored URL or decode from key
                let displayUrl = storedUrl;
                if (!displayUrl) {
                    if (key.length === 11 && /^[a-zA-Z0-9_-]+$/.test(key)) {
                        displayUrl = `youtube.com/watch?v=${key}`;
                    } else {
                        try {
                            displayUrl = atob(key.replace(/_/g, '/').replace(/-/g, '+'));
                        } catch (e) {
                            displayUrl = key;
                        }
                    }
                }
                // Truncate for display
                if (displayUrl.length > 50) {
                    displayUrl = displayUrl.substring(0, 47) + '...';
                }

                return `
                    <div class="sidebar-item ${isActive ? 'active' : ''}" data-key="${escapeHtml(key)}">
                        <button class="sidebar-item-delete" onclick="event.stopPropagation(); deleteSavedVideo('${escapeHtml(key)}')">&times;</button>
                        <div class="sidebar-item-url">${escapeHtml(displayUrl)}</div>
                        <div class="sidebar-item-count">${times.length} saved time${times.length !== 1 ? 's' : ''}</div>
                    </div>
                `;
            }).join('');

            // Add click handlers
            list.querySelectorAll('.sidebar-item').forEach(item => {
                item.addEventListener('click', () => {
                    const key = item.dataset.key;
                    loadVideoFromSidebar(key);
                });
            });
        }

        function loadVideoFromSidebar(key) {
            const data = allSavedTimes[key];
            const storedUrl = data?.url;

            // Determine URL - prefer stored URL, otherwise decode from key
            let url = storedUrl;
            if (!url) {
                if (key.length === 11 && /^[a-zA-Z0-9_-]+$/.test(key)) {
                    url = `https://www.youtube.com/watch?v=${key}`;
                } else {
                    try {
                        url = atob(key.replace(/_/g, '/').replace(/-/g, '+'));
                    } catch (e) {
                        showStatus('Could not decode video URL', 'error');
                        return;
                    }
                }
            }

            // Load the video
            loadMediaFromUrl(url);

            // Load its saved times (handle both array and object with times property)
            savedTimesData = Array.isArray(data) ? data : (data || []);
            renderSavedTimesTable();
            renderSavedVideosSidebar();

            // Close sidebar on mobile
            if (window.innerWidth < 768) {
                toggleSavedVideosSidebar();
            }

            showStatus('Loaded video with saved times', 'success');
        }

        async function deleteSavedVideo(key) {
            if (!confirm('Delete all saved times for this video?')) return;

            // Delete from cloud
            await deleteVideoFromCloud(key);

            // If we deleted the current video's times, clear the table
            if (key === getCurrentMediaKey()) {
                savedTimesData = [];
                renderSavedTimesTable();
            }
            showStatus('Deleted saved video', 'info');
        }

        function saveCurrentVideoToSidebar() {
            const key = getCurrentMediaKey();
            if (!key) {
                showStatus('No video loaded', 'error');
                return;
            }
            if (!savedTimesData || savedTimesData.length === 0) {
                showStatus('No times to save - add some times first', 'error');
                return;
            }
            allSavedTimes[key] = savedTimesData;
            saveSavedTimesToCloud();
            renderSavedVideosSidebar();
            showStatus('Video saved to sidebar', 'success');
        }

        // Keep old function names as aliases for compatibility
        async function saveSavedTimesToIndexedDB() {
            return saveSavedTimesToCloud();
        }

        async function loadSavedTimesFromIndexedDB() {
            await loadSavedTimesFromCloud();
            loadTimesForCurrentVideo();
            return savedTimesData.map(item => item.time);
        }

        // Render saved times - accepts strings or objects, populates savedTimesData
        function renderSavedTimes(times) {
            if (!times || times.length === 0) return;

            // Convert to {time, name} format if needed
            savedTimesData = times.map(item => {
                if (typeof item === 'string') {
                    return { time: item, name: '' };
                }
                return item;
            });

            // Update allSavedTimes
            const key = getCurrentMediaKey();
            if (key) allSavedTimes[key] = savedTimesData;

            renderSavedTimesTable();
            console.log('‚úÖ Rendered', savedTimesData.length, 'saved times');
        }

        // Render the saved times table and color buttons
        function renderSavedTimesTable() {
            const table = document.getElementById('savedTimesTable');
            const tbody = document.getElementById('savedTimesTableBody');
            const btnContainer = document.getElementById('savedTimesButtons');

            // Clear existing content
            tbody.innerHTML = '';
            btnContainer.innerHTML = '';

            if (!savedTimesData || savedTimesData.length === 0) {
                table.style.display = 'none';
                return;
            }

            table.style.display = 'table';

            const colors = [
                'linear-gradient(45deg, #4CAF50, #45a049)',
                'linear-gradient(45deg, #2196F3, #1976D2)',
                'linear-gradient(45deg, #9C27B0, #7B1FA2)',
                'linear-gradient(45deg, #FF9800, #F57C00)',
                'linear-gradient(45deg, #607D8B, #455A64)',
                'linear-gradient(45deg, #E91E63, #C2185B)',
                'linear-gradient(45deg, #00BCD4, #0097A7)',
                'linear-gradient(45deg, #8BC34A, #689F38)',
                'linear-gradient(45deg, #FF5722, #E64A19)'
            ];

            savedTimesData.forEach((item, index) => {
                // Table row
                const tr = document.createElement('tr');
                tr.dataset.index = index;
                tr.addEventListener('click', () => jumpToSavedTime(index));
                tr.innerHTML = `
                    <td style="text-align: center; color: #999;">${index + 1}</td>
                    <td>${escapeHtml(item.name || '')}</td>
                    <td style="text-align: center; font-weight: 600; color: #FFC107;">${escapeHtml(item.time)}</td>
                    <td style="text-align: center;"><button class="delete-time-btn" data-index="${index}" title="Delete">&times;</button></td>
                `;
                tbody.appendChild(tr);

                // Color button
                const button = document.createElement('button');
                button.className = 'saved-time-btn time-btn';
                button.dataset.time = item.time;
                button.dataset.index = index;
                button.textContent = item.time;
                button.style.background = colors[index % colors.length];
                btnContainer.appendChild(button);
            });

            // Wire up delete buttons (stop propagation so row click doesn't fire)
            tbody.querySelectorAll('.delete-time-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteSavedTime(parseInt(btn.dataset.index));
                });
            });

            // Re-attach button listeners
            attachTimeButtonListeners();
        }

        // Jump to a saved time by index (from table row click)
        function jumpToSavedTime(index) {
            if (index < 0 || index >= savedTimesData.length) return;
            const item = savedTimesData[index];
            const seconds = parseTimeToSeconds(item.time);
            if (seconds === null) return;

            // Highlight table row
            document.querySelectorAll('#savedTimesTableBody tr').forEach(tr => tr.classList.remove('active-time-row'));
            const rows = document.querySelectorAll('#savedTimesTableBody tr');
            if (rows[index]) rows[index].classList.add('active-time-row');

            // Highlight button
            document.querySelectorAll('.saved-time-btn').forEach(b => b.classList.remove('active'));
            const btns = document.querySelectorAll('.saved-time-btn');
            if (btns[index]) btns[index].classList.add('active');

            // Update loop start time
            const loopStartTimeInput = document.getElementById('loopStartTime');
            if (loopStartTimeInput) {
                loopStartTimeInput.value = item.time;
            }

            lastClickedTime = seconds;
            currentTimeIndex = index;
            jumpToYouTubeTime(seconds);
        }

        // Go to the next saved time (updates loopStartTime + playbackTimeValue and jumps)
        function goToNextSavedTime() {
            if (!savedTimesData || savedTimesData.length === 0) {
                showStatus('No saved times', 'error');
                return;
            }
            let nextIndex = (currentTimeIndex < 0) ? 0 : currentTimeIndex + 1;
            if (nextIndex >= savedTimesData.length) {
                nextIndex = 0;
            }
            const item = savedTimesData[nextIndex];
            const seconds = parseTimeToSeconds(item.time);
            if (seconds === null) return;

            currentTimeIndex = nextIndex;

            // Update playback inputs
            document.getElementById('loopStartTime').value = item.time;
            document.getElementById('playbackTimeValue').textContent = item.time;

            // Jump to that time
            skipSeekDetection = true;
            setTimeout(() => { skipSeekDetection = false; }, 3000);
            jumpToYouTubeTime(seconds);

            showStatus(`Saved time ${nextIndex + 1}/${savedTimesData.length}: ${item.time}`, 'info');
        }

        // Delete a saved time by index
        function deleteSavedTime(index) {
            savedTimesData.splice(index, 1);
            const key = getCurrentMediaKey();
            if (key) allSavedTimes[key] = savedTimesData;
            renderSavedTimesTable();
            saveSavedTimesToCloud();
        }

        // Add a time+name to the table
        function addTimeToTable(timeStr, name) {
            timeStr = timeStr.trim();
            const seconds = parseTimeToSeconds(timeStr);
            if (seconds === null) {
                showStatus('Invalid time format. Use M:SS or H:MM:SS', 'error');
                return;
            }
            savedTimesData.push({ time: timeStr, name: (name || '').trim() });
            const key = getCurrentMediaKey();
            if (key) allSavedTimes[key] = savedTimesData;
            renderSavedTimesTable();
            // Auto-save after 500ms delay
            setTimeout(() => {
                saveSavedTimesToCloud();
            }, 500);
            showStatus(`Added time: ${timeStr}${name ? ' (' + name + ')' : ''}`, 'success');
        }

        // Format seconds to time string (M:SS or H:MM:SS)
        function formatSecondsToTime(totalSeconds) {
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = Math.floor(totalSeconds % 60);

            if (hours > 0) {
                return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            } else {
                return `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        // Clean transcript: Keep the first timestamp in each minute (starting from minute 1)
        // e.g., skip 0:xx, keep first in 1:xx, first in 2:xx, first in 3:xx, etc.
        function cleanTranscript(text) {
            if (!text || !text.trim()) {
                return '';
            }

            const lines = text.split('\n');
            const result = [];
            let currentText = [];
            let lastKeptMinute = 0; // Start at 0, so we skip minute 0 and start keeping from minute 1

            for (let line of lines) {
                line = line.trim();

                // Skip empty lines
                if (!line) {
                    continue;
                }

                // Check if line is a timestamp (M:SS or H:MM:SS)
                const timeMatch = line.match(/^(\d+):(\d+)(?::(\d+))?$/);

                if (timeMatch) {
                    const hours = timeMatch[3] ? parseInt(timeMatch[1]) : 0;
                    const minutes = timeMatch[3] ? parseInt(timeMatch[2]) : parseInt(timeMatch[1]);
                    const totalMinutes = (hours * 60) + minutes;

                    // Keep this timestamp if it's the first one in a new minute (after minute 0)
                    if (totalMinutes > lastKeptMinute) {
                        // Save previous text block
                        if (currentText.length > 0) {
                            result.push(currentText.join(' '));
                            currentText = [];
                        }

                        // Add the timestamp
                        result.push(line);
                        lastKeptMinute = totalMinutes;
                    }
                    // Otherwise, skip this timestamp (already have one for this minute or it's minute 0)
                } else {
                    // This is text content
                    currentText.push(line);
                }
            }

            // Add any remaining text
            if (currentText.length > 0) {
                result.push(currentText.join(' '));
            }

            return result.join('\n');
        }

        // Loop Timer Functions
        function getLoopInterval() {
            const loopIntervalInput = document.getElementById('loopIntervalInput');
            if (!loopIntervalInput) return 13; // Default if element doesn't exist
            const inputValue = loopIntervalInput.value.trim();
            if (inputValue === '' || isNaN(inputValue) || parseInt(inputValue) < 1) {
                return 13; // Default to 13 seconds
            }
            return parseInt(inputValue) + 1; // Add 1 second for reload delay
        }

        function toggleLoopTimer(intervalSeconds, buttonElement, durationMinutes = 5) {
            if (loopTimerActive) {
                // Timer is running - stop it first, then start new one
                stopLoopTimer();
            }
            startLoopTimer(intervalSeconds, buttonElement, durationMinutes);
        }

        function startLoopTimer(intervalSeconds, buttonElement, durationMinutes = 5) {
            // Get the loop start time from the input
            const loopStartTimeInput = document.getElementById('loopStartTime');
            const timeStr = loopStartTimeInput.value.trim();

            if (!timeStr) {
                showStatus('Please enter a loop start time', 'error');
                return;
            }

            // Parse the time string
            const baseSeconds = parseTimeToSeconds(timeStr);
            if (baseSeconds === null) {
                showStatus('Invalid time format. Use MM:SS or H:MM:SS', 'error');
                return;
            }

            if (!currentVideoId && !currentMediaUrl) {
                showStatus('Please load a video first', 'error');
                return;
            }

            loopBaseTime = baseSeconds;
            loopIntervalSeconds = intervalSeconds;
            currentLoopButton = buttonElement;

            // Start the timer (5 or 25 minutes)
            loopTimerActive = true;
            loopTimerEndTime = Date.now() + (durationMinutes * 60 * 1000);
            loopNextResetTime = Date.now() + (intervalSeconds * 1000);

            // Update UI - show which timer is running
            buttonElement.textContent = `üîÑ ${durationMinutes} min`;
            buttonElement.style.background = 'linear-gradient(45deg, #FF9800, #F57C00)';

            const statusDiv = document.getElementById('loopTimerStatus');
            if (statusDiv) statusDiv.style.display = 'block';

            // Set up display update interval
            loopTimerInterval = setInterval(updateLoopTimerDisplay, 1000);

            // Schedule first loop reset with fade (fire early to allow fade time)
            const fadeAdjustedDelay = Math.max(1000, (intervalSeconds * 1000) - FADE_OUT_DURATION_MS);
            loopResetInterval = setTimeout(resetToLoopTimeWithFade, fadeAdjustedDelay);

            // Jump to the base time immediately
            jumpToYouTubeTime(loopBaseTime);

            const playTime = intervalSeconds - 1;
            console.log(`üîÑ Loop timer started - will return to ${loopBaseTime}s (${timeStr}) every ${intervalSeconds} seconds (${playTime}s play + 1s reload) for ${durationMinutes} minutes`);
            showStatus(`Loop to ${timeStr} every ${playTime}s for ${durationMinutes} min`, 'success');
        }

        function stopLoopTimer() {
            loopTimerActive = false;

            // Clear intervals/timeouts
            if (loopTimerInterval) {
                clearInterval(loopTimerInterval);
                loopTimerInterval = null;
            }
            if (loopResetInterval) {
                clearTimeout(loopResetInterval);  // Changed to clearTimeout
                loopResetInterval = null;
            }

            // Cancel any ongoing fades and restore volume
            cancelFades();

            // Update UI - Reset all buttons
            const loop5minBtn = document.getElementById('loopTimer5minBtn');
            const loop25minBtn = document.getElementById('loopTimer25minBtn');

            if (loop5minBtn) {
                loop5minBtn.textContent = '‚ñ∂Ô∏è 5 min';
                loop5minBtn.style.background = 'linear-gradient(45deg, #4CAF50, #45a049)';
            }

            if (loop25minBtn) {
                loop25minBtn.textContent = '‚ñ∂Ô∏è 25 min';
                loop25minBtn.style.background = 'linear-gradient(45deg, #9C27B0, #7B1FA2)';
            }

            const statusDiv = document.getElementById('loopTimerStatus');
            if (statusDiv) statusDiv.style.display = 'none';

            // Reset variables
            loopTimerEndTime = null;
            loopBaseTime = null;
            loopNextResetTime = null;
            loopIntervalSeconds = 13;
            currentLoopButton = null;

            // Reset page title
            document.title = originalPageTitle;

            console.log('üîÑ Loop timer stopped');
            showStatus('Loop timer stopped', 'info');
        }

        // Shared timer state
        let timerTimeout = null;
        let timerLoopsRemaining = 0;
        let timerStartTime = 0;
        let timerButtonRef = null;
        let timerDurationMs = 0;
        let timerTotalLoops = 0;
        let timerLabel = '';
        let timerDefaultBg = '';
        let timerAdvanceEvery = 0;    // auto-advance every N loops (0 = disabled)
        let timerAdvanceSeconds = 0;  // seconds to advance by

        // Fade state variables
        const FADE_OUT_DURATION_MS = 1500;  // 1.5 second fade out
        const FADE_IN_DURATION_MS = 500;    // 0.5 second fade in
        let fadeOutInterval = null;
        let fadeInInterval = null;
        let fadeOutInProgress = false;
        let fadeInInProgress = false;
        let originalVolume = 100;  // YouTube uses 0-100

        // Get current volume from active player
        function getCurrentVolume() {
            if (player && typeof player.getVolume === 'function') {
                return player.getVolume();  // YouTube: 0-100
            } else if (html5Player) {
                return html5Player.volume * 100;  // HTML5: 0-1 -> 0-100
            } else if (audioPlayer) {
                return audioPlayer.volume * 100;
            }
            return 100;
        }

        // Set volume on active player
        function setPlayerVolume(vol) {
            if (player && typeof player.setVolume === 'function') {
                player.setVolume(vol);  // YouTube: 0-100
            } else if (html5Player) {
                html5Player.volume = vol / 100;  // HTML5: 0-1
            } else if (audioPlayer) {
                audioPlayer.volume = vol / 100;
            }
        }

        // Fade out function - returns a Promise that resolves when fade is complete
        function fadeOut(durationMs = FADE_OUT_DURATION_MS) {
            return new Promise((resolve) => {
                if (fadeOutInProgress) {
                    resolve();
                    return;
                }

                // Cancel any ongoing fade in
                if (fadeInInterval) {
                    clearInterval(fadeInInterval);
                    fadeInInterval = null;
                    fadeInInProgress = false;
                }

                fadeOutInProgress = true;
                const startVolume = getCurrentVolume();
                originalVolume = startVolume;  // Remember for fade in
                const steps = 20;
                const stepDuration = durationMs / steps;
                const volumeStep = startVolume / steps;
                let currentStep = 0;

                console.log(`üîâ Fade out started: ${startVolume} -> 0 over ${durationMs}ms`);

                fadeOutInterval = setInterval(() => {
                    currentStep++;
                    const newVolume = Math.max(0, startVolume - (volumeStep * currentStep));
                    setPlayerVolume(newVolume);

                    if (currentStep >= steps || newVolume <= 0) {
                        clearInterval(fadeOutInterval);
                        fadeOutInterval = null;
                        fadeOutInProgress = false;
                        setPlayerVolume(0);
                        console.log(`üîá Fade out complete`);
                        resolve();
                    }
                }, stepDuration);
            });
        }

        // Fade in function
        function fadeIn(durationMs = FADE_IN_DURATION_MS) {
            if (fadeInInProgress) return;

            // Cancel any ongoing fade out
            if (fadeOutInterval) {
                clearInterval(fadeOutInterval);
                fadeOutInterval = null;
                fadeOutInProgress = false;
            }

            fadeInInProgress = true;
            setPlayerVolume(0);  // Start silent
            const targetVolume = originalVolume || 100;
            const steps = 20;
            const stepDuration = durationMs / steps;
            const volumeStep = targetVolume / steps;
            let currentStep = 0;

            console.log(`üîä Fade in started: 0 -> ${targetVolume} over ${durationMs}ms`);

            fadeInInterval = setInterval(() => {
                currentStep++;
                const newVolume = Math.min(targetVolume, volumeStep * currentStep);
                setPlayerVolume(newVolume);

                if (currentStep >= steps || newVolume >= targetVolume) {
                    clearInterval(fadeInInterval);
                    fadeInInterval = null;
                    fadeInInProgress = false;
                    setPlayerVolume(targetVolume);
                    console.log(`üîä Fade in complete`);
                }
            }, stepDuration);
        }

        // Cancel any ongoing fades and restore volume
        function cancelFades() {
            if (fadeOutInterval) {
                clearInterval(fadeOutInterval);
                fadeOutInterval = null;
            }
            if (fadeInInterval) {
                clearInterval(fadeInInterval);
                fadeInInterval = null;
            }
            fadeOutInProgress = false;
            fadeInInProgress = false;
            setPlayerVolume(originalVolume || 100);
        }

        function getRepeatCount() {
            const radio = document.querySelector('input[name="timerRepeat"]:checked');
            return radio ? parseInt(radio.value) : 1;
        }

        function resetTimerButton() {
            if (timerButtonRef) {
                // Check if it's the custom select dropdown
                if (timerButtonRef.tagName === 'SELECT') {
                    timerButtonRef.value = '';
                    timerButtonRef.style.background = 'linear-gradient(45deg, #E1BEE7, #CE93D8)';
                } else {
                    timerButtonRef.textContent = timerLabel;
                    timerButtonRef.style.background = timerDefaultBg;
                }
            }
        }

        function startTimerLoop() {
            const currentLoop = timerTotalLoops - timerLoopsRemaining + 1;

            // Update button/select to show progress
            if (timerButtonRef.tagName === 'SELECT') {
                // For select, just change background to indicate running
                timerButtonRef.style.background = 'linear-gradient(45deg, #FF5722, #E64A19)';
            } else if (timerTotalLoops > 1) {
                timerButtonRef.textContent = `‚èπÔ∏è ${currentLoop}/${timerTotalLoops}`;
                timerButtonRef.style.background = 'linear-gradient(45deg, #FF5722, #E64A19)';
            } else {
                timerButtonRef.textContent = '‚èπÔ∏è Stop';
                timerButtonRef.style.background = 'linear-gradient(45deg, #FF5722, #E64A19)';
            }

            if (timerTotalLoops > 1) {
                showStatus(`Playing ${timerLabel.replace('‚è±Ô∏è ', '')} loop ${currentLoop} of ${timerTotalLoops}...`, 'info', true);
            } else {
                showStatus(`Playing for ${timerLabel.replace('‚è±Ô∏è ', '')}...`, 'info', true);
            }

            // Focus the loopStartTime input so user can type a new time while watching
            const loopInput = document.getElementById('loopStartTime');
            loopInput.focus();
            loopInput.select();

            // Calculate when to start fade out (before the loop ends)
            const fadeStartDelay = Math.max(0, timerDurationMs - FADE_OUT_DURATION_MS);

            // Set timeout to start fade out before the loop ends
            timerTimeout = setTimeout(function() {
                // Start fade out, then handle loop completion
                fadeOut().then(() => {
                    timerLoopsRemaining--;

                    // Auto-advance: every N loops, read playback time and advance by M seconds
                    const completedLoops = timerTotalLoops - timerLoopsRemaining;
                    if (timerAdvanceEvery > 0 && timerLoopsRemaining > 0 && completedLoops % timerAdvanceEvery === 0) {
                        const playbackStr = document.getElementById('playbackTimeValue').textContent.trim();
                        const playbackSeconds = parseTimeToSeconds(playbackStr) || 0;
                        const newTime = playbackSeconds + timerAdvanceSeconds;
                        const newTimeStr = formatSecondsToTime(newTime);
                        timerStartTime = newTime;
                        document.getElementById('loopStartTime').value = newTimeStr;
                        document.getElementById('playbackTimeValue').textContent = newTimeStr;
                        showStatus(`Advanced +${timerAdvanceSeconds}s ‚Üí ${newTimeStr}`, 'info');
                    }

                    // Rewind to start - always re-read from input so saved time changes are picked up
                    const inputVal = document.getElementById('loopStartTime').value.trim();
                    const currentInputTime = parseTimeToSeconds(inputVal);
                    const rewindTime = Math.max(0, currentInputTime !== null ? currentInputTime : timerStartTime);
                    skipSeekDetection = true;
                    setTimeout(() => { skipSeekDetection = false; }, 3000);
                    jumpToYouTubeTime(rewindTime);

                    if (timerLoopsRemaining > 0) {
                        // More loops - restore volume and restart
                        fadeIn();
                        showStatus(`Loop ${timerTotalLoops - timerLoopsRemaining} complete. Starting next...`, 'info', true);
                        startTimerLoop();
                    } else {
                        // All done - pause (volume already at 0 from fade out)
                        if (player && typeof player.pauseVideo === 'function') {
                            player.pauseVideo();
                        } else if (html5Player) {
                            html5Player.pause();
                        } else if (audioPlayer) {
                            audioPlayer.pause();
                        }

                        // Restore volume for next play
                        setPlayerVolume(originalVolume || 100);

                        resetTimerButton();
                        timerTimeout = null;

                        if (timerTotalLoops > 1) {
                            showStatus(`All ${timerTotalLoops} loops complete! Rewound to ${formatSecondsToTime(rewindTime)}`, 'success');
                        } else {
                            showStatus('Paused and rewound to ' + formatSecondsToTime(rewindTime), 'success');
                        }
                    }
                });
            }, fadeStartDelay);
        }

        // 15-second play then rewind function
        function play15sThenRewind(buttonElement) {
            // If this timer is already running, cancel it
            if (timerTimeout && timerButtonRef === buttonElement) {
                clearTimeout(timerTimeout);
                timerTimeout = null;
                timerLoopsRemaining = 0;
                buttonElement.textContent = '‚è±Ô∏è 15s';
                buttonElement.style.background = 'linear-gradient(45deg, #7E57C2, #5E35B1)';
                showStatus('15s timer cancelled', 'info');
                return;
            }

            // If other timer is running, cancel it first
            if (timerTimeout) {
                clearTimeout(timerTimeout);
                resetTimerButton();
            }

            // Setup timer
            timerLabel = '‚è±Ô∏è 15s';
            timerDefaultBg = 'linear-gradient(45deg, #7E57C2, #5E35B1)';
            timerDurationMs = 15000;
            timerTotalLoops = 80;  // 15s √ó 80 = 20 minutes
            timerLoopsRemaining = timerTotalLoops;
            timerButtonRef = buttonElement;
            timerAdvanceEvery = 0;
            timerAdvanceSeconds = 0;

            // Get start time from loopStartTime input
            const loopStartTimeInput = document.getElementById('loopStartTime');
            const timeStr = loopStartTimeInput.value.trim();
            timerStartTime = parseTimeToSeconds(timeStr);
            if (timerStartTime === null) {
                timerStartTime = 0;
            }

            // Jump to the start time immediately
            jumpToYouTubeTime(timerStartTime);

            startTimerLoop();
        }

        // 30-second play then rewind function
        function play30sThenRewind(buttonElement) {
            // If this timer is already running, cancel it
            if (timerTimeout && timerButtonRef === buttonElement) {
                clearTimeout(timerTimeout);
                timerTimeout = null;
                timerLoopsRemaining = 0;
                buttonElement.textContent = '‚è±Ô∏è 30s';
                buttonElement.style.background = 'linear-gradient(45deg, #00BCD4, #0097A7)';
                showStatus('30s timer cancelled', 'info');
                return;
            }

            // If other timer is running, cancel it first
            if (timerTimeout) {
                clearTimeout(timerTimeout);
                resetTimerButton();
            }

            // Setup timer
            timerLabel = '‚è±Ô∏è 30s';
            timerDefaultBg = 'linear-gradient(45deg, #00BCD4, #0097A7)';
            timerDurationMs = 30000;
            timerTotalLoops = 40;  // 30s √ó 40 = 20 minutes
            timerLoopsRemaining = timerTotalLoops;
            timerButtonRef = buttonElement;
            timerAdvanceEvery = 3;   // advance every 3 loops
            timerAdvanceSeconds = 30; // advance by 30s

            // Get start time from loopStartTime input
            const loopStartTimeInput = document.getElementById('loopStartTime');
            const timeStr = loopStartTimeInput.value.trim();
            timerStartTime = parseTimeToSeconds(timeStr);
            if (timerStartTime === null) {
                timerStartTime = 0;
            }

            // Jump to the start time immediately
            jumpToYouTubeTime(timerStartTime);

            startTimerLoop();
        }

        // 1-minute play then rewind function
        function play60sThenRewind(buttonElement) {
            // If this timer is already running, cancel it
            if (timerTimeout && timerButtonRef === buttonElement) {
                clearTimeout(timerTimeout);
                timerTimeout = null;
                timerLoopsRemaining = 0;
                buttonElement.textContent = '‚è±Ô∏è 1m';
                buttonElement.style.background = 'linear-gradient(45deg, #8BC34A, #689F38)';
                showStatus('1min timer cancelled', 'info');
                return;
            }

            // If other timer is running, cancel it first
            if (timerTimeout) {
                clearTimeout(timerTimeout);
                resetTimerButton();
            }

            // Setup timer
            timerLabel = '‚è±Ô∏è 1m';
            timerDefaultBg = 'linear-gradient(45deg, #8BC34A, #689F38)';
            timerDurationMs = 60000;
            timerTotalLoops = 25;  // 1m √ó 25 = 25 minutes
            timerLoopsRemaining = timerTotalLoops;
            timerButtonRef = buttonElement;
            timerAdvanceEvery = 0;
            timerAdvanceSeconds = 0;

            // Get start time from loopStartTime input
            const loopStartTimeInput = document.getElementById('loopStartTime');
            const timeStr = loopStartTimeInput.value.trim();
            timerStartTime = parseTimeToSeconds(timeStr);
            if (timerStartTime === null) {
                timerStartTime = 0;
            }

            // Jump to the start time immediately
            jumpToYouTubeTime(timerStartTime);

            startTimerLoop();
        }

        // 3-minute play then rewind function
        function play3minThenRewind(buttonElement) {
            // If this timer is already running, cancel it
            if (timerTimeout && timerButtonRef === buttonElement) {
                clearTimeout(timerTimeout);
                timerTimeout = null;
                timerLoopsRemaining = 0;
                buttonElement.textContent = '‚è±Ô∏è 3m';
                buttonElement.style.background = 'linear-gradient(45deg, #FF9800, #F57C00)';
                showStatus('3min timer cancelled', 'info');
                return;
            }

            // If other timer is running, cancel it first
            if (timerTimeout) {
                clearTimeout(timerTimeout);
                resetTimerButton();
            }

            // Setup timer
            timerLabel = '‚è±Ô∏è 3m';
            timerDefaultBg = 'linear-gradient(45deg, #FF9800, #F57C00)';
            timerDurationMs = 180000;
            timerTotalLoops = 8;  // 3m √ó 8 = 24 minutes
            timerLoopsRemaining = timerTotalLoops;
            timerButtonRef = buttonElement;
            timerAdvanceEvery = 0;
            timerAdvanceSeconds = 0;

            // Get start time from loopStartTime input
            const loopStartTimeInput = document.getElementById('loopStartTime');
            const timeStr = loopStartTimeInput.value.trim();
            timerStartTime = parseTimeToSeconds(timeStr);
            if (timerStartTime === null) {
                timerStartTime = 0;
            }

            // Jump to the start time immediately
            jumpToYouTubeTime(timerStartTime);

            startTimerLoop();
        }

        // Custom duration play then rewind function
        function playCustomThenRewind(selectElement, seconds) {
            const customLabel = `‚è±Ô∏è ${seconds}s`;
            const customBg = 'linear-gradient(45deg, #9C27B0, #7B1FA2)';

            // If timer is already running, cancel it
            if (timerTimeout && timerButtonRef === selectElement) {
                clearTimeout(timerTimeout);
                timerTimeout = null;
                timerLoopsRemaining = 0;
                selectElement.value = '';
                selectElement.style.background = 'linear-gradient(45deg, #E1BEE7, #CE93D8)';
                showStatus(`${seconds}s timer cancelled`, 'info');
                return;
            }

            // If other timer is running, cancel it first
            if (timerTimeout) {
                clearTimeout(timerTimeout);
                resetTimerButton();
            }

            // Setup timer
            timerLabel = customLabel;
            timerDefaultBg = customBg;
            timerDurationMs = seconds * 1000;
            timerTotalLoops = getRepeatCount();
            timerLoopsRemaining = timerTotalLoops;
            timerButtonRef = selectElement;
            timerAdvanceEvery = 0;
            timerAdvanceSeconds = 0;

            // Get start time from loopStartTime input
            const loopStartTimeInput = document.getElementById('loopStartTime');
            const timeStr = loopStartTimeInput.value.trim();
            timerStartTime = parseTimeToSeconds(timeStr);
            if (timerStartTime === null) {
                timerStartTime = 0;
            }

            // Jump to the start time immediately
            jumpToYouTubeTime(timerStartTime);

            startTimerLoop();
        }

        // New version with fade out/in for smooth loop transitions
        function resetToLoopTimeWithFade() {
            if (!loopTimerActive || loopBaseTime === null) {
                return;
            }

            // Check if the main timer is still running
            if (Date.now() >= loopTimerEndTime) {
                // Timer is ending - fade out, then stop
                fadeOut().then(() => {
                    showStatus('Loop timer completed!', 'success');
                    // Play beep sound when timer completes
                    beepSound.play().catch(err => console.log('Beep sound failed:', err));
                    stopLoopTimer();
                });
                return;
            }

            // Fade out, then jump and fade in
            fadeOut().then(() => {
                // Jump back to the loop time - re-read from input so saved time changes are picked up
                const inputTime = parseTimeToSeconds(document.getElementById('loopStartTime').value.trim());
                if (inputTime !== null) loopBaseTime = inputTime;
                jumpToYouTubeTime(loopBaseTime);

                // Fade back in
                fadeIn();

                // Set next reset time for display purposes
                loopNextResetTime = Date.now() + (loopIntervalSeconds * 1000);

                // Schedule next reset with fade
                const fadeAdjustedDelay = Math.max(1000, (loopIntervalSeconds * 1000) - FADE_OUT_DURATION_MS);
                loopResetInterval = setTimeout(resetToLoopTimeWithFade, fadeAdjustedDelay);

                console.log(`üîÑ Reset to loop time ${loopBaseTime}s with fade`);
            });
        }

        // Original version without fade (kept for compatibility)
        function resetToLoopTime() {
            if (!loopTimerActive || loopBaseTime === null) {
                return;
            }

            // Check if the main timer is still running
            if (Date.now() >= loopTimerEndTime) {
                showStatus('Loop timer completed!', 'success');
                // Play beep sound when timer completes
                beepSound.play().catch(err => console.log('Beep sound failed:', err));
                stopLoopTimer();
                return;
            }

            // Jump back to the loop time - re-read from input so saved time changes are picked up
            const inputTime2 = parseTimeToSeconds(document.getElementById('loopStartTime').value.trim());
            if (inputTime2 !== null) loopBaseTime = inputTime2;
            jumpToYouTubeTime(loopBaseTime);

            // Set next reset time
            loopNextResetTime = Date.now() + (loopIntervalSeconds * 1000);

            console.log(`üîÑ Reset to loop time ${loopBaseTime}s`);
        }

        function updateLoopTimerDisplay() {
            if (!loopTimerActive) return;

            const statusDiv = document.getElementById('loopTimerStatus');
            const remainingTime = loopTimerEndTime - Date.now();
            const nextResetTime = loopNextResetTime - Date.now();

            if (remainingTime <= 0) {
                document.title = `‚úÖ Timer Complete! | ${originalPageTitle}`;
                setTimeout(() => {
                    document.title = originalPageTitle;
                }, 3000);

                // Play beep sound when timer completes
                beepSound.play().catch(err => console.log('Beep sound failed:', err));
                stopLoopTimer();
                showStatus('Loop timer completed!', 'success');
                return;
            }

            const minutes = Math.floor(remainingTime / 60000);
            const seconds = Math.floor((remainingTime % 60000) / 1000);
            const nextResetSeconds = Math.max(0, Math.floor(nextResetTime / 1000));

            const timeRemaining = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

            // Update status display
            if (statusDiv) statusDiv.textContent = `Loop Timer: ${timeRemaining} remaining | Next reset in: ${nextResetSeconds}s`;

            // Update page title
            document.title = `üîÑ ${timeRemaining} left | Next: ${nextResetSeconds}s | ${originalPageTitle}`;
        }

        // ========== Memorize - Line Reader with TTS Functions ==========

        // Memorize State
        let memorizeLines = [];
        let memorizeLastStart = null;
        let memorizeLastEnd = null;
        let memorizeIsSpeaking = false;
        let memorizeUtterance = null;

        // Initialize TTS for Memorize
        if ('speechSynthesis' in window) {
            speechSynthesis.addEventListener('voiceschanged', () => {
                speechSynthesis.getVoices();
            });
        }

        // Memorize TTS Toggle
        const memorizeTtsToggle = document.getElementById('memorize-ttsToggle');
        const memorizeTtsLabel = document.getElementById('memorize-ttsLabel');

        if (memorizeTtsToggle) {
            memorizeTtsToggle.addEventListener('change', function() {
                if (this.checked) {
                    memorizeTtsLabel.textContent = 'TTS ON';
                } else {
                    memorizeTtsLabel.textContent = 'TTS OFF';
                    memorizeStopSpeaking();
                }
            });
        }

        // Memorize Paste from clipboard
        async function memorizePasteFromClipboard() {
            try {
                const text = await navigator.clipboard.readText();
                if (!text.trim()) {
                    memorizeShowStatus('Clipboard is empty');
                    return;
                }

                memorizeLines = text.split('\n');
                document.getElementById('memorize-totalLines').textContent = memorizeLines.length;

                memorizeRenderContent(null, null, true);
                document.getElementById('memorize-toggleDisplayBtn').textContent = 'Hide Content';
                memorizeShowStatus(`Loaded ${memorizeLines.length} lines from clipboard`);
            } catch (err) {
                memorizeShowStatus('Failed to read clipboard. Please allow clipboard access.');
                console.error('Memorize clipboard error:', err);
            }
        }

        // Memorize Render content with line numbers
        function memorizeRenderContent(highlightStart = null, highlightEnd = null, forceShow = false) {
            const display = document.getElementById('memorize-contentDisplay');
            const wasHidden = display.classList.contains('memorize-hidden');

            if (memorizeLines.length === 0) {
                display.classList.add('memorize-hidden');
                return;
            }

            let html = '';
            memorizeLines.forEach((line, index) => {
                const lineNum = index + 1;
                const isHighlighted = highlightStart !== null &&
                    lineNum >= highlightStart && lineNum <= highlightEnd;

                html += `<div class="memorize-line ${isHighlighted ? 'highlighted' : ''}">
                    <span class="memorize-line-num">${lineNum}</span>
                    <span class="memorize-line-text">${memorizeEscapeHtml(line)}</span>
                </div>`;
            });

            display.innerHTML = html;

            if (forceShow || !wasHidden) {
                display.classList.remove('memorize-hidden');
            }
        }

        // Memorize Show all lines
        function memorizeShowAllLines() {
            const display = document.getElementById('memorize-contentDisplay');
            display.classList.toggle('full');
            display.classList.remove('memorize-hidden');
            document.getElementById('memorize-toggleDisplayBtn').textContent = 'Hide Content';
            memorizeRenderContent(null, null, true);
        }

        // Memorize Toggle content display visibility
        function memorizeToggleContentDisplay() {
            const display = document.getElementById('memorize-contentDisplay');
            const btn = document.getElementById('memorize-toggleDisplayBtn');

            if (display.classList.contains('memorize-hidden')) {
                display.classList.remove('memorize-hidden');
                btn.textContent = 'Hide Content';
            } else {
                display.classList.add('memorize-hidden');
                btn.textContent = 'Show Content';
            }
        }

        // Memorize Clear content
        function memorizeClearContent() {
            memorizeLines = [];
            memorizeLastStart = null;
            memorizeLastEnd = null;
            document.getElementById('memorize-totalLines').textContent = '0';
            document.getElementById('memorize-contentDisplay').classList.add('memorize-hidden');
            document.getElementById('memorize-selectedText').classList.add('memorize-hidden');
            document.getElementById('memorize-rangeInput').value = '';
            memorizeStopSpeaking();
            memorizeShowStatus('Cleared');
        }

        // Memorize Read range
        function memorizeReadRange() {
            const input = document.getElementById('memorize-rangeInput').value.trim();

            if (!input) {
                memorizeShowStatus('Enter a range (e.g., 1-4 or 5)');
                return;
            }

            // Handle special commands
            if (input.toLowerCase() === 'r') {
                memorizeRepeatLast();
                return;
            }
            if (input.toLowerCase() === 'catn') {
                memorizeShowAllLines();
                return;
            }
            if (input.toLowerCase() === 'clr' || input.toLowerCase() === 'clear') {
                memorizeClearContent();
                return;
            }

            // Parse range
            let start, end;
            if (input.includes('-')) {
                const parts = input.split('-');
                start = parseInt(parts[0]);
                end = parseInt(parts[1]);
            } else {
                start = parseInt(input);
                end = start;
            }

            // Validate
            if (isNaN(start) || isNaN(end)) {
                memorizeShowStatus('Invalid format. Use: 3-4 or 5');
                return;
            }

            if (start < 1 || end > memorizeLines.length || start > end) {
                memorizeShowStatus(`Invalid range. Lines available: 1-${memorizeLines.length}`);
                return;
            }

            // Save for repeat
            memorizeLastStart = start;
            memorizeLastEnd = end;

            // Display and speak
            memorizeDisplaySelectedLines(start, end);
        }

        // Memorize Repeat last range
        function memorizeRepeatLast() {
            if (memorizeLastStart === null) {
                memorizeShowStatus('No previous range to repeat');
                return;
            }
            memorizeDisplaySelectedLines(memorizeLastStart, memorizeLastEnd);
        }

        // Memorize Display selected lines
        function memorizeDisplaySelectedLines(start, end) {
            const selectedText = document.getElementById('memorize-selectedText');
            const selectedLines = memorizeLines.slice(start - 1, end);

            let html = '';
            selectedLines.forEach((line, index) => {
                const lineNum = start + index;
                html += `<div class="memorize-line">
                    <span class="memorize-line-num">${lineNum}</span>
                    <span class="memorize-line-text">${memorizeEscapeHtml(line)}</span>
                </div>`;
            });

            selectedText.innerHTML = html;
            selectedText.classList.remove('memorize-hidden');

            // Highlight in main display
            memorizeRenderContent(start, end);

            // Speak if TTS is on
            if (memorizeTtsToggle && memorizeTtsToggle.checked) {
                memorizeSpeakText(selectedLines.join('\n'));
            }

            memorizeShowStatus(`Reading lines ${start}-${end}`);
        }

        // Memorize Text-to-Speech
        function memorizeSpeakText(text) {
            if (!('speechSynthesis' in window)) {
                memorizeShowStatus('Text-to-Speech not supported in this browser');
                return;
            }

            // Stop any current speech
            memorizeStopSpeaking();

            memorizeUtterance = new SpeechSynthesisUtterance(text);
            memorizeUtterance.rate = parseFloat(document.getElementById('memorize-speedSelect').value);
            memorizeUtterance.pitch = 1;
            memorizeUtterance.volume = 1;
            memorizeUtterance.lang = 'en-US';

            // Try to get a good voice
            const voices = speechSynthesis.getVoices();
            if (voices.length > 0) {
                const englishVoice = voices.find(voice =>
                    (voice.lang.includes('en-') && voice.name.includes('Enhanced')) ||
                    (voice.lang.includes('en-') && voice.name.includes('Premium')) ||
                    voice.lang.includes('en-')
                );
                if (englishVoice) {
                    memorizeUtterance.voice = englishVoice;
                }
            }

            memorizeUtterance.onstart = () => {
                memorizeIsSpeaking = true;
            };

            memorizeUtterance.onend = () => {
                memorizeIsSpeaking = false;
                memorizeShowStatus('Finished reading');
            };

            memorizeUtterance.onerror = (event) => {
                memorizeIsSpeaking = false;
                if (event.error !== 'interrupted') {
                    memorizeShowStatus('Speech error: ' + event.error);
                }
            };

            // Small delay to ensure clean start
            setTimeout(() => {
                speechSynthesis.speak(memorizeUtterance);
            }, 100);
        }

        // Memorize Stop speaking
        function memorizeStopSpeaking() {
            if ('speechSynthesis' in window) {
                speechSynthesis.cancel();
            }
            memorizeIsSpeaking = false;
        }

        // Memorize Show status message
        function memorizeShowStatus(message) {
            const status = document.getElementById('memorize-status');
            status.textContent = message;
            status.classList.remove('memorize-hidden');

            setTimeout(() => {
                status.classList.add('memorize-hidden');
            }, 3000);
        }

        // Memorize Escape HTML
        function memorizeEscapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Memorize Keyboard shortcuts
        const memorizeRangeInput = document.getElementById('memorize-rangeInput');
        if (memorizeRangeInput) {
            memorizeRangeInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    memorizeReadRange();
                }
            });
        }

        // ========== Link Extractor & Bilingual Display Functions ==========

        let extractedLink = null;
        let isSwapped = false;
        let parsedLines = [];

        async function pasteToExtractor() {
            try {
                const text = await navigator.clipboard.readText();
                document.getElementById('linkExtractorTextarea').value = text;
                showStatus('Pasted from clipboard', 'success');
            } catch (err) {
                console.error('Failed to read clipboard:', err);
                showStatus('Failed to paste from clipboard', 'error');
            }
        }

        function extractLinkFromTextarea() {
            const content = document.getElementById('linkExtractorTextarea').value.trim();
            const displayDiv = document.getElementById('extractedLinkDisplay');
            const anchor = document.getElementById('extractedLinkAnchor');

            if (!content) {
                extractedLink = null;
                displayDiv.style.display = 'none';
                showStatus('No content in textarea', 'error');
                return null;
            }

            // Find first URL using regex
            const urlRegex = /(https?:\/\/[^\s]+)/;
            const match = content.match(urlRegex);

            if (!match) {
                extractedLink = null;
                displayDiv.style.display = 'none';
                showStatus('No link found in textarea', 'error');
                return null;
            }

            // Extract and clean the URL (remove trailing punctuation)
            extractedLink = match[0].replace(/[.,;!?]+$/, '');

            // Display the extracted link
            anchor.href = extractedLink;
            anchor.textContent = extractedLink;
            displayDiv.style.display = 'block';

            console.log('extractedLink:', extractedLink);
            showStatus('Link extracted: ' + extractedLink, 'success');
            return extractedLink;
        }

        function loadExtractedLink() {
            // Extract link if not already extracted
            if (!extractedLink) {
                extractLinkFromTextarea();
            }

            if (!extractedLink) {
                showStatus('No link to load. Extract a link first.', 'error');
                return;
            }

            // Extract video ID from the URL
            const videoId = extractVideoId(extractedLink);

            if (!videoId) {
                showStatus('Invalid YouTube URL', 'error');
                return;
            }

            // Load the video
            currentVideoId = videoId;
            switchToPlayer('youtube');

            // Clear the container and create player div
            const container = document.getElementById('youtubeContainer');
            container.innerHTML = '<div id="youtube-player"></div>';

            // Wait for API to be ready then create player
            const initPlayer = () => {
                if (typeof YT !== 'undefined' && YT.Player) {
                    player = new YT.Player('youtube-player', {
                        height: '100%',
                        width: '100%',
                        videoId: videoId,
                        playerVars: {
                            'enablejsapi': 1,
                            'rel': 0,
                            'modestbranding': 1,
                            'iv_load_policy': 3
                        },
                        events: {
                            'onReady': onPlayerReady,
                            'onStateChange': onPlayerStateChange
                        }
                    });
                } else {
                    setTimeout(initPlayer, 500);
                }
            };

            initPlayer();
            showStatus('Loaded extracted video', 'success');
        }

        function processAndDisplayBilingual() {
            const content = document.getElementById('linkExtractorTextarea').value.trim();
            const displaySection = document.getElementById('bilingualDisplaySection');
            const bilingualContent = document.getElementById('bilingualContent');

            if (!content) {
                displaySection.style.display = 'none';
                showStatus('No content to display', 'error');
                return;
            }

            const lines = content.split('\n');
            parsedLines = [];
            let html = '';
            let rowNum = 0;

            for (const line of lines) {
                if (!line.trim()) {
                    // Empty line - add spacing
                    html += '<div style="height: 15px;"></div>';
                    parsedLines.push({ left: '', right: '', isEmpty: true });
                    continue;
                }

                // Split by pipe
                const parts = line.split('|');

                if (parts.length >= 2) {
                    rowNum++;
                    // Remove glossed words in parentheses (e.g., "vida(life)" or "conto (tale)")
                    const left = parts[0].trim().replace(/\s*\([^)]+\)/g, '');
                    const right = parts.slice(1).join('|').trim();

                    parsedLines.push({ left, right, isEmpty: false });

                    const displayLeft = isSwapped ? right : left;
                    const displayRight = isSwapped ? left : right;

                    html += `
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; padding: 10px 0; border-bottom: 1px solid #eee;">
                            <div style="padding-right: 15px; border-right: 2px solid #e0e0e0;">
                                <span style="display: inline-block; background: #2196F3; color: white; width: 22px; height: 22px; border-radius: 50%; text-align: center; line-height: 22px; font-size: 11px; margin-right: 8px; font-weight: bold;">${rowNum}</span>
                                ${escapeHtml(displayLeft)}
                            </div>
                            <div style="padding-left: 15px; color: #555;">${escapeHtml(displayRight)}</div>
                        </div>
                    `;
                } else {
                    // No pipe found - show on left side only
                    rowNum++;
                    const content = line.trim();
                    parsedLines.push({ left: content, right: '', isEmpty: false });

                    html += `
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; padding: 10px 0; border-bottom: 1px solid #eee;">
                            <div style="padding-right: 15px; border-right: 2px solid #e0e0e0;">
                                <span style="display: inline-block; background: #2196F3; color: white; width: 22px; height: 22px; border-radius: 50%; text-align: center; line-height: 22px; font-size: 11px; margin-right: 8px; font-weight: bold;">${rowNum}</span>
                                ${escapeHtml(content)}
                            </div>
                            <div style="padding-left: 15px; color: #999; font-style: italic;">(no translation)</div>
                        </div>
                    `;
                }
            }

            bilingualContent.innerHTML = html || '<div style="color: #999; text-align: center; padding: 20px;">No piped text found</div>';
            displaySection.style.display = 'block';
            showStatus('Displayed ' + rowNum + ' lines', 'success');
        }

        function swapLanguages() {
            isSwapped = !isSwapped;

            // Swap headers
            const leftHeader = document.getElementById('leftHeader');
            const rightHeader = document.getElementById('rightHeader');

            if (isSwapped) {
                leftHeader.textContent = 'English';
                rightHeader.textContent = 'Portuguese';
            } else {
                leftHeader.textContent = 'Portuguese';
                rightHeader.textContent = 'English';
            }

            // Re-process to update display
            if (parsedLines.length > 0) {
                processAndDisplayBilingual();
            }

            showStatus('Languages swapped', 'success');
        }

        function clearExtractor() {
            document.getElementById('linkExtractorTextarea').value = '';
            document.getElementById('extractedLinkDisplay').style.display = 'none';
            document.getElementById('bilingualDisplaySection').style.display = 'none';
            extractedLink = null;
            parsedLines = [];
            showStatus('Extractor cleared', 'info');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Global access to extractedLink
        window.getExtractedLink = () => extractedLink;

        // ========== METRONOME FUNCTIONALITY ==========
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        let metronomeContext = null;
        let metronomeTimer = null;
        let metronomeNoteCount = 0;
        let metronomeCounting = false;
        let metronomeAccentPitch = 380;
        let metronomeOffBeatPitch = 200;
        let metronomeCurTime = 0.0;
        let metronomeDelta = 0;

        // Initialize audio context on first user interaction
        function initMetronomeContext() {
            if (!metronomeContext) {
                metronomeContext = new AudioContext();
            }
        }

        function metronomeSchedule() {
            while (metronomeCurTime < metronomeContext.currentTime + 0.1) {
                metronomePlayNote(metronomeCurTime);
                metronomeUpdateTime();
            }
            metronomeTimer = window.setTimeout(metronomeSchedule, 100);
        }

        function metronomeUpdateTime() {
            const bpm = parseInt(document.getElementById('metronomeBpm').value, 10) || 60;
            metronomeCurTime += 60.0 / bpm;
            metronomeNoteCount++;
        }

        function metronomePlayNote(t) {
            const note = metronomeContext.createOscillator();
            const beat = parseInt(document.getElementById('metronomeBeat').value, 10) || 4;

            if (metronomeNoteCount >= beat) {
                metronomeNoteCount = 0;
            }

            const dots = document.querySelectorAll('#metronomeCounter .dot');
            const currentDot = dots[metronomeNoteCount];

            if (currentDot && currentDot.classList.contains('active')) {
                note.frequency.value = metronomeAccentPitch;
            } else {
                note.frequency.value = metronomeOffBeatPitch;
            }

            note.connect(metronomeContext.destination);
            note.start(t);
            note.stop(t + 0.05);

            // Visual feedback
            dots.forEach(dot => {
                dot.style.transform = '';
                dot.style.background = dot.classList.contains('active') ? '#5ec2ff' : '#FFF';
            });

            if (currentDot) {
                currentDot.style.transform = 'translateY(-8px)';
                currentDot.style.background = '#F75454';
            }
        }

        function metronomeCountDown() {
            const timerInput = document.getElementById('metronomeTimer');
            const currentVal = parseInt(timerInput.value, 10);

            if (currentVal > 0 && metronomeCounting) {
                timerInput.value = currentVal - 1;
                window.setTimeout(metronomeCountDown, 1000);
            } else {
                document.getElementById('metronomePlay').click();
                timerInput.value = 60;
            }
        }

        // Update dots when beat changes
        function updateMetronomeDots() {
            const counter = document.getElementById('metronomeCounter');
            const beat = parseInt(document.getElementById('metronomeBeat').value, 10) || 4;
            counter.innerHTML = '';

            for (let i = 0; i < beat; i++) {
                const dot = document.createElement('div');
                dot.className = 'dot' + (i === 0 ? ' active' : '');
                dot.addEventListener('click', function() {
                    this.classList.toggle('active');
                });
                counter.appendChild(dot);
            }
        }

        // Metronome Event listeners
        document.getElementById('metronomeBeat').addEventListener('change', updateMetronomeDots);

        document.querySelector('.bpm-minus').addEventListener('click', function() {
            const input = document.getElementById('metronomeBpm');
            input.value = Math.max(1, parseInt(input.value, 10) - 1);
        });

        document.querySelector('.bpm-plus').addEventListener('click', function() {
            const input = document.getElementById('metronomeBpm');
            input.value = parseInt(input.value, 10) + 1;
        });

        document.getElementById('metronomeTap').addEventListener('click', function() {
            const d = new Date();
            const temp = d.getTime();
            const bpm = Math.ceil(60000 / (temp - metronomeDelta));
            if (bpm > 0 && bpm < 300) {
                document.getElementById('metronomeBpm').value = bpm;
            }
            metronomeDelta = temp;
        });

        document.getElementById('metronomePlay').addEventListener('click', function() {
            initMetronomeContext();

            if (this.dataset.playing === 'true') {
                // Stop
                metronomeCounting = false;
                window.clearTimeout(metronomeTimer);
                document.querySelectorAll('#metronomeCounter .dot').forEach(dot => {
                    dot.style.transform = '';
                    dot.style.background = dot.classList.contains('active') ? '#5ec2ff' : '#FFF';
                });
                this.dataset.playing = 'false';
                this.textContent = 'Play';
                this.style.background = '#D6E26D';
                this.style.color = '#3d430d';
            } else {
                // Play
                if (document.getElementById('metronome-timer-check').checked) {
                    metronomeCounting = true;
                    metronomeCountDown();
                }

                metronomeCurTime = metronomeContext.currentTime;
                metronomeNoteCount = parseInt(document.getElementById('metronomeBeat').value, 10) || 4;
                metronomeSchedule();

                this.dataset.playing = 'true';
                this.textContent = 'Stop';
                this.style.background = '#F75454';
                this.style.color = '#FFF';
            }
        });

        // Click dots to toggle accent
        document.querySelectorAll('#metronomeCounter .dot').forEach(dot => {
            dot.addEventListener('click', function() {
                this.classList.toggle('active');
            });
        });

        // ============================================
        // CLOUD NOTES FEATURE (Inline)
        // ============================================
        const CLOUD_NOTES_CODE = '123';
        const CLOUD_NOTES_FILENAME = 'cloud_notes.txt';

        // Toggle section visibility
        document.getElementById('cloudNotesToggleBtn').addEventListener('click', function() {
            const section = document.getElementById('cloudNotesSection');
            section.style.display = section.style.display === 'none' ? 'block' : 'none';
        });

        // Load from cloud
        document.getElementById('cloudNotesLoadBtn').addEventListener('click', async function() {
            const statusEl = document.getElementById('cloudNotesStatus');
            const textarea = document.getElementById('cloudNotesTextarea');

            statusEl.textContent = 'Loading...';
            statusEl.style.color = '#FFC107';

            try {
                const response = await fetch('/api/files');
                if (response.ok) {
                    const data = await response.json();
                    textarea.value = data.files?.[CLOUD_NOTES_FILENAME] || '';
                    statusEl.textContent = 'Loaded ‚úì';
                    statusEl.style.color = '#4CAF50';
                } else {
                    statusEl.textContent = 'Load failed';
                    statusEl.style.color = '#f44336';
                }
            } catch (err) {
                statusEl.textContent = 'Error: ' + err.message;
                statusEl.style.color = '#f44336';
            }
        });

        // Save to cloud
        document.getElementById('cloudNotesSaveBtn').addEventListener('click', async function() {
            const statusEl = document.getElementById('cloudNotesStatus');
            const textarea = document.getElementById('cloudNotesTextarea');
            const saveBtn = this;

            saveBtn.disabled = true;
            statusEl.textContent = 'Saving...';
            statusEl.style.color = '#FFC107';

            try {
                const response = await fetch('/api/files', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        filename: CLOUD_NOTES_FILENAME,
                        content: textarea.value,
                        accessCode: CLOUD_NOTES_CODE
                    })
                });

                if (response.ok) {
                    statusEl.textContent = 'Saved ‚úì';
                    statusEl.style.color = '#4CAF50';
                } else {
                    statusEl.textContent = 'Save failed';
                    statusEl.style.color = '#f44336';
                }
            } catch (err) {
                statusEl.textContent = 'Save failed';
                statusEl.style.color = '#f44336';
            } finally {
                saveBtn.disabled = false;
            }
        });
    </script>
    <div style="max-width: 900px; margin: 40px auto 20px; padding: 0 15px;">
        <textarea id="pasteMediaTextarea" placeholder="Paste media content appears here..." style="width: 100%; min-height: 80px; padding: 12px; font-size: 14px; border: 2px solid #333; border-radius: 6px; background: #2a2a2a; color: #fff; resize: vertical; outline: none; font-family: inherit; line-height: 1.5; box-sizing: border-box;"></textarea>
    </div>
    <!-- Audio Recording Libraries -->
    <script src="https://cdn.rawgit.com/mattdiamond/Recorderjs/08e7abd9/dist/recorder.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
    <script>
        // ============================================
        // AUDIO RECORDING
        // ============================================
        (function() {
            let isRecording = false;
            let isProcessing = false;
            let gumStream = null;
            let recorder = null;
            let audioContext = null;

            const recordBtn = document.getElementById('recordBtn');
            const recordingIndicator = document.getElementById('recordingIndicator');
            const processingIndicator = document.getElementById('processingIndicator');

            recordBtn.addEventListener('click', function() {
                if (isProcessing) return;
                if (!isRecording) {
                    startRecording();
                } else {
                    stopRecording();
                }
            });

            async function startRecording() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                    audioContext = new AudioContextClass();
                    gumStream = stream;

                    const input = audioContext.createMediaStreamSource(stream);
                    recorder = new Recorder(input, { numChannels: 1 });
                    recorder.record();

                    isRecording = true;
                    recordBtn.classList.add('recording');
                    recordBtn.textContent = '‚èπÔ∏è';
                    recordBtn.title = 'Stop & Save Recording';
                    recordingIndicator.style.display = '';
                } catch (err) {
                    console.error('Error accessing microphone:', err);
                    alert('Microphone access denied. Please allow microphone access to record.');
                }
            }

            function stopRecording() {
                if (!recorder || !gumStream) return;

                isRecording = false;
                isProcessing = true;
                recordBtn.classList.remove('recording');
                recordBtn.textContent = 'üéôÔ∏è';
                recordBtn.title = 'Start Recording';
                recordBtn.disabled = true;
                recordingIndicator.style.display = 'none';
                processingIndicator.style.display = '';

                recorder.stop();
                gumStream.getAudioTracks()[0].stop();

                recorder.exportWAV(async function(wavBlob) {
                    const mp3Blob = await convertToMp3(wavBlob);
                    const filename = generateFilename();

                    // Upload to Dropbox /recordings/vercel/
                    if (window.uploadToDropboxRecordings) {
                        processingIndicator.textContent = 'Uploading...';
                        const uploaded = await window.uploadToDropboxRecordings(mp3Blob, filename);
                        if (uploaded) {
                            processingIndicator.textContent = 'Uploaded! get it with grabrecording()';
                            await new Promise(r => setTimeout(r, 1000));
                        } else {
                            // Fallback to local download if Dropbox not signed in
                            downloadMp3(mp3Blob, filename);
                        }
                    } else {
                        downloadMp3(mp3Blob, filename);
                    }

                    isProcessing = false;
                    recordBtn.disabled = false;
                    processingIndicator.style.display = 'none';
                    processingIndicator.textContent = 'Saving...';
                });
            }

            function convertToMp3(wavBlob) {
                return new Promise(function(resolve) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const wavData = new DataView(e.target.result);
                        const sampleRate = wavData.getUint32(24, true);
                        const numChannels = wavData.getUint16(22, true);
                        const samples = new Int16Array(e.target.result, 44);

                        const mp3encoder = new lamejs.Mp3Encoder(numChannels, sampleRate, 128);
                        const mp3Data = [];
                        const sampleBlockSize = 1152;

                        for (let i = 0; i < samples.length; i += sampleBlockSize) {
                            const sampleChunk = samples.subarray(i, i + sampleBlockSize);
                            const mp3buf = mp3encoder.encodeBuffer(sampleChunk);
                            if (mp3buf.length > 0) {
                                mp3Data.push(mp3buf);
                            }
                        }

                        const finalBuf = mp3encoder.flush();
                        if (finalBuf.length > 0) {
                            mp3Data.push(finalBuf);
                        }

                        const mp3Blob = new Blob(mp3Data, { type: 'audio/mp3' });
                        resolve(mp3Blob);
                    };
                    reader.readAsArrayBuffer(wavBlob);
                });
            }

            function generateFilename() {
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                let hours = now.getHours();
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');
                const isPM = hours >= 12;
                hours = hours % 12 || 12;
                return 'Recording ' + year + '-' + month + '-' + day + ' at ' + hours + '.' + minutes + '.' + seconds + ' ' + (isPM ? 'PM' : 'AM') + '.mp3';
            }

            function downloadMp3(blob, filename) {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }
        })();
    </script>

    <!-- Dropbox Integration -->
    <script>
    (function() {
        // ============ DROPBOX INTEGRATION ============
        let dropboxAccessToken = null;
        let dropboxAppKey = '';
        let currentDropboxFilePath = '';
        let currentDropboxFileName = '';
        let dbxRootFilesLoaded = false;

        const dbxIsLocalhost = ['localhost', '127.0.0.1'].includes(window.location.hostname);

        // PKCE helpers
        function generateCodeVerifier() {
            const array = new Uint8Array(64);
            crypto.getRandomValues(array);
            return btoa(String.fromCharCode(...array))
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=+$/, '');
        }

        async function generateCodeChallenge(verifier) {
            const encoder = new TextEncoder();
            const data = encoder.encode(verifier);
            const digest = await crypto.subtle.digest('SHA-256', data);
            return btoa(String.fromCharCode(...new Uint8Array(digest)))
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=+$/, '');
        }

        async function fetchDropboxAppKey() {
            if (dbxIsLocalhost) {
                return localStorage.getItem('dropbox-app-key') || '';
            }
            try {
                const res = await fetch('/api/dropbox-key');
                const data = await res.json();
                return data.key || '';
            } catch {
                return '';
            }
        }

        function setDbxStatus(msg) {
            document.getElementById('dbxStatus').textContent = msg;
        }

        window.toggleDropboxSidebar = async function() {
            const sidebar = document.getElementById('dbxSidebar');
            sidebar.classList.toggle('open');

            if (!sidebar.classList.contains('open')) return;

            if (dbxIsLocalhost) {
                document.getElementById('dbxAppKeyRow').style.display = 'flex';
                const savedKey = localStorage.getItem('dropbox-app-key');
                if (savedKey) {
                    document.getElementById('dbxAppKeyInput').value = savedKey;
                }
            } else {
                document.getElementById('dbxAppKeyRow').style.display = 'none';
            }

            if (dropboxAccessToken) {
                document.getElementById('dbxSignInSection').style.display = 'none';
                document.getElementById('dbxSearchSection').style.display = 'flex';
                if (!dbxRootFilesLoaded) {
                    dbxRootFilesLoaded = true;
                    loadDropboxFolder('');
                }
            } else {
                document.getElementById('dbxSignInSection').style.display = 'block';
                document.getElementById('dbxSearchSection').style.display = 'none';
            }
        };

        function closeDropboxSidebar() {
            document.getElementById('dbxSidebar').classList.remove('open');
        }

        async function handleDropboxSignIn() {
            let appKey;
            if (dbxIsLocalhost) {
                appKey = document.getElementById('dbxAppKeyInput').value.trim();
                if (!appKey) {
                    alert('Please enter a Dropbox App Key');
                    return;
                }
                localStorage.setItem('dropbox-app-key', appKey);
            } else {
                appKey = await fetchDropboxAppKey();
                if (!appKey) {
                    alert('Dropbox App Key not configured on server');
                    return;
                }
            }
            dropboxAppKey = appKey;

            const verifier = generateCodeVerifier();
            const challenge = await generateCodeChallenge(verifier);
            sessionStorage.setItem('dropbox_code_verifier', verifier);

            const redirectUri = window.location.origin + window.location.pathname;
            const authUrl = `https://www.dropbox.com/oauth2/authorize?client_id=${appKey}&response_type=code&code_challenge=${challenge}&code_challenge_method=S256&redirect_uri=${encodeURIComponent(redirectUri)}&token_access_type=online`;
            window.location.href = authUrl;
        }

        async function handleDropboxOAuthRedirect() {
            const params = new URLSearchParams(window.location.search);
            const code = params.get('code');
            if (!code) return;

            const verifier = sessionStorage.getItem('dropbox_code_verifier');
            const appKey = await fetchDropboxAppKey();
            if (!verifier || !appKey) return;
            dropboxAppKey = appKey;

            const redirectUri = window.location.origin + window.location.pathname;
            const body = new URLSearchParams({
                code,
                grant_type: 'authorization_code',
                client_id: appKey,
                redirect_uri: redirectUri,
                code_verifier: verifier,
            });

            try {
                const res = await fetch('https://api.dropboxapi.com/oauth2/token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: body.toString(),
                });
                const data = await res.json();
                if (data.access_token) {
                    dropboxAccessToken = data.access_token;
                    sessionStorage.removeItem('dropbox_code_verifier');
                    window.history.replaceState({}, document.title, window.location.pathname);
                    toggleDropboxSidebar();
                } else {
                    console.error('Dropbox auth failed:', data);
                }
            } catch (err) {
                console.error('Dropbox auth error:', err);
            }
        }

        async function handleDropboxSignOut() {
            if (dropboxAccessToken) {
                try {
                    await fetch('https://api.dropboxapi.com/2/auth/token/revoke', {
                        method: 'POST',
                        headers: { Authorization: `Bearer ${dropboxAccessToken}` },
                    });
                } catch { /* ignore */ }
            }
            dropboxAccessToken = null;
            currentDropboxFilePath = '';
            currentDropboxFileName = '';
            dbxRootFilesLoaded = false;
            document.getElementById('dbxSaveBtn').style.display = 'none';
            document.getElementById('dbxContentSection').style.display = 'none';
            document.getElementById('dbxSignInSection').style.display = 'block';
            document.getElementById('dbxSearchSection').style.display = 'none';
            document.getElementById('dbxResults').innerHTML = '';
            document.getElementById('dbxBreadcrumb').innerHTML = '';
            setDbxStatus('Signed out');
        }

        async function searchDropboxFiles(query) {
            if (!query.trim() || !dropboxAccessToken) return;
            setDbxStatus('Searching...');
            document.getElementById('dbxBreadcrumb').innerHTML = '';

            try {
                const response = await fetch('https://api.dropboxapi.com/2/files/search_v2', {
                    method: 'POST',
                    headers: {
                        Authorization: `Bearer ${dropboxAccessToken}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        query: query,
                        options: { max_results: 20 },
                    }),
                });
                if (!response.ok) throw new Error('Search failed');
                const data = await response.json();
                const results = (data.matches || []).map(m => {
                    const metadata = m.metadata?.metadata || m.metadata;
                    return {
                        name: metadata.name,
                        path: metadata.path_lower || metadata.path_display,
                        isFolder: metadata['.tag'] === 'folder',
                    };
                }).filter(item => !item.isFolder);
                setDbxStatus(`Found ${results.length} files`);
                renderDbxResults(results, true);
            } catch (error) {
                setDbxStatus('Error: ' + error.message);
            }
        }

        async function loadDropboxFolder(path) {
            setDbxStatus('Loading folder...');
            try {
                const response = await fetch('https://api.dropboxapi.com/2/files/list_folder', {
                    method: 'POST',
                    headers: {
                        Authorization: `Bearer ${dropboxAccessToken}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ path: path }),
                });
                if (!response.ok) throw new Error('Failed to list folder');
                const data = await response.json();
                const entries = (data.entries || []).map(entry => ({
                    name: entry.name,
                    path: entry.path_lower || entry.path_display,
                    isFolder: entry['.tag'] === 'folder',
                }));
                entries.sort((a, b) => {
                    if (a.isFolder !== b.isFolder) return a.isFolder ? -1 : 1;
                    return a.name.localeCompare(b.name);
                });
                setDbxStatus(`Loaded ${entries.length} items`);
                renderDbxBreadcrumb(path);
                renderDbxResults(entries);
            } catch (error) {
                setDbxStatus('Error: ' + error.message);
            }
        }

        function renderDbxBreadcrumb(path) {
            const container = document.getElementById('dbxBreadcrumb');
            if (!path) {
                container.innerHTML = '';
                return;
            }
            const parts = path.replace(/^\//, '').split('/').filter(Boolean);
            let html = '';
            parts.forEach((part, i) => {
                const crumbPath = '/' + parts.slice(0, i + 1).join('/');
                if (i > 0) html += '<span class="dbx-breadcrumb-sep">/</span>';
                html += `<button class="dbx-breadcrumb-link" data-path="${crumbPath}">${part}</button>`;
            });
            container.innerHTML = html;
        }

        async function loadDropboxFile(path, name) {
            setDbxStatus(`Loading ${name}...`);
            try {
                const response = await fetch('https://content.dropboxapi.com/2/files/download', {
                    method: 'POST',
                    headers: {
                        Authorization: `Bearer ${dropboxAccessToken}`,
                        'Dropbox-API-Arg': JSON.stringify({ path: path }),
                    },
                });
                if (!response.ok) throw new Error('Download failed');
                const content = await response.text();

                // Load into the Dropbox content textarea
                document.getElementById('dbxContentTextarea').value = content;
                document.getElementById('dbxContentSection').style.display = 'block';
                document.getElementById('dbxFileLabel').textContent = name;
                document.getElementById('dbxSaveBtn').style.display = '';

                // Track for saving back
                currentDropboxFilePath = path;
                currentDropboxFileName = name;

                // Highlight the loaded file in sidebar
                document.querySelectorAll('#dbxResults .dbx-result-item').forEach(el => {
                    el.classList.toggle('selected', el.dataset.path === path);
                });
                setDbxStatus(`Loaded: ${name}`);
            } catch (error) {
                setDbxStatus('Error: ' + error.message);
            }
        }

        // ============ CONTENT VIEWER TOGGLE & FONT ============
        let dbxContentFontSize = 13;
        let dbxContentViewMode = false; // false = textarea, true = div view

        function toggleDbxContentView() {
            dbxContentViewMode = !dbxContentViewMode;
            const textarea = document.getElementById('dbxContentTextarea');
            const view = document.getElementById('dbxContentView');
            const btn = document.getElementById('dbxToggleViewBtn');

            if (dbxContentViewMode) {
                const text = textarea.value;
                const paragraphs = text.split(/\n\s*\n/).filter(p => p.trim());
                view.innerHTML = paragraphs.length > 0
                    ? paragraphs.map(p => `<p>${p.replace(/\n/g, '<br>')}</p>`).join('')
                    : `<p>${text.replace(/\n/g, '<br>')}</p>`;
                textarea.style.display = 'none';
                view.style.display = 'block';
                btn.textContent = 'Edit';
            } else {
                textarea.style.display = '';
                view.style.display = 'none';
                btn.textContent = 'View';
            }
        }

        function changeDbxContentFont(delta) {
            dbxContentFontSize = Math.max(9, Math.min(24, dbxContentFontSize + delta));
            document.getElementById('dbxContentTextarea').style.fontSize = dbxContentFontSize + 'px';
            document.getElementById('dbxContentView').style.fontSize = dbxContentFontSize + 'px';
        }

        async function saveToDropbox() {
            if (!currentDropboxFilePath || !dropboxAccessToken) return;

            const btn = document.getElementById('dbxSaveBtn');
            const origText = btn.textContent;
            btn.textContent = 'Saving...';
            btn.disabled = true;

            try {
                const content = document.getElementById('dbxContentTextarea').value;

                const response = await fetch('https://content.dropboxapi.com/2/files/upload', {
                    method: 'POST',
                    headers: {
                        Authorization: `Bearer ${dropboxAccessToken}`,
                        'Dropbox-API-Arg': JSON.stringify({
                            path: currentDropboxFilePath,
                            mode: { '.tag': 'overwrite' },
                            mute: true,
                        }),
                        'Content-Type': 'application/octet-stream',
                    },
                    body: content,
                });
                if (response.ok) {
                    btn.textContent = 'Saved!';
                    setTimeout(() => { btn.textContent = origText; }, 1500);
                } else {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error_summary || `HTTP ${response.status}`);
                }
            } catch (error) {
                alert('Error saving to Dropbox: ' + error.message);
                btn.textContent = origText;
            } finally {
                btn.disabled = false;
            }
        }

        function renderDbxResults(items, isSearch) {
            const container = document.getElementById('dbxResults');
            if (items.length === 0) {
                container.innerHTML = '<div style="padding: 15px; color: #888; text-align: center;">No results</div>';
                return;
            }
            let html = '';
            if (isSearch) {
                html += '<div style="padding: 2px 10px;"><button class="dbx-show-all-btn" id="dbxShowAllBtn">Show All</button></div>';
            }
            html += items.map(item => {
                const icon = item.isFolder ? '\uD83D\uDCC1' : '\uD83D\uDCC4';
                const isSelected = !item.isFolder && currentDropboxFilePath && item.path === currentDropboxFilePath;
                const pathHtml = isSearch ? `<div class="dbx-result-path">${item.path}</div>` : '';
                return `
                    <div class="dbx-result-item${isSelected ? ' selected' : ''}" data-path="${item.path}" data-name="${item.name}" data-folder="${item.isFolder}">
                        <span class="dbx-result-icon">${icon}</span>
                        <div class="dbx-result-info">
                            <div class="dbx-result-name">${item.name}</div>
                            ${pathHtml}
                        </div>
                    </div>
                `;
            }).join('');
            container.innerHTML = html;
        }

        function handleDbxResultClick(e) {
            if (e.target.id === 'dbxShowAllBtn') {
                document.getElementById('dbxSearchInput').value = '';
                document.getElementById('dbxBreadcrumb').innerHTML = '';
                loadDropboxFolder('');
                return;
            }
            if (e.target.closest('.dbx-breadcrumb-link')) {
                const crumbPath = e.target.dataset.path;
                loadDropboxFolder(crumbPath);
                return;
            }
            const item = e.target.closest('.dbx-result-item');
            if (!item) return;
            const path = item.dataset.path;
            const name = item.dataset.name;
            const isFolder = item.dataset.folder === 'true';
            if (isFolder) {
                loadDropboxFolder(path);
            } else {
                loadDropboxFile(path, name);
            }
        }

        function handleDbxSearch() {
            const query = document.getElementById('dbxSearchInput').value.trim();
            if (!query) {
                loadDropboxFolder('');
                return;
            }
            if (query.startsWith('/')) {
                const path = query.replace(/\/+$/, '') || '';
                loadDropboxFolder(path);
                return;
            }
            searchDropboxFiles(query);
        }

        async function createDbxTxtFile() {
            if (!dropboxAccessToken) return;

            const lastCrumb = document.querySelector('#dbxBreadcrumb .dbx-breadcrumb-link:last-child');
            const folderPath = lastCrumb ? lastCrumb.dataset.path : '';

            const name = window.prompt('Enter filename (without .txt):');
            if (name === null || name.trim() === '') return;

            const fileName = name.trim().endsWith('.txt') ? name.trim() : name.trim() + '.txt';
            const targetPath = (folderPath || '') + '/' + fileName;

            setDbxStatus('Creating "' + fileName + '"...');
            try {
                const response = await fetch('https://content.dropboxapi.com/2/files/upload', {
                    method: 'POST',
                    headers: {
                        Authorization: 'Bearer ' + dropboxAccessToken,
                        'Dropbox-API-Arg': JSON.stringify({
                            path: targetPath,
                            mode: 'add',
                            autorename: true,
                            mute: true,
                        }),
                        'Content-Type': 'application/octet-stream',
                    },
                    body: '',
                });
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error_summary || 'HTTP ' + response.status);
                }
                setDbxStatus('Created "' + fileName + '"');
                loadDropboxFolder(folderPath);
            } catch (error) {
                setDbxStatus('Error creating file: ' + error.message);
            }
        }

        // Expose upload function for recording integration
        window.uploadToDropboxRecordings = async function(blob, filename) {
            if (!dropboxAccessToken) {
                console.warn('Dropbox not signed in ‚Äî recording saved locally only');
                return false;
            }
            const targetPath = '/recordings/vercel/' + filename;
            try {
                const response = await fetch('https://content.dropboxapi.com/2/files/upload', {
                    method: 'POST',
                    headers: {
                        Authorization: 'Bearer ' + dropboxAccessToken,
                        'Dropbox-API-Arg': JSON.stringify({
                            path: targetPath,
                            mode: 'add',
                            autorename: true,
                            mute: true,
                        }),
                        'Content-Type': 'application/octet-stream',
                    },
                    body: blob,
                });
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error_summary || 'HTTP ' + response.status);
                }
                console.log('Recording uploaded to Dropbox:', targetPath);
                return true;
            } catch (error) {
                console.error('Dropbox upload failed:', error);
                return false;
            }
        };

        // Setup event listeners on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', function() {
            // Handle OAuth redirect
            handleDropboxOAuthRedirect();

            // Dropbox button listeners
            document.getElementById('dbxCloseBtn').addEventListener('click', closeDropboxSidebar);
            document.getElementById('dbxSignInBtn').addEventListener('click', handleDropboxSignIn);
            document.getElementById('dbxSignOutBtn').addEventListener('click', handleDropboxSignOut);
            document.getElementById('dbxSearchBtn').addEventListener('click', handleDbxSearch);
            document.getElementById('dbxCreateTxtBtn').addEventListener('click', createDbxTxtFile);
            document.getElementById('dbxSearchInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleDbxSearch();
            });
            document.getElementById('dbxResults').addEventListener('click', handleDbxResultClick);
            document.getElementById('dbxBreadcrumb').addEventListener('click', (e) => {
                const link = e.target.closest('.dbx-breadcrumb-link');
                if (link) loadDropboxFolder(link.dataset.path);
            });
            document.getElementById('dbxSaveBtn').addEventListener('click', saveToDropbox);

            // Content viewer controls
            document.getElementById('dbxToggleViewBtn').addEventListener('click', toggleDbxContentView);
            document.getElementById('dbxFontPlus').addEventListener('click', () => changeDbxContentFont(1));
            document.getElementById('dbxFontMinus').addEventListener('click', () => changeDbxContentFont(-1));
        });
    })();
    </script>
</body>
</html>


