<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube Viewer (Looper)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #FF6B35 0%, #F7931E 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 25px;
            padding: 35px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.2);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 25px;
            font-size: 2.5rem;
            background: linear-gradient(45deg, #FF6B35, #F7931E);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .section {
            background: rgba(255, 255, 255, 0.6);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            border: 2px solid rgba(255, 107, 53, 0.2);
        }

        .section-title {
            font-size: 1.3rem;
            color: #FF6B35;
            margin-bottom: 15px;
            font-weight: 700;
            text-align: center;
        }

        .paste-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }

        .paste-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(76, 175, 80, 0.4);
        }

        .youtube-container {
            position: relative;
            width: 100%;
            height: 0;
            padding-bottom: 56.25%;
            border-radius: 10px;
            overflow: hidden;
            background: #000;
        }

        .youtube-container iframe,
        .youtube-container #youtube-player {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 10px;
        }

        .media-container {
            position: relative;
            width: 100%;
            border-radius: 10px;
            overflow: hidden;
            background: #000;
            display: none;
        }

        .media-container video,
        .media-container audio {
            width: 100%;
            border-radius: 10px;
        }

        .media-container audio {
            height: 60px;
        }

        .time-offset-control {
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.1), rgba(255, 152, 0, 0.1));
            border: 1px solid rgba(255, 193, 7, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 1rem 0;
            text-align: center;
        }

        .time-offset-control h4 {
            color: #FFC107;
            margin: 0 0 10px 0;
            font-size: 1.1rem;
        }

        .time-input {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            border: 2px solid rgba(255, 193, 7, 0.5);
            border-radius: 8px;
            font-size: 1rem;
            width: 80px;
            text-align: center;
            font-family: monospace;
        }

        .time-input:focus {
            outline: none;
            border-color: #FFC107;
            box-shadow: 0 0 5px rgba(255, 193, 7, 0.3);
        }

        .jump-btn {
            padding: 8px 16px;
            background: linear-gradient(45deg, #FF5722, #E64A19);
            color: white;
            border: none;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-left: 10px;
        }

        .jump-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 87, 34, 0.4);
        }

        .time-btn {
            padding: 6px 12px;
            color: white;
            border: none;
            border-radius: 15px;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .time-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
        }

        .time-btn.active {
            border: 3px solid #FFD700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
        }

        .current-time-display {
            background: transparent;
            border: none;
            border-radius: 0;
            padding: 4px 0;
            margin-top: 3px;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            font-weight: 600;
            display: none;
        }

        .time-label {
            color: #4CAF50;
            margin-right: 6px;
        }

        .time-value {
            color: #4CAF50;
            background: transparent;
            padding: 0;
            border-radius: 0;
            border: none;
            min-width: 60px;
            display: inline-block;
            font-weight: 700;
        }

        .status-display {
            text-align: center;
            padding: 10px;
            margin: 10px 0;
            border-radius: 8px;
            font-weight: 600;
            display: none;
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid #4CAF50;
            color: #4CAF50;
        }

        #loopTimerStatus {
            display: none;
            text-align: center;
            margin-top: 10px;
            padding: 10px;
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid #4CAF50;
            border-radius: 8px;
            color: #4CAF50;
            font-family: monospace;
            font-weight: 600;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .container {
                padding: 20px;
            }
        }

        /* Memorize Component Styles */
        .memorize-container {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            color: #333;
        }

        .memorize-btn-row {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .memorize-btn {
            padding: 10px 16px;
            font-family: inherit;
            font-size: 13px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: opacity 0.2s, transform 0.2s;
            font-weight: 600;
        }
        .memorize-btn:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }
        .memorize-btn-primary { background: linear-gradient(45deg, #FF6B35, #F7931E); color: #fff; }
        .memorize-btn-secondary { background: #666; color: #fff; }
        .memorize-btn-success { background: linear-gradient(45deg, #4CAF50, #45a049); color: #fff; }
        .memorize-btn-warning { background: linear-gradient(45deg, #ff9800, #e68900); color: #fff; }
        .memorize-btn-danger { background: linear-gradient(45deg, #f44336, #d32f2f); color: #fff; }

        .memorize-info-bar {
            display: flex;
            justify-content: space-between;
            padding: 10px 15px;
            background: #e8e8e8;
            border-radius: 6px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }

        .memorize-input-group {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .memorize-input {
            padding: 10px 15px;
            font-size: 14px;
            font-family: inherit;
            background: #fff;
            border: 2px solid #ddd;
            color: #333;
            border-radius: 6px;
            width: 150px;
        }
        .memorize-input:focus {
            outline: none;
            border-color: #FF6B35;
        }

        .memorize-content-display {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 15px;
            max-height: 250px;
            overflow-y: auto;
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 15px;
            margin-top: 15px;
        }
        .memorize-content-display.full {
            max-height: 400px;
        }

        .memorize-line {
            display: flex;
            padding: 3px 0;
        }
        .memorize-line-num {
            color: #999;
            min-width: 35px;
            text-align: right;
            margin-right: 12px;
            user-select: none;
        }
        .memorize-line-text {
            flex: 1;
            white-space: pre-wrap;
            word-break: break-word;
        }
        .memorize-line.highlighted {
            background: #e3f2fd;
            border-left: 3px solid #2196F3;
            padding-left: 10px;
            margin-left: -10px;
        }

        .memorize-selected-text {
            background: #e3f2fd;
            border-radius: 6px;
            padding: 15px;
            margin-top: 15px;
            font-size: 16px;
            line-height: 1.8;
            min-height: 80px;
        }
        .memorize-selected-text .memorize-line {
            padding: 4px 0;
        }

        .memorize-commands {
            background: #e8e8e8;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 11px;
            color: #666;
        }
        .memorize-commands code {
            color: #FF6B35;
            background: #fff;
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: 600;
        }

        .memorize-hidden { display: none; }

        .memorize-toggle-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .memorize-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }
        .memorize-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .memorize-slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #4CAF50;
            transition: .3s;
            border-radius: 24px;
        }
        .memorize-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .memorize-switch input:checked + .memorize-slider {
            background-color: #ff6b6b;
        }
        .memorize-switch input:checked + .memorize-slider:before {
            transform: translateX(20px);
        }
        .memorize-toggle-label {
            font-size: 12px;
            color: #666;
            font-weight: 600;
        }

        .memorize-speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .memorize-speed-control label {
            color: #666;
            font-size: 12px;
        }
        .memorize-select {
            padding: 6px 10px;
            font-family: inherit;
            font-size: 12px;
            background: #fff;
            border: 2px solid #ddd;
            color: #333;
            border-radius: 5px;
            cursor: pointer;
        }
        .memorize-select:focus {
            outline: none;
            border-color: #FF6B35;
        }

        .memorize-status {
            text-align: center;
            padding: 10px;
            background: #e3f2fd;
            border-radius: 6px;
            margin-top: 10px;
            color: #1976D2;
            font-weight: 600;
        }

        /* Toggle Slider Switch */
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider-toggle {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ddd;
            transition: .4s;
            border-radius: 26px;
        }

        .slider-toggle:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        input:checked + .slider-toggle {
            background: linear-gradient(45deg, #FF5722, #E64A19);
        }

        input:checked + .slider-toggle:before {
            transform: translateX(24px);
        }

        .toggle-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .toggle-label {
            font-size: 0.9em;
            color: #495057;
            font-weight: 500;
        }

        /* Compact Metronome */
        .metronome-section {
            background: #2f2f2f;
            border-radius: 8px;
            padding: 10px 15px;
            margin-top: 10px;
        }

        .metronome-section .counter {
            text-align: center;
            padding: 8px 0;
            background: #404040;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .metronome-section .counter .dot {
            width: 12px;
            height: 12px;
            display: inline-block;
            margin: 0 6px;
            background: #FFF;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
        }

        .metronome-section .counter .dot.active {
            background: #5ec2ff;
        }

        .metronome-section .controls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
            color: #FFF;
            font-size: 12px;
        }

        .metronome-section .controls label {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .metronome-section .controls input[type="text"] {
            width: 40px;
            border: 0;
            text-align: center;
            padding: 4px;
            background: #FFF;
            color: #222;
            border-radius: 3px;
            font-size: 12px;
        }

        .metronome-section .controls .bpm-minus,
        .metronome-section .controls .bpm-plus {
            cursor: pointer;
            padding: 0 5px;
            color: #222;
        }

        .metronome-section .controls .bpm-minus:hover,
        .metronome-section .controls .bpm-plus:hover {
            color: #FA6900;
        }

        .metronome-section .controls .bpm-wrapper {
            background: #FFF;
            padding: 2px 5px;
            border-radius: 3px;
            display: flex;
            align-items: center;
        }

        .metronome-section .play-btn,
        .metronome-section .tap-btn {
            padding: 6px 15px;
            border: 0;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            min-width: auto;
            flex: none;
        }

        .metronome-section .play-btn {
            background: #D6E26D;
            color: #3d430d;
        }

        .metronome-section .play-btn:hover {
            background: #e8efad;
        }

        .metronome-section .tap-btn {
            background: #888;
            color: #fbfbfb;
        }

        .metronome-section .tap-btn:hover {
            background: #959595;
        }

        .metronome-section .timer-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .metronome-section .timer-group input[type="checkbox"] {
            display: none;
        }

        .metronome-section .timer-group input[type="checkbox"] + label {
            display: inline-block;
            height: 12px;
            width: 12px;
            background: #FFF;
            cursor: pointer;
            position: relative;
        }

        .metronome-section .timer-group input[type="checkbox"]:checked + label:before {
            content: "";
            display: inline-block;
            width: 3px;
            height: 6px;
            background: #F38630;
            position: absolute;
            top: 0;
            left: 2px;
            transform: skewX(30deg);
        }

        .metronome-section .timer-group input[type="checkbox"]:checked + label:after {
            content: "";
            display: inline-block;
            width: 3px;
            height: 10px;
            background: #F38630;
            position: absolute;
            top: 0;
            left: 6px;
            transform: skewX(-30deg);
        }

        /* Link Pagination Navbar */
        .link-pagination-navbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            gap: 12px;
            z-index: 9999;
            padding: 0 20px;
            border-bottom: 3px solid #FF6B35;
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.5);
        }
        .link-pagination-navbar.active {
            display: flex;
        }
        .link-nav-btn {
            width: 36px;
            height: 36px;
            background: linear-gradient(45deg, #FF6B35, #F7931E);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            color: white;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .link-nav-btn:hover:not(:disabled) {
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.5);
        }
        .link-nav-btn:disabled {
            background: #555;
            opacity: 0.5;
            cursor: not-allowed;
        }
        .link-label-display {
            width: 450px;
            padding: 10px 20px;
            background: linear-gradient(45deg, #FF6B35, #F7931E);
            color: white;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .link-counter {
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            font-weight: bold;
            min-width: 50px;
            text-align: center;
        }
        .link-go-btn {
            padding: 8px 20px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            color: white;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s ease;
            margin-left: 10px;
        }
        .link-go-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.5);
        }
        .link-close-btn {
            width: 32px;
            height: 32px;
            background: #e74c3c;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            color: white;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 10px;
        }
        .link-close-btn:hover {
            background: #c0392b;
            transform: scale(1.1);
        }
        .pagination-auto-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: 15px;
            padding: 6px 12px;
            background: rgba(50, 50, 50, 0.9);
            border-radius: 20px;
            border: 1px solid rgba(255, 107, 53, 0.3);
        }
        .pagination-auto-label {
            font-size: 12px;
            color: #aaa;
            font-weight: 500;
        }
        .pagination-timer {
            font-size: 13px;
            color: #4CAF50;
            font-weight: bold;
            min-width: 40px;
            text-align: center;
        }
        .pagination-timer.active {
            color: #FF6B35;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        body.pagination-active {
            padding-top: 70px;
        }
    </style>
</head>
<body>
    <!-- Link Pagination Navbar -->
    <div id="linkPaginationNavbar" class="link-pagination-navbar">
        <button id="linkNextBtn" class="link-nav-btn" onclick="paginationNext()">‚ñ∂</button>
        <button id="linkPrevBtn" class="link-nav-btn" onclick="paginationPrev()">‚óÄ</button>
        <div id="linkLabelDisplay" class="link-label-display">Link Name</div>
        <span id="linkCounter" class="link-counter">1/1</span>
        <button class="link-go-btn" onclick="goAutoplayPending = true; loadCurrentPaginationLink()">Go</button>
        <button id="navbarLoopBtn" class="link-go-btn" style="background:linear-gradient(45deg,#9C27B0,#7B1FA2);margin-left:5px;padding:8px 14px;" onclick="toggleNavbarLoop(this)">üîÅ 3</button>
        <button class="link-go-btn" style="background:linear-gradient(45deg,#1565C0,#0D47A1);margin-left:5px;padding:8px 14px;" onclick="window.open('https://cdpn.io/pen/debug/KwVxmKR','_blank')">üîó reader</button>
        <!-- Auto-play toggle -->
        <div class="pagination-auto-group">
            <span class="pagination-auto-label">Auto</span>
            <label class="switch">
                <input type="checkbox" id="paginationAutoPlay">
                <span class="slider-toggle"></span>
            </label>
            <span id="paginationTimer" class="pagination-timer"></span>
        </div>
        <button class="link-close-btn" onclick="closePagination()">‚úï</button>
    </div>

    <div class="container">
        <h1>Youtube Viewer (and Looper)</h1>

        <!-- Clipboard Button -->
        <div style="text-align: center; margin-bottom: 20px; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; align-items: center;">
            <button id="loadDefaultBtn" class="jump-btn" style="display: none; background: linear-gradient(45deg, #4CAF50, #45a049); font-size: 13px; padding: 10px 19px;">üé¨ Load Default</button>
            <input type="text" id="accessCodeInput" placeholder="123" autocomplete="off" value="" style="width: 80px; padding: 8px 12px; font-size: 14px; border: 2px solid rgb(255, 152, 0); border-radius: 6px; background: rgb(42, 42, 42); color: white; outline: none;">
            <button id="loadYouTubeClipboardBtn" class="jump-btn" style="background: linear-gradient(45deg, #FF9800, #F57C00); font-size: 13px; padding: 10px 19px;">üìã Paste Media + Times</button>
            <button id="copyShareableLinkBtn" class="jump-btn" style="display: none; background: linear-gradient(45deg, #9C27B0, #7B1FA2); font-size: 13px; padding: 10px 19px;">üîó Copy Shareable Link</button>
            <button id="cleanTranscriptBtn" class="jump-btn" style="background: linear-gradient(45deg, #2196F3, #1976D2); font-size: 13px; padding: 10px 19px;">‚ú® Clean & Copy Transcript</button>
            <button id="restoreTranscriptBtn" class="jump-btn" style="background: linear-gradient(45deg, #00BCD4, #0097A7); font-size: 13px; padding: 10px 19px;">üìÑ Restore Prev. Pasted Trans.</button>
            <a id="textProcessorLink" href="processedText.html" class="jump-btn" style="background: linear-gradient(45deg, #E91E63, #C2185B); font-size: 13px; padding: 10px 19px; text-decoration: none; color: white;">üìù Text Processor</a>
            <button id="cloudNotesToggleBtn" class="jump-btn" style="background: linear-gradient(45deg, #607D8B, #455A64); font-size: 13px; padding: 10px 19px;">‚òÅÔ∏è Cloud Notes</button>
        </div>

        <!-- Inline Cloud Notes Section -->
        <div id="cloudNotesSection" style="display:none; margin-bottom: 20px; padding: 15px; background: #1a1a2e; border-radius: 8px; border: 1px solid #333;">
            <div style="display: flex; gap: 10px; margin-bottom: 10px; align-items: center; flex-wrap: wrap;">
                <button id="cloudNotesLoadBtn" class="jump-btn" style="background: linear-gradient(45deg, #2196F3, #1976D2); font-size: 12px; padding: 8px 16px;">üì• Load</button>
                <button id="cloudNotesSaveBtn" class="jump-btn" style="background: linear-gradient(45deg, #4CAF50, #45a049); font-size: 12px; padding: 8px 16px;">üíæ Save</button>
                <span id="cloudNotesStatus" style="font-size: 13px; color: #888;"></span>
            </div>
            <textarea id="cloudNotesTextarea" placeholder="Your cloud notes..." style="width: 100%; min-height: 150px; padding: 12px; font-size: 14px; border: 2px solid #333; border-radius: 6px; background: #2a2a2a; color: #fff; resize: vertical; outline: none; font-family: inherit; line-height: 1.5; box-sizing: border-box;"></textarea>
        </div>

        <!-- Time Controls -->
        <div class="time-offset-control">
            <h4>‚è∞ Time Controls</h4>
            <div style="display: flex; align-items: center; justify-content: center; gap: 10px; flex-wrap: wrap; margin-bottom: 15px;">
                <label for="customTimesInput" style="color: #FFC107; font-weight: 600;">Add Media + Times:</label>
                <input type="text" id="customTimesInput" class="time-input" placeholder="URL (YouTube/Dropbox/etc), 1:15,2:00,3:10" style="width: 280px;">
                <button id="addTimesBtn" class="jump-btn" style="background: linear-gradient(45deg, #2196F3, #1976D2);">‚ûï Add</button>
                <button id="clearTimesBtn" class="jump-btn" style="display: none; background: linear-gradient(45deg, #f44336, #d32f2f); font-size: 12px; padding: 8px 16px;">üóëÔ∏è Clear All</button>
                <button id="copyCurrentStateBtn" class="jump-btn" style="background: linear-gradient(45deg, #8BC34A, #689F38); font-size: 12px; padding: 8px 16px;">üìã Copy URL+Times</button>
            </div>
        </div>

        <!-- Saved Times Section (directly above video) -->
        <div style="margin-bottom: 5px; padding: 10px; background: rgba(255, 193, 7, 0.05); border-radius: 10px;">
            <div style="display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 8px;">
                <label style="color: #FFC107; font-weight: 600; font-size: 1rem; margin: 0;">‚ö° Saved Times:</label>
                <button id="clearSavedTimesBtn" class="time-btn" style="background: linear-gradient(45deg, #f44336, #d32f2f); padding: 4px 10px; font-size: 10px;">üóëÔ∏è Clear</button>
            </div>
            <div id="savedTimesButtons" style="display: flex; justify-content: center; gap: 8px; flex-wrap: wrap;">
                <!-- Buttons will be loaded from localStorage or default video -->
            </div>
        </div>

        <!-- YouTube Video Section -->
        <div class="youtube-section">
            <div class="youtube-container" id="youtubeContainer">
                <div id="youtube-player"></div>
            </div>

            <!-- HTML5 Media Player (for Dropbox videos/audio) -->
            <div class="media-container" id="mediaContainer">
                <video id="html5-player" controls controlsList="nodownload">
                    Your browser does not support the video tag.
                </video>
            </div>

            <div class="media-container" id="audioContainer">
                <audio id="audio-player" controls controlsList="nodownload">
                    Your browser does not support the audio tag.
                </audio>
            </div>

            <!-- Current Time Display (below video players) -->
            <div class="current-time-display" id="currentTimeDisplay" style="display: none;">
                <label style="color: #FFC107; font-weight: 600; font-size: 12px;">üîÑ Loop to:</label>
                <button id="loopTimeMinus30" class="jump-btn" style="background: linear-gradient(45deg, #9E9E9E, #757575); padding: 4px 8px; font-size: 11px; margin-right: 4px;">‚àí30s</button>
                <input type="text" id="loopStartTime" class="time-input" placeholder="0:01" value="0:01" style="width: 65px; text-align: center; font-size: 12px; padding: 4px 6px;">
                <button id="loopTimePlus30" class="jump-btn" style="background: linear-gradient(45deg, #9E9E9E, #757575); padding: 4px 8px; font-size: 11px; margin-left: 4px;">+30s</button>
                <button id="loopTimePlus5" class="jump-btn" style="background: linear-gradient(45deg, #78909C, #546E7A); padding: 4px 8px; font-size: 11px; margin-left: 4px; margin-right: 15px;">+5s</button>
                <span class="time-label">Current Time:</span>
                <span class="time-value" id="currentTimeValue">--:--</span>
                <button id="timer30sBtn" class="jump-btn" style="background: linear-gradient(45deg, #00BCD4, #0097A7); margin-left: 15px; padding: 6px 12px; font-size: 12px;">‚è±Ô∏è 30s</button>
                <button id="timer60sBtn" class="jump-btn" style="background: linear-gradient(45deg, #8BC34A, #689F38); margin-left: 10px; padding: 6px 12px; font-size: 12px;">‚è±Ô∏è 1m</button>
                <button id="timer3minBtn" class="jump-btn" style="background: linear-gradient(45deg, #FF9800, #F57C00); margin-left: 10px; padding: 6px 12px; font-size: 12px;">‚è±Ô∏è 3m</button>
                <select id="timerCustomSelect" style="margin-left: 10px; padding: 5px 8px; font-size: 12px; border-radius: 6px; border: 2px solid #9C27B0; background: linear-gradient(45deg, #E1BEE7, #CE93D8); cursor: pointer; font-weight: 600;">
                    <option value="">‚è±Ô∏è Custom</option>
                    <option value="35">35s</option>
                    <option value="40">40s</option>
                    <option value="45">45s</option>
                    <option value="50">50s</option>
                </select>
                <span style="margin-left: 15px; color: #9C27B0; font-size: 12px; font-weight: 600;">üîÑ Repeat:</span>
                <label style="margin-left: 8px; cursor: pointer; font-size: 12px;">
                    <input type="radio" name="timerRepeat" value="1" style="cursor: pointer;"> 1 time
                </label>
                <label style="margin-left: 10px; cursor: pointer; font-size: 12px;">
                    <input type="radio" name="timerRepeat" value="8" style="cursor: pointer;"> 8 times
                </label>
                <label style="margin-left: 10px; cursor: pointer; font-size: 12px;">
                    <input type="radio" name="timerRepeat" value="30" checked style="cursor: pointer;"> 30 times
                </label>
                <label style="margin-left: 10px; cursor: pointer; font-size: 12px;">
                    <input type="radio" name="timerRepeat" value="50" style="cursor: pointer;"> 50 times
                </label>
            </div>
        </div>

        <!-- Status Display -->
        <div class="status-display" id="statusDisplay"></div>

        <!-- Birds Audio Player -->
        <div id="birdsAudioSection" style="background: linear-gradient(135deg, #4CAF50 0%, #2E7D32 100%); color: white; padding: 12px 15px; border-radius: 8px; margin-bottom: 10px;">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                <span style="font-weight: bold;">üê¶ Birds Chirping</span>
                <button id="birdsPlayBtn" onclick="toggleBirdsAudio()" style="background: rgba(255,255,255,0.2); border: 1px solid white; color: white; padding: 5px 12px; border-radius: 4px; cursor: pointer;">‚ñ∂ Play</button>
            </div>
            <audio id="birdsAudioElement" preload="metadata" controls style="width: 100%; height: 35px;"
                src="https://www.dropbox.com/scl/fi/2jzvla2xykyz2auqvcrcv/birds_chirping_23mins.mp3?rlkey=re6qjmobia9cr2ttf8nkmwkv1&st=96hl9yvs&raw=1">
            </audio>
        </div>

        <!-- Compact Metronome -->
        <div class="metronome-section">
            <div class="counter" id="metronomeCounter">
                <div class="dot active"></div>
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
            </div>
            <div class="controls">
                <label>BPM:
                    <span class="bpm-wrapper">
                        <span class="bpm-minus">‚àí</span>
                        <input type="text" value="60" class="bpm-input" id="metronomeBpm">
                        <span class="bpm-plus">+</span>
                    </span>
                </label>
                <label>Beat: <input type="text" value="4" class="ts-top" id="metronomeBeat"></label>
                <div class="timer-group">
                    <input type="checkbox" id="metronome-timer-check">
                    <label for="metronome-timer-check"></label>
                    Timer: <input type="text" value="60" class="timer" id="metronomeTimer">
                </div>
                <button class="tap-btn" id="metronomeTap">Tap</button>
                <button class="play-btn" id="metronomePlay">Play</button>
            </div>
        </div>

        <!-- Quick Links -->
        <div class="section" style="margin-top: 30px;">
            <h3 class="section-title">Quick Links</h3>
            <button class="paste-btn" onclick="pasteQuickLinks()" style="margin-bottom: 15px; background: linear-gradient(45deg, #8B5CF6, #7C3AED);">üìã Paste Links from Clipboard</button>
            <div class="toggle-group">
                <label class="switch">
                    <input type="checkbox" id="autoTimerToggle">
                    <span class="slider-toggle"></span>
                </label>
                <span class="toggle-label" id="autoTimerLabel">Normal Mode</span>
            </div>
            <div id="text-section" style="background: #f5f5f5; padding: 15px; border-radius: 8px; font-size: 1em; line-height: 1.6; white-space: pre-wrap;"></div>
        </div>

        <!-- Cloud Links Section -->
        <div class="section" style="margin-top: 30px;">
            <h3 class="section-title">Cloud Links</h3>
            <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-bottom: 15px; align-items: center;">
                <button id="loadCloudBtn" class="paste-btn" onclick="loadLinksFromCloud()" style="background: linear-gradient(45deg, #2196F3, #1976D2);">‚òÅÔ∏è Load Cloud</button>
                <button id="saveCloudBtn" class="paste-btn" onclick="saveLinksToCloud()" style="background: linear-gradient(45deg, #4CAF50, #45a049);">üíæ Save to Cloud</button>
                <button id="getYTTitleBtn" class="paste-btn" onclick="getAndAppendYouTubeTitle()" style="display: none; background: linear-gradient(45deg, #E91E63, #C2185B);">üé¨ Get YT Title</button>
            </div>
            <div id="cloud-section" style="background: #2a2a2a; color: #fff; padding: 15px; border-radius: 8px; font-size: 1em; line-height: 1.6; white-space: pre-wrap; min-height: 100px;"></div>

            <!-- Show Formatted Links Button -->
            <div style="margin-top: 15px; text-align: center;">
                <button id="toggleFormattedLinksBtn" class="paste-btn" onclick="toggleFormattedLinks()" style="background: linear-gradient(45deg, #9C27B0, #7B1FA2);">üìã Show Formatted Links</button>
            </div>

            <!-- Formatted Links Display (hidden by default) -->
            <div id="formatted-links-container" style="display: none; margin-top: 15px; position: relative;">
                <div style="background: #1e1e1e; color: #d4d4d4; padding: 15px; padding-top: 40px; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 0.9em; line-height: 1.5; white-space: pre-wrap; border: 1px solid #444; position: relative;">
                    <button id="copyFormattedLinksBtn" onclick="copyFormattedLinks()" style="position: absolute; top: 8px; right: 8px; padding: 6px 10px; border: none; border-radius: 4px; background: #2196F3; color: white; cursor: pointer; font-size: 14px; display: flex; align-items: center; gap: 5px;" title="Copy to clipboard">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                        </svg>
                        <span>Copy</span>
                    </button>
                    <div id="formatted-links-content"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- YouTube IFrame Player API -->
    <script src="https://www.youtube.com/iframe_api"></script>
    <!-- Template data loaded from external file for easy editing -->
    <script src="template_data.js"></script>
    <script>
        // ============================================
        // LINK PAGINATION SYSTEM
        // ============================================
        let allPaginationLinks = [];  // Array of {name, url}
        let currentPaginationIndex = 0;
        let paginationSource = null;  // 'text' or 'cloud'
        let goAutoplayPending = false; // Flag: Go button was clicked, play after embed + 500ms

        // Parse links from text-section template
        function parseTextSectionLinks() {
            const lines = template_for_copy_and_paste.split('\n').map(l => l.trim()).filter(l => l);
            const entries = [];
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (line.startsWith('http://') || line.startsWith('https://')) {
                    entries.push({ name: '', url: line });
                } else if (i + 1 < lines.length) {
                    const nextLine = lines[i + 1];
                    if (nextLine.startsWith('http://') || nextLine.startsWith('https://')) {
                        entries.push({ name: line, url: nextLine });
                        i++;
                    }
                }
            }
            return entries;
        }

        // Activate pagination from text-section
        function activatePaginationFromText(clickedUrl) {
            allPaginationLinks = parseTextSectionLinks();
            paginationSource = 'text';
            const index = allPaginationLinks.findIndex(l => l.url === clickedUrl);
            currentPaginationIndex = index >= 0 ? index : 0;
            showPagination();
            loadCurrentPaginationLink();
        }

        // Activate pagination from cloud-section
        function activatePaginationFromCloud(clickedUrl) {
            allPaginationLinks = parseCloudLinks();
            paginationSource = 'cloud';
            const index = allPaginationLinks.findIndex(l => l.url === clickedUrl);
            currentPaginationIndex = index >= 0 ? index : 0;
            showPagination();
            loadCurrentPaginationLink();
        }

        // Show the pagination navbar
        function showPagination() {
            const navbar = document.getElementById('linkPaginationNavbar');
            navbar.classList.add('active');
            document.body.classList.add('pagination-active');
            updatePaginationDisplay();
            // Start auto-play timer if enabled
            const toggle = document.getElementById('paginationAutoPlay');
            if (toggle && toggle.checked) {
                startAutoPlayTimer();
            }
        }

        // Close pagination
        function closePagination() {
            const navbar = document.getElementById('linkPaginationNavbar');
            navbar.classList.remove('active');
            document.body.classList.remove('pagination-active');
            allPaginationLinks = [];
            currentPaginationIndex = 0;
            stopAutoPlayTimer();
        }

        // Update the pagination display
        function updatePaginationDisplay() {
            if (allPaginationLinks.length === 0) return;
            const current = allPaginationLinks[currentPaginationIndex];
            const labelDisplay = document.getElementById('linkLabelDisplay');
            const counter = document.getElementById('linkCounter');
            const prevBtn = document.getElementById('linkPrevBtn');
            const nextBtn = document.getElementById('linkNextBtn');

            labelDisplay.textContent = current.name || current.url;
            labelDisplay.title = current.url;
            counter.textContent = `${currentPaginationIndex + 1}/${allPaginationLinks.length}`;
            prevBtn.disabled = currentPaginationIndex === 0;
            nextBtn.disabled = currentPaginationIndex === allPaginationLinks.length - 1;
        }

        // Navigate to previous link (display only, no embed)
        function paginationPrev() {
            if (currentPaginationIndex > 0) {
                currentPaginationIndex--;
                updatePaginationDisplay();
                resetAutoPlayTimer();
            }
        }

        // Navigate to next link (display only, no embed)
        function paginationNext() {
            if (currentPaginationIndex < allPaginationLinks.length - 1) {
                currentPaginationIndex++;
                updatePaginationDisplay();
                resetAutoPlayTimer();
            }
        }

        // Load the current pagination link (auto-embed)
        // autoplay: if true, video will start playing automatically
        function loadCurrentPaginationLink(autoplay = false) {
            if (allPaginationLinks.length === 0) return;
            const current = allPaginationLinks[currentPaginationIndex];
            loadMediaFromUrl(current.url, autoplay);
        }

        function toggleNavbarLoop(buttonElement) {
            // If this timer is already running, cancel it
            if (timerTimeout && timerButtonRef === buttonElement) {
                clearTimeout(timerTimeout);
                timerTimeout = null;
                timerLoopsRemaining = 0;
                buttonElement.textContent = 'üîÅ 3';
                buttonElement.style.background = 'linear-gradient(45deg, #9C27B0, #7B1FA2)';
                showStatus('Navbar loop cancelled', 'info');
                return;
            }

            // If another timer is running, cancel it first
            if (timerTimeout) {
                clearTimeout(timerTimeout);
                resetTimerButton();
            }

            // Set repeat radio to 8
            const radio8 = document.querySelector('input[name="timerRepeat"][value="8"]');
            if (radio8) radio8.checked = true;

            // Setup 3-minute timer with 8 repeats
            timerLabel = 'üîÅ 3';
            timerDefaultBg = 'linear-gradient(45deg, #9C27B0, #7B1FA2)';
            timerDurationMs = 180000;
            timerTotalLoops = 8;
            timerLoopsRemaining = 8;
            timerButtonRef = buttonElement;

            // Get start time from loopStartTime input
            const loopStartTimeInput = document.getElementById('loopStartTime');
            const timeStr = loopStartTimeInput.value.trim();
            timerStartTime = parseTimeToSeconds(timeStr);
            if (timerStartTime === null) timerStartTime = 0;

            // Jump to start and begin looping
            jumpToYouTubeTime(timerStartTime);
            startTimerLoop();
        }

        // ============ AUTO-PLAY TIMER ============
        const AUTO_ADVANCE_SECONDS = 180; // 3 minutes
        const FADE_OUT_SECONDS = 3; // Start fading 3 seconds before switch
        let autoPlayTimerId = null;
        let autoPlayTimeRemaining = AUTO_ADVANCE_SECONDS;
        let isFadingOut = false;
        let fadeIntervalId = null;

        // Load saved preference
        function loadAutoPlayPreference() {
            const saved = localStorage.getItem('paginationAutoPlay');
            const toggle = document.getElementById('paginationAutoPlay');
            if (toggle && saved === 'true') {
                toggle.checked = true;
                startAutoPlayTimer();
            }
        }

        // Format time as M:SS
        function formatAutoPlayTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Fade out volume over duration (in ms)
        function fadeOutVolume(duration = 2500, callback) {
            if (isFadingOut) return;
            isFadingOut = true;

            let currentVolume = 100;
            const steps = 25;
            const stepTime = duration / steps;
            const volumeStep = 100 / steps;

            // Try to get current volume from YouTube player
            if (player && typeof player.getVolume === 'function') {
                try {
                    currentVolume = player.getVolume();
                } catch (e) {}
            }

            const initialVolume = currentVolume;

            fadeIntervalId = setInterval(() => {
                currentVolume -= (initialVolume / steps);
                if (currentVolume <= 0) {
                    currentVolume = 0;
                    clearInterval(fadeIntervalId);
                    fadeIntervalId = null;
                    isFadingOut = false;
                    if (callback) callback();
                }

                // Set volume on YouTube player
                if (player && typeof player.setVolume === 'function') {
                    try {
                        player.setVolume(Math.max(0, currentVolume));
                    } catch (e) {}
                }

                // Set volume on HTML5 video/audio
                const html5Video = document.querySelector('#html5Container video');
                const html5Audio = document.querySelector('#html5Container audio');
                if (html5Video) html5Video.volume = Math.max(0, currentVolume / 100);
                if (html5Audio) html5Audio.volume = Math.max(0, currentVolume / 100);
            }, stepTime);
        }

        // Reset volume to full
        function resetVolume() {
            if (fadeIntervalId) {
                clearInterval(fadeIntervalId);
                fadeIntervalId = null;
            }
            isFadingOut = false;

            if (player && typeof player.setVolume === 'function') {
                try {
                    player.setVolume(100);
                } catch (e) {}
            }
        }

        // Update timer display
        function updateTimerDisplay() {
            const timerEl = document.getElementById('paginationTimer');
            const toggle = document.getElementById('paginationAutoPlay');
            if (!timerEl) return;

            if (toggle && toggle.checked && currentPaginationIndex < allPaginationLinks.length - 1) {
                timerEl.textContent = formatAutoPlayTime(autoPlayTimeRemaining);
                timerEl.classList.add('active');
            } else {
                timerEl.textContent = '';
                timerEl.classList.remove('active');
            }
        }

        // Start the auto-play timer
        function startAutoPlayTimer() {
            stopAutoPlayTimer();
            autoPlayTimeRemaining = AUTO_ADVANCE_SECONDS;
            updateTimerDisplay();
            resetVolume();

            const toggle = document.getElementById('paginationAutoPlay');
            if (!toggle || !toggle.checked) return;
            if (currentPaginationIndex >= allPaginationLinks.length - 1) return;

            autoPlayTimerId = setInterval(() => {
                autoPlayTimeRemaining--;
                updateTimerDisplay();

                // Start fading out volume 3 seconds before switch
                if (autoPlayTimeRemaining === FADE_OUT_SECONDS && !isFadingOut) {
                    fadeOutVolume(2500);
                }

                if (autoPlayTimeRemaining <= 0) {
                    // Time's up - advance to next and load it with autoplay
                    paginationNext();
                    loadCurrentPaginationLink(true); // true = autoplay
                    autoPlayTimeRemaining = AUTO_ADVANCE_SECONDS;
                    resetVolume();

                    // Stop if we reached the last link
                    if (currentPaginationIndex >= allPaginationLinks.length - 1) {
                        stopAutoPlayTimer();
                    }
                }
            }, 1000);
        }

        // Stop the auto-play timer
        function stopAutoPlayTimer() {
            if (autoPlayTimerId) {
                clearInterval(autoPlayTimerId);
                autoPlayTimerId = null;
            }
            if (fadeIntervalId) {
                clearInterval(fadeIntervalId);
                fadeIntervalId = null;
            }
            isFadingOut = false;
            updateTimerDisplay();
        }

        // Reset timer when navigating
        function resetAutoPlayTimer() {
            const toggle = document.getElementById('paginationAutoPlay');
            if (toggle && toggle.checked) {
                startAutoPlayTimer();
            }
        }

        // Auto-play toggle event listener
        document.addEventListener('DOMContentLoaded', function() {
            const toggle = document.getElementById('paginationAutoPlay');
            if (toggle) {
                toggle.addEventListener('change', function() {
                    localStorage.setItem('paginationAutoPlay', this.checked.toString());
                    if (this.checked) {
                        startAutoPlayTimer();
                    } else {
                        stopAutoPlayTimer();
                    }
                });
            }
            loadAutoPlayPreference();
        });
        // ============ END AUTO-PLAY TIMER ============

        // Keyboard navigation for pagination
        document.addEventListener('keydown', function(e) {
            const navbar = document.getElementById('linkPaginationNavbar');
            if (!navbar.classList.contains('active')) return;
            if (['INPUT', 'TEXTAREA', 'SELECT'].includes(e.target.tagName)) return;

            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                paginationPrev();
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                paginationNext();
            } else if (e.key === 'Enter') {
                e.preventDefault();
                loadCurrentPaginationLink();
            } else if (e.key === 'Escape') {
                e.preventDefault();
                closePagination();
            }
        });
        // ============================================

        // Populate text-section with clickable URLs
        function populateQuickLinks() {
            const container = document.getElementById('text-section');
            const lines = template_for_copy_and_paste.split('\n');

            container.innerHTML = ''; // Clear existing content

            lines.forEach((line, index) => {
                const trimmedLine = line.trim();

                // Check if the line is a URL
                if (trimmedLine.startsWith('http://') || trimmedLine.startsWith('https://')) {
                    // Create clickable span for URL
                    const span = document.createElement('span');
                    span.textContent = trimmedLine;
                    span.style.cssText = 'cursor: pointer; color: #2196F3; text-decoration: underline; transition: all 0.2s ease;';
                    span.dataset.url = trimmedLine;

                    // Hover effects
                    span.addEventListener('mouseenter', function() {
                        this.style.color = '#FF6B35';
                        this.style.background = 'rgba(255, 107, 53, 0.1)';
                    });
                    span.addEventListener('mouseleave', function() {
                        this.style.color = '#2196F3';
                        this.style.background = 'transparent';
                    });

                    // Click to activate pagination and load video
                    span.addEventListener('click', function() {
                        const url = this.dataset.url;
                        const autoTimerToggle = document.getElementById('autoTimerToggle');

                        // Visual feedback
                        const originalText = this.textContent;
                        const originalColor = this.style.color;
                        this.textContent = '‚úÖ Loading...';
                        this.style.color = '#4CAF50';

                        setTimeout(() => {
                            this.textContent = originalText;
                            this.style.color = originalColor;
                        }, 1500);

                        // Activate pagination and load video
                        activatePaginationFromText(url);

                        // Check if Auto Timer mode is ON
                        if (autoTimerToggle && autoTimerToggle.checked) {
                            // Select the 50 times radio button
                            const radio50 = document.querySelector('input[name="timerRepeat"][value="50"]');
                            if (radio50) {
                                radio50.checked = true;
                            }

                            // Extract timestamp from URL (e.g., &t=958s or ?t=505s)
                            let startSeconds = 0;
                            const timeMatch = url.match(/[?&]t=(\d+)s?/);
                            if (timeMatch) {
                                startSeconds = parseInt(timeMatch[1], 10);
                            }

                            // Wait for video to load, then seek to timestamp and start timer
                            setTimeout(() => {
                                // Jump to the extracted timestamp
                                if (startSeconds > 0) {
                                    jumpToYouTubeTime(startSeconds);
                                }

                                // Trigger the 30s timer button after a short delay
                                setTimeout(() => {
                                    const timer30sBtn = document.getElementById('timer30sBtn');
                                    if (timer30sBtn) {
                                        timer30sBtn.click();
                                    }
                                }, 500);
                            }, 1500);
                        }
                    });

                    container.appendChild(span);
                } else {
                    // Regular text (label)
                    const textNode = document.createTextNode(trimmedLine);
                    container.appendChild(textNode);
                }

                // Add line break after each line (except the last)
                if (index < lines.length - 1) {
                    container.appendChild(document.createElement('br'));
                }
            });
        }

        // Initialize quick links on page load
        populateQuickLinks();

        // Auto Timer toggle event listener
        const autoTimerToggle = document.getElementById('autoTimerToggle');
        if (autoTimerToggle) {
            autoTimerToggle.addEventListener('change', function() {
                const label = document.getElementById('autoTimerLabel');
                if (this.checked) {
                    label.textContent = 'Auto Timer Mode (50x)';
                    label.style.color = '#FF5722';
                    label.style.fontWeight = '600';
                } else {
                    label.textContent = 'Normal Mode';
                    label.style.color = '#495057';
                    label.style.fontWeight = '500';
                }
            });
        }

        // Paste quick links from clipboard (format: "name, url" or "name,url")
        function pasteQuickLinks() {
            navigator.clipboard.readText()
                .then(text => {
                    if (!text.trim()) {
                        alert('Clipboard is empty. Please copy some links first.');
                        return;
                    }

                    const lines = text.split('\n');
                    let parsedContent = '';
                    let linkCount = 0;

                    lines.forEach(line => {
                        const trimmedLine = line.trim();

                        // Skip empty lines
                        if (!trimmedLine) return;

                        // Check if line contains a URL (has http:// or https://)
                        if (trimmedLine.includes('http://') || trimmedLine.includes('https://')) {
                            // Try to parse "name, url" or "name,url" format
                            const commaIndex = trimmedLine.indexOf(',');
                            if (commaIndex > 0) {
                                const name = trimmedLine.substring(0, commaIndex).trim();
                                const url = trimmedLine.substring(commaIndex + 1).trim();

                                if (url.startsWith('http://') || url.startsWith('https://')) {
                                    parsedContent += name + '\n' + url + '\n';
                                    linkCount++;
                                }
                            } else if (trimmedLine.startsWith('http://') || trimmedLine.startsWith('https://')) {
                                // Just a URL without a name
                                parsedContent += trimmedLine + '\n';
                                linkCount++;
                            }
                        }
                        // Skip lines that don't contain URLs (treat as notes)
                    });

                    if (linkCount === 0) {
                        alert('No valid links found. Expected format: "name, url" (e.g., "notion, https://www.notion.so")');
                        return;
                    }

                    // Update the template and re-populate
                    template_for_copy_and_paste = parsedContent.trim();
                    populateQuickLinks();

                    console.log(`Loaded ${linkCount} links from clipboard`);
                })
                .catch(err => {
                    console.error('Failed to read clipboard contents:', err);
                    alert('Unable to access clipboard. Please check browser permissions or paste manually.');
                });
        }

        // ============================================
        // CLOUD STORAGE FUNCTIONS (Vercel Blob)
        // ============================================

        const CLOUD_LINKS_FILENAME = 'youtube_quick_links.txt';
        let cloudLinksContent = '';

        // Populate cloud-section with clickable URLs (similar to text-section)
        // Parse cloud content into array of {name, url} objects
        function parseCloudLinks() {
            const lines = cloudLinksContent.split('\n').map(l => l.trim()).filter(l => l);
            const entries = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (line.startsWith('http://') || line.startsWith('https://')) {
                    // URL without a name before it
                    entries.push({ name: '', url: line });
                } else if (i + 1 < lines.length) {
                    const nextLine = lines[i + 1];
                    if (nextLine.startsWith('http://') || nextLine.startsWith('https://')) {
                        // This is a name, next is URL
                        entries.push({ name: line, url: nextLine });
                        i++; // Skip the URL line
                    }
                }
            }
            return entries;
        }

        // Rebuild cloud content from entries array
        function rebuildCloudContent(entries) {
            return entries.map(e => e.name ? `${e.name}\n${e.url}` : e.url).join('\n');
        }

        function populateCloudLinks() {
            const container = document.getElementById('cloud-section');
            if (!cloudLinksContent.trim()) {
                container.innerHTML = '<span style="color: #888;">No cloud links. Load from cloud or paste & save.</span>';
                return;
            }

            const entries = parseCloudLinks();
            container.innerHTML = '';

            entries.forEach((entry, index) => {
                // Create row container
                const row = document.createElement('div');
                row.style.cssText = 'display: flex; align-items: center; gap: 8px; padding: 8px; margin-bottom: 5px; background: rgba(255,255,255,0.05); border-radius: 6px; flex-wrap: wrap;';
                row.dataset.index = index;

                // Name span (editable on click)
                const nameSpan = document.createElement('span');
                nameSpan.textContent = entry.name || '(no name)';
                nameSpan.style.cssText = 'color: #FFC107; font-weight: 600; min-width: 100px; cursor: pointer;';
                nameSpan.title = 'Click to edit name';
                nameSpan.addEventListener('click', function() {
                    const newName = prompt('Edit name:', entry.name);
                    if (newName !== null) {
                        entry.name = newName;
                        cloudLinksContent = rebuildCloudContent(parseCloudLinks().map((e, i) => i === index ? entry : e));
                        populateCloudLinks();
                        // Auto-save if access code present
                        const accessCode = document.getElementById('accessCodeInput').value.trim();
                        if (accessCode) saveLinksToCloud();
                    }
                });

                // URL span (clickable to load video)
                const urlSpan = document.createElement('span');
                urlSpan.textContent = entry.url.length > 50 ? entry.url.substring(0, 50) + '...' : entry.url;
                urlSpan.style.cssText = 'flex: 1; color: #64B5F6; text-decoration: underline; cursor: pointer; min-width: 150px;';
                urlSpan.title = entry.url;
                urlSpan.addEventListener('click', function() {
                    // Visual feedback
                    urlSpan.textContent = '‚úÖ Loading...';
                    urlSpan.style.color = '#4CAF50';

                    // Activate pagination and load video
                    activatePaginationFromCloud(entry.url);

                    setTimeout(() => {
                        urlSpan.textContent = entry.url.length > 50 ? entry.url.substring(0, 50) + '...' : entry.url;
                        urlSpan.style.color = '#64B5F6';
                    }, 1500);
                });
                urlSpan.addEventListener('mouseenter', function() {
                    this.style.color = '#FF6B35';
                    this.style.background = 'rgba(255, 107, 53, 0.2)';
                });
                urlSpan.addEventListener('mouseleave', function() {
                    this.style.color = '#64B5F6';
                    this.style.background = 'transparent';
                });

                // Edit button
                const editBtn = document.createElement('button');
                editBtn.textContent = '‚úèÔ∏è';
                editBtn.style.cssText = 'padding: 4px 8px; border: none; border-radius: 4px; background: #2196F3; color: white; cursor: pointer; font-size: 12px;';
                editBtn.title = 'Edit name';
                editBtn.addEventListener('click', function() {
                    const newName = prompt('Edit name:', entry.name);
                    if (newName !== null) {
                        const allEntries = parseCloudLinks();
                        allEntries[index].name = newName;
                        cloudLinksContent = rebuildCloudContent(allEntries);
                        populateCloudLinks();
                        const accessCode = document.getElementById('accessCodeInput').value.trim();
                        if (accessCode) saveLinksToCloud();
                    }
                });

                // Delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'üóëÔ∏è';
                deleteBtn.style.cssText = 'padding: 4px 8px; border: none; border-radius: 4px; background: #f44336; color: white; cursor: pointer; font-size: 12px;';
                deleteBtn.title = 'Delete entry';
                deleteBtn.addEventListener('click', function() {
                    if (confirm(`Delete "${entry.name || entry.url}"?`)) {
                        const allEntries = parseCloudLinks();
                        allEntries.splice(index, 1);
                        cloudLinksContent = rebuildCloudContent(allEntries);
                        populateCloudLinks();
                        const accessCode = document.getElementById('accessCodeInput').value.trim();
                        if (accessCode) saveLinksToCloud();
                    }
                });

                row.appendChild(nameSpan);
                row.appendChild(urlSpan);
                row.appendChild(editBtn);
                row.appendChild(deleteBtn);
                container.appendChild(row);
            });
        }

        // Load links from Vercel Blob
        async function loadLinksFromCloud() {
            const loadBtn = document.getElementById('loadCloudBtn');
            loadBtn.textContent = '‚è≥ Loading...';
            loadBtn.disabled = true;

            try {
                const response = await fetch('/api/files');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                const files = data.files || {};

                if (files[CLOUD_LINKS_FILENAME]) {
                    cloudLinksContent = files[CLOUD_LINKS_FILENAME];
                    populateCloudLinks();
                    loadBtn.textContent = '‚úì Loaded!';
                    loadBtn.style.background = 'linear-gradient(45deg, #4CAF50, #45a049)';
                    console.log('‚úì Loaded cloud links');
                } else {
                    cloudLinksContent = '';
                    populateCloudLinks();
                    loadBtn.textContent = '‚òÅÔ∏è No file';
                    console.log('No cloud links file found');
                }

                setTimeout(() => {
                    loadBtn.textContent = '‚òÅÔ∏è Load Cloud';
                    loadBtn.style.background = 'linear-gradient(45deg, #2196F3, #1976D2)';
                    loadBtn.disabled = false;
                }, 2000);

            } catch (error) {
                console.error('Error loading from cloud:', error);
                loadBtn.textContent = '‚ùå Error';
                setTimeout(() => {
                    loadBtn.textContent = '‚òÅÔ∏è Load Cloud';
                    loadBtn.style.background = 'linear-gradient(45deg, #2196F3, #1976D2)';
                    loadBtn.disabled = false;
                }, 2000);
            }
        }

        // Save links to Vercel Blob
        async function saveLinksToCloud() {
            const accessCode = document.getElementById('accessCodeInput').value.trim();
            if (!accessCode) {
                alert('Please enter access code');
                return false;
            }

            const saveBtn = document.getElementById('saveCloudBtn');
            saveBtn.textContent = '‚è≥ Saving...';
            saveBtn.disabled = true;

            try {
                const response = await fetch('/api/files', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        filename: CLOUD_LINKS_FILENAME,
                        content: cloudLinksContent,
                        accessCode: accessCode
                    })
                });

                const data = await response.json();

                if (!response.ok) {
                    if (response.status === 401) {
                        alert('Invalid access code');
                        saveBtn.textContent = '‚ùå Invalid Code';
                    } else {
                        throw new Error(data.error || 'Failed to save');
                    }
                } else {
                    saveBtn.textContent = '‚úì Saved!';
                    saveBtn.style.background = 'linear-gradient(45deg, #4CAF50, #45a049)';
                    console.log('‚úì Saved cloud links');
                }

                setTimeout(() => {
                    saveBtn.textContent = 'üíæ Save to Cloud';
                    saveBtn.style.background = 'linear-gradient(45deg, #4CAF50, #45a049)';
                    saveBtn.disabled = false;
                }, 2000);

                return response.ok;

            } catch (error) {
                console.error('Error saving to cloud:', error);
                saveBtn.textContent = '‚ùå Error';
                setTimeout(() => {
                    saveBtn.textContent = 'üíæ Save to Cloud';
                    saveBtn.style.background = 'linear-gradient(45deg, #4CAF50, #45a049)';
                    saveBtn.disabled = false;
                }, 2000);
                return false;
            }
        }

        // Append current video + title to cloud links and auto-save
        async function appendToCloudAndSave(title, url) {
            const accessCode = document.getElementById('accessCodeInput').value.trim();
            if (!accessCode) return; // Only append if access code is present

            // Append to cloud content
            const newEntry = title + '\n' + url;
            if (cloudLinksContent.trim()) {
                cloudLinksContent = cloudLinksContent.trim() + '\n' + newEntry;
            } else {
                cloudLinksContent = newEntry;
            }

            // Update the UI
            populateCloudLinks();

            // Auto-save to cloud
            await saveLinksToCloud();
        }

        // Get YouTube video title using IFrame API and append to cloud
        async function getAndAppendYouTubeTitle() {
            if (!player || !playerReady || typeof player.getVideoData !== 'function') {
                showStatus('No YouTube video loaded', 'error');
                return;
            }

            const videoData = player.getVideoData();
            const title = videoData.title || 'Untitled';
            const videoId = videoData.video_id;
            const url = `https://www.youtube.com/watch?v=${videoId}`;

            // Copy to clipboard
            const entry = title + '\n' + url;
            try {
                await navigator.clipboard.writeText(entry);
                showStatus(`Copied: ${title}`, 'success');
            } catch (err) {
                console.error('Failed to copy:', err);
            }

            // Append to cloud and save
            await appendToCloudAndSave(title, url);
        }

        // ============================================
        // FORMATTED LINKS DISPLAY FUNCTIONS
        // ============================================

        // Generate formatted text from cloud links content
        function generateFormattedLinks() {
            if (!cloudLinksContent.trim()) {
                return '(No links available)';
            }

            const entries = parseCloudLinks();
            const formatted = entries.map(entry => {
                if (entry.name) {
                    return `${entry.name}\n${entry.url}`;
                }
                return entry.url;
            }).join('\n');

            return formatted;
        }

        // Toggle the formatted links display
        function toggleFormattedLinks() {
            const container = document.getElementById('formatted-links-container');
            const content = document.getElementById('formatted-links-content');
            const btn = document.getElementById('toggleFormattedLinksBtn');

            if (container.style.display === 'none') {
                // Show the formatted links
                const formatted = generateFormattedLinks();
                content.textContent = formatted;
                container.style.display = 'block';
                btn.textContent = 'üìã Hide Formatted Links';
                btn.style.background = 'linear-gradient(45deg, #E91E63, #C2185B)';
            } else {
                // Hide the formatted links
                container.style.display = 'none';
                btn.textContent = 'üìã Show Formatted Links';
                btn.style.background = 'linear-gradient(45deg, #9C27B0, #7B1FA2)';
            }
        }

        // Copy formatted links to clipboard
        async function copyFormattedLinks() {
            const content = document.getElementById('formatted-links-content');
            const copyBtn = document.getElementById('copyFormattedLinksBtn');
            const originalHTML = copyBtn.innerHTML;

            try {
                await navigator.clipboard.writeText(content.textContent);
                copyBtn.innerHTML = '<span>‚úì Copied!</span>';
                copyBtn.style.background = '#4CAF50';

                setTimeout(() => {
                    copyBtn.innerHTML = originalHTML;
                    copyBtn.style.background = '#2196F3';
                }, 2000);
            } catch (err) {
                console.error('Failed to copy:', err);
                copyBtn.innerHTML = '<span>‚ùå Error</span>';
                copyBtn.style.background = '#f44336';

                setTimeout(() => {
                    copyBtn.innerHTML = originalHTML;
                    copyBtn.style.background = '#2196F3';
                }, 2000);
            }
        }

        // Auto-load cloud links on page load
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                loadLinksFromCloud();
            }, 1000);
        });

        // ===== Birds Audio Player (LG TV compatible) =====
        function toggleBirdsAudio() {
            const audio = document.getElementById('birdsAudioElement');
            const btn = document.getElementById('birdsPlayBtn');

            if (audio.paused) {
                // LG TV fix: force load before playing
                audio.load();
                audio.volume = 0.3;
                audio.muted = false;

                audio.play().then(() => {
                    btn.textContent = '‚è∏ Pause';
                }).catch(err => {
                    console.error('Audio play failed:', err);
                    // Try reload on error
                    audio.load();
                    setTimeout(() => {
                        audio.play();
                        btn.textContent = '‚è∏ Pause';
                    }, 500);
                });
            } else {
                audio.pause();
                btn.textContent = '‚ñ∂ Play';
            }
        }

        // Initialize birds audio on page load (LG TV fix)
        document.addEventListener('DOMContentLoaded', function() {
            const birdsAudio = document.getElementById('birdsAudioElement');
            if (birdsAudio) {
                // Force initial load for LG TV compatibility
                birdsAudio.load();
                birdsAudio.volume = 0.3;
                birdsAudio.muted = false;

                // Sync button state with audio events
                birdsAudio.addEventListener('play', () => {
                    document.getElementById('birdsPlayBtn').textContent = '‚è∏ Pause';
                });
                birdsAudio.addEventListener('pause', () => {
                    document.getElementById('birdsPlayBtn').textContent = '‚ñ∂ Play';
                });
                birdsAudio.addEventListener('ended', () => {
                    document.getElementById('birdsPlayBtn').textContent = '‚ñ∂ Play';
                });
            }
        });
    </script>
    <script>
        // ===== IndexedDB Wrapper Class =====
        class IndexedDBWrapper {
            constructor() {
                this.dbConnections = new Map();
                this.availableKeys = new Set();
                this.DB_VERSION = 1;
                this.STORE_NAME = 'content';
            }

            async openDatabase(databaseName) {
                if (this.dbConnections.has(databaseName)) {
                    return this.dbConnections.get(databaseName);
                }

                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(databaseName, this.DB_VERSION);

                    request.onerror = () => reject(new Error(`Failed to open database: ${request.error?.message}`));

                    request.onsuccess = () => {
                        const db = request.result;
                        this.dbConnections.set(databaseName, db);

                        db.onclose = () => this.dbConnections.delete(databaseName);
                        db.onerror = (event) => console.error(`Database error for ${databaseName}:`, event);

                        resolve(db);
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;

                        if (!db.objectStoreNames.contains(this.STORE_NAME)) {
                            const store = db.createObjectStore(this.STORE_NAME, { keyPath: 'key' });
                            store.createIndex('timestamp', 'timestamp', { unique: false });
                            store.createIndex('dataType', 'dataType', { unique: false });
                        }
                    };
                });
            }

            async set(databaseName, key, data) {
                const db = await this.openDatabase(databaseName);

                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([this.STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(this.STORE_NAME);

                    const record = {
                        key,
                        data,
                        timestamp: Date.now(),
                        dataType: typeof data,
                        lastModified: new Date().toISOString()
                    };

                    const request = store.put(record);
                    request.onsuccess = () => {
                        console.log(`‚úì Saved: ${databaseName}/${key}`);
                        resolve();
                    };
                    request.onerror = () => reject(new Error(`Save failed: ${request.error?.message}`));
                });
            }

            async get(databaseName, key) {
                const db = await this.openDatabase(databaseName);

                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([this.STORE_NAME], 'readonly');
                    const store = transaction.objectStore(this.STORE_NAME);
                    const request = store.get(key);

                    request.onsuccess = () => {
                        const result = request.result;

                        resolve({
                            exists: () => !!result,
                            val: () => result ? result.data : null,
                            key: () => key,
                            ref: { key }
                        });
                    };

                    request.onerror = () => reject(new Error(`Get failed: ${request.error?.message}`));
                });
            }

            async delete(databaseName, key) {
                const db = await this.openDatabase(databaseName);

                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([this.STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(this.STORE_NAME);
                    const request = store.delete(key);

                    request.onsuccess = () => {
                        console.log(`‚úì Deleted: ${databaseName}/${key}`);
                        resolve();
                    };
                    request.onerror = () => reject(new Error(`Delete failed: ${request.error?.message}`));
                });
            }

            async getAllKeys(databaseName) {
                const db = await this.openDatabase(databaseName);

                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([this.STORE_NAME], 'readonly');
                    const store = transaction.objectStore(this.STORE_NAME);
                    const request = store.getAllKeys();

                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(new Error(`Get keys failed: ${request.error?.message}`));
                });
            }
        }

        // Initialize IndexedDB wrapper
        const indexedDBWrapper = new IndexedDBWrapper();
        const DB_NAME = 'basketballStorage';
        const SAVED_TIMES_KEY = 'youtubelichess';

        // Extract YouTube video ID from URL
        function extractVideoId(url) {
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
            const match = url.match(regExp);
            return (match && match[2].length === 11) ? match[2] : null;
        }

        // Default basketball tutorial video with times
        const defaultVideo = "https://www.youtube.com/watch?v=DYM8HNXMq-A, 1:15, 2:30, 4:45, 6:00";

        // Player state
        let player = null;
        let playerReady = false;
        let currentVideoId = null;
        let timeUpdateInterval = null;
        let lastKnownTime = 0;
        let seekDetectionThreshold = 1.5; // If time jumps more than 1.5 seconds, it's a seek
        let lastClickedTime = null; // Track the last clicked timestamp
        let currentTimeIndex = -1; // Track current position in saved times for cycling

        // Media player state (for HTML5 video/audio)
        let playerType = 'youtube'; // 'youtube', 'video', or 'audio'
        let html5Player = null;
        let audioPlayer = null;
        let currentMediaUrl = null;

        // Loop Timer variables
        let loopTimerActive = false;
        let loopTimerInterval = null;
        let loopResetInterval = null;
        let loopTimerEndTime = null;
        let loopBaseTime = null;
        let loopNextResetTime = null;
        let loopIntervalSeconds = 13;
        let currentLoopButton = null;
        const originalPageTitle = document.title;

        // Beep sound for timer completion
        const beepSound = new Audio('https://assets.codepen.io/1075762/beep1.mp3');

        // ============ CONFIG: Text Processor Link ============
        const TEXT_PROCESSOR_URL = "https://cdpn.io/pen/debug/KwzBPaM";  // Replace with your CodePen URL
        // =====================================================

        // Set the Text Processor link to open in new tab
        const textProcessorLink = document.getElementById('textProcessorLink');
        if (textProcessorLink) {
            textProcessorLink.addEventListener('click', function(e) {
                e.preventDefault();
                window.open(TEXT_PROCESSOR_URL, '_blank');
            });
        }



        // Store last cleaned transcript for restore functionality
        let lastCleanedTranscript = null;

        // Check URL parameters on page load
        function checkUrlParameters() {
            // Get everything after the ? in the URL
            const queryString = window.location.search;

            if (!queryString || queryString.length <= 1) return null;

            // Remove the leading '?' and decode the URL
            const param = decodeURIComponent(queryString.substring(1));

            // The parameter should be the full URL + times string
            // Example: ?https://www.youtube.com/watch?v=m0e43ItU8oo,3:10,3:40,1:10

            // Clean up any extra whitespace
            const cleanParam = param.trim();

            console.log('üé¨ URL parameter found (original):', param);
            console.log('üé¨ URL parameter found (cleaned):', cleanParam);
            return cleanParam;
        }

        // Check for timer parameter in URL (e.g., &timer=25)
        function checkTimerParameter() {
            const queryString = window.location.search;
            if (!queryString) return null;

            // Look for &timer=X or timer=X in the URL
            const timerMatch = queryString.match(/[&?]timer=(\d+)/);
            if (timerMatch) {
                return parseInt(timerMatch[1]);
            }
            return null;
        }

        // Auto-trigger timer based on URL parameter
        function autoTriggerTimer() {
            const timerMinutes = checkTimerParameter();
            if (timerMinutes === 5) {
                console.log('üîÑ Auto-triggering 5min timer from URL parameter');
                const btn = document.getElementById('loopTimer5minBtn');
                if (btn) btn.click();
            } else if (timerMinutes === 25) {
                console.log('üîÑ Auto-triggering 25min timer from URL parameter');
                const btn = document.getElementById('loopTimer25minBtn');
                if (btn) btn.click();
            }
        }

        // YouTube API ready callback
        function onYouTubeIframeAPIReady() {
            console.log('üé¨ YouTube IFrame API ready');

            // Check if URL parameter exists
            const urlParam = checkUrlParameters();

            if (urlParam) {
                // Load from URL parameter with a delay to ensure API is ready
                console.log('üé¨ Loading from URL parameter:', urlParam);

                // Remove timer parameter from the URL param before processing
                const cleanUrlParam = urlParam.replace(/&timer=\d+/g, '');

                // Wait a bit for the API to be fully ready
                setTimeout(async () => {
                    try {
                        // Check if URL parameter includes times (has commas)
                        const hasTimes = cleanUrlParam.includes(',');

                        // Save to IndexedDB only if URL includes times
                        processVideoAndTimes(cleanUrlParam, hasTimes);

                        // If URL doesn't have times, load saved times from IndexedDB
                        if (!hasTimes) {
                            const savedTimes = await loadSavedTimesFromIndexedDB();
                            if (savedTimes && savedTimes.length > 0) {
                                renderSavedTimes(savedTimes);
                                console.log('üíæ Loaded saved times from IndexedDB (URL had no times)');
                            }
                        }

                        showStatus('Loaded from URL!', 'success');

                        // Auto-trigger timer after video loads (with extra delay for player ready)
                        setTimeout(() => {
                            autoTriggerTimer();
                        }, 2000);
                    } catch (error) {
                        console.error('üé¨ Error loading from URL:', error);
                        showStatus('Error loading from URL, loading default', 'error');
                        loadDefaultVideo();
                    }
                }, 500);
            } else {
                // Try to load saved times from IndexedDB
                loadSavedTimesFromIndexedDB().then(savedTimes => {
                    if (savedTimes && savedTimes.length > 0) {
                        // Load saved times from IndexedDB
                        renderSavedTimes(savedTimes);
                        console.log('üíæ Loaded saved times from IndexedDB on page load');
                    } else {
                        // Load default if no saved times
                        loadDefaultVideo();
                    }
                });
            }
        }

        // YouTube player ready callback
        function onPlayerReady(event) {
            console.log('üé¨ YouTube Player ready');
            console.log('üé¨ DEBUG: Player object:', event.target);
            playerReady = true;
            player = event.target;

            // Go button: delay 500ms then auto-play
            if (goAutoplayPending) {
                goAutoplayPending = false;
                setTimeout(() => {
                    if (player && typeof player.playVideo === 'function') {
                        player.playVideo();
                    }
                }, 500);
            }

            startTimeUpdates();
            document.getElementById('currentTimeDisplay').style.display = 'flex';

            // Auto-append to cloud if access code is present
            const accessCode = document.getElementById('accessCodeInput');
            if (accessCode && accessCode.value.trim()) {
                setTimeout(async () => {
                    try {
                        const videoData = player.getVideoData();
                        const title = videoData.title || 'Untitled';
                        const videoId = videoData.video_id;
                        const url = `https://www.youtube.com/watch?v=${videoId}`;

                        // Check if this URL already exists in cloud content
                        if (!cloudLinksContent.includes(url)) {
                            await appendToCloudAndSave(title, url);
                            showStatus(`Auto-saved: ${title}`, 'success');
                        }
                    } catch (err) {
                        console.error('Auto-append failed:', err);
                    }
                }, 1500); // Wait for video data to be available
            }
        }

        // YouTube player state change callback
        function onPlayerStateChange(event) {
            console.log('üé¨ YouTube Player state changed:', event.data);

            if (event.data === YT.PlayerState.PLAYING) {
                startTimeUpdates();
            } else if (event.data === YT.PlayerState.PAUSED || event.data === YT.PlayerState.ENDED) {
                stopTimeUpdates();
            }
        }

        // Load default video
        function loadDefaultVideo() {
            console.log('üé¨ DEBUG: Loading defaultVideo:', defaultVideo);

            // Process the default video string (same format as addCustomTimes)
            processVideoAndTimes(defaultVideo);

            showStatus('Default video loaded!', 'success');
        }

        // Update URL parameter to reflect current state
        function updateUrlParameter() {
            // Get current URL
            let currentUrl = '';

            if (playerType === 'youtube' && currentVideoId) {
                // Reconstruct YouTube URL
                currentUrl = `https://www.youtube.com/watch?v=${currentVideoId}`;
            } else if ((playerType === 'video' || playerType === 'audio') && currentMediaUrl) {
                // Use the direct media URL
                currentUrl = currentMediaUrl;
            } else {
                return; // No media loaded
            }

            // Get all saved times
            const savedTimeButtons = document.querySelectorAll('.saved-time-btn');

            if (savedTimeButtons.length === 0) {
                return; // No times to save
            }

            // Build the format: URL, time1, time2, time3, ...
            const times = Array.from(savedTimeButtons).map(btn => btn.dataset.time);
            const formattedString = `${currentUrl}, ${times.join(', ')}`;

            // Update URL without reloading
            const newUrl = `${window.location.pathname}?${encodeURIComponent(formattedString)}`;
            window.history.replaceState({}, '', newUrl);
        }

        // Shared function to process "URL, time1, time2, ..." format
        function processVideoAndTimes(inputString, saveToIndexedDB = false) {
            console.log('üé¨ DEBUG processVideoAndTimes called with:', inputString);

            const container = document.getElementById('savedTimesButtons');

            // Clear all existing buttons first
            container.innerHTML = '';
            currentTimeIndex = -1; // Reset cycle index when loading new times

            // Split by comma and process each entry
            const entries = inputString.split(',').map(t => t.trim()).filter(t => t);

            console.log('üé¨ DEBUG entries after split:', entries);

            if (entries.length === 0) {
                console.log('üé¨ DEBUG no entries found');
                return;
            }

            // Check if the first element is a media URL
            const firstEntry = entries[0];
            let timeEntries = entries;

            console.log('üé¨ DEBUG firstEntry:', firstEntry);

            // Detect media type
            const mediaType = detectMediaType(firstEntry);

            console.log('üé¨ DEBUG mediaType detected:', mediaType);

            if (mediaType) {
                // It's a valid media URL - load it
                if (mediaType === 'youtube') {
                    // YouTube URL - use YouTube player
                    const videoId = extractVideoId(firstEntry);

                    console.log('üé¨ DEBUG videoId extracted:', videoId);

                    if (videoId) {
                        currentVideoId = videoId;
                        switchToPlayer('youtube');

                        // Clear and recreate player
                        const youtubeContainer = document.getElementById('youtubeContainer');
                        youtubeContainer.innerHTML = '<div id="youtube-player"></div>';

                        const initPlayer = () => {
                            if (typeof YT !== 'undefined' && YT.Player) {
                                player = new YT.Player('youtube-player', {
                                    height: '100%',
                                    width: '100%',
                                    videoId: videoId,
                                    playerVars: {
                                        'enablejsapi': 1,
                                        'rel': 0,
                                        'modestbranding': 1,
                                        'iv_load_policy': 3
                                    },
                                    events: {
                                        'onReady': onPlayerReady,
                                        'onStateChange': onPlayerStateChange
                                    }
                                });

                                console.log('üé¨ YouTube video loaded:', firstEntry);
                            } else {
                                setTimeout(initPlayer, 500);
                            }
                        };

                        initPlayer();
                    }
                } else {
                    // Direct media URL (video or audio) - use HTML5 player
                    switchToPlayer(mediaType);
                    loadHTML5Media(firstEntry, mediaType);
                    console.log('üé¨ Media loaded:', firstEntry, 'type:', mediaType);
                }

                // Remove the URL from the entries, keep only the times
                timeEntries = entries.slice(1);
            }

            // Process time entries
            let addedCount = 0;
            const colors = [
                'linear-gradient(45deg, #4CAF50, #45a049)',
                'linear-gradient(45deg, #2196F3, #1976D2)',
                'linear-gradient(45deg, #9C27B0, #7B1FA2)',
                'linear-gradient(45deg, #FF9800, #F57C00)',
                'linear-gradient(45deg, #607D8B, #455A64)',
                'linear-gradient(45deg, #E91E63, #C2185B)',
                'linear-gradient(45deg, #00BCD4, #0097A7)',
                'linear-gradient(45deg, #8BC34A, #689F38)',
                'linear-gradient(45deg, #FF5722, #E64A19)'
            ];

            timeEntries.forEach((timeEntry, index) => {
                const timeStr = timeEntry.trim();

                // Validate the time string
                const seconds = parseTimeToSeconds(timeStr);
                if (seconds !== null) {
                    // Create button element
                    const button = document.createElement('button');
                    button.className = 'saved-time-btn time-btn';
                    button.dataset.time = timeStr;
                    button.textContent = timeStr;
                    button.style.background = colors[addedCount % colors.length];

                    container.appendChild(button);
                    addedCount++;
                }
            });

            if (addedCount > 0) {
                // Re-attach listeners to new buttons
                attachTimeButtonListeners();

                // Update URL to reflect new state
                updateUrlParameter();

                // Save to IndexedDB only if requested (when URL has times or from Paste button)
                if (saveToIndexedDB) {
                    saveSavedTimesToIndexedDB();
                }
            }
        }

        // Setup event listeners
        document.addEventListener('DOMContentLoaded', function() {
            // Create metronome iframe
            const metronomeContainer = document.getElementById('metronomeIframeContainer');
            if (metronomeContainer) {
                const metronomeIframe = document.createElement('iframe');
                metronomeIframe.src = './metronome/dist/index.html';
                metronomeIframe.style.cssText = 'width: 100%; height: 400px; border: none; border-radius: 10px;';
                metronomeContainer.appendChild(metronomeIframe);
            }

            // Load default button
            document.getElementById('loadDefaultBtn').addEventListener('click', function() {
                loadDefaultVideo();
            });

            // YouTube clipboard button
            document.getElementById('loadYouTubeClipboardBtn').addEventListener('click', function() {
                loadYouTubeFromClipboard();
            });

            // Add custom times button
            document.getElementById('addTimesBtn').addEventListener('click', function() {
                addCustomTimes();
            });

            // Enter key support for custom times input
            document.getElementById('customTimesInput').addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    addCustomTimes();
                }
            });

            // Clear times button
            document.getElementById('clearTimesBtn').addEventListener('click', function() {
                clearAllTimes();
            });

            // Copy current state button
            document.getElementById('copyCurrentStateBtn').addEventListener('click', function() {
                copyCurrentStateToClipboard();
            });

            // Copy shareable link button
            document.getElementById('copyShareableLinkBtn').addEventListener('click', function() {
                copyShareableLink();
            });

            // Clean & Copy Transcript button
            document.getElementById('cleanTranscriptBtn').addEventListener('click', async function() {
                try {
                    // Read from clipboard
                    const text = await navigator.clipboard.readText();
                    console.log('üìã Clipboard content:', text.substring(0, 200) + '...');

                    if (!text.trim()) {
                        showStatus('Clipboard is empty - please copy transcript first', 'error');
                        return;
                    }

                    // Clean the transcript
                    const cleanedText = cleanTranscript(text);
                    console.log('üìã Cleaned text:', cleanedText.substring(0, 200) + '...');

                    if (!cleanedText) {
                        showStatus('No valid transcript content found', 'error');
                        return;
                    }

                    // Extract timestamps from the CLEANED text (which has one per minute)
                    const cleanedLines = cleanedText.split('\n');
                    const keptTimestamps = [];

                    for (let line of cleanedLines) {
                        line = line.trim();
                        // Check if line is a timestamp (M:SS or H:MM:SS)
                        const timeMatch = line.match(/^(\d+):(\d+)(?::(\d+))?$/);
                        if (timeMatch) {
                            keptTimestamps.push(line);
                        }
                    }

                    console.log('üìã Kept timestamps:', keptTimestamps);

                    if (keptTimestamps.length > 0) {
                        renderSavedTimes(keptTimestamps);
                        saveSavedTimesToIndexedDB();

                        // Store cleaned text for restore functionality
                        lastCleanedTranscript = cleanedText;

                        // Copy cleaned text back to clipboard
                        await navigator.clipboard.writeText(cleanedText);

                        // Visual feedback
                        const btn = this;
                        const originalText = btn.textContent;
                        btn.textContent = '‚úÖ Cleaned & Copied!';
                        btn.style.transform = 'scale(1.05)';

                        setTimeout(() => {
                            btn.textContent = originalText;
                            btn.style.transform = '';
                        }, 2000);

                        showStatus(`Transcript cleaned, ${keptTimestamps.length} times added, and copied!`, 'success');
                    } else {
                        // No timestamps found - don't store, show error
                        showStatus('No timestamps found in clipboard content - paste a transcript first', 'error');
                        return;
                    }

                } catch (err) {
                    console.error('Failed to process transcript:', err);
                    showStatus('Failed to read/write clipboard. Please grant permission.', 'error');
                }
            });

            // Restore Transcript button
            document.getElementById('restoreTranscriptBtn').addEventListener('click', async function() {
                if (!lastCleanedTranscript) {
                    showStatus('No transcript to restore - use "Clean & Copy Transcript" first', 'error');
                    return;
                }

                // Don't restore if it looks like a URL (not a transcript)
                if (lastCleanedTranscript.trim().startsWith('http')) {
                    showStatus('No valid transcript to restore', 'error');
                    return;
                }

                try {
                    await navigator.clipboard.writeText(lastCleanedTranscript);

                    // Visual feedback
                    const btn = this;
                    const originalText = btn.textContent;
                    btn.textContent = '‚úÖ Restored!';
                    btn.style.transform = 'scale(1.05)';

                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.transform = '';
                    }, 2000);

                    showStatus('Transcript restored to clipboard!', 'success');
                } catch (err) {
                    console.error('Failed to restore transcript:', err);
                    showStatus('Failed to write to clipboard', 'error');
                }
            });

            // Loop timer buttons
            const loopTimer5minBtn = document.getElementById('loopTimer5minBtn');
            if (loopTimer5minBtn) {
                loopTimer5minBtn.addEventListener('click', function() {
                    const intervalSeconds = getLoopInterval();
                    toggleLoopTimer(intervalSeconds, this, 5);
                });
            }

            const loopTimer25minBtn = document.getElementById('loopTimer25minBtn');
            if (loopTimer25minBtn) {
                loopTimer25minBtn.addEventListener('click', function() {
                    const intervalSeconds = getLoopInterval();
                    toggleLoopTimer(intervalSeconds, this, 25);
                });
            }

            // 30-second play button - plays 30s, pauses, rewinds 30s
            document.getElementById('timer30sBtn').addEventListener('click', function() {
                play30sThenRewind(this);
            });

            // 1-minute play button - plays 1min, pauses, rewinds 1min
            document.getElementById('timer60sBtn').addEventListener('click', function() {
                play60sThenRewind(this);
            });

            // 3-minute play button - plays 3min, pauses, rewinds 3min
            document.getElementById('timer3minBtn').addEventListener('click', function() {
                play3minThenRewind(this);
            });

            // Custom timer dropdown - plays selected duration, pauses, rewinds
            document.getElementById('timerCustomSelect').addEventListener('change', function() {
                if (this.value) {
                    playCustomThenRewind(this, parseInt(this.value));
                }
            });

            // Auto-detect valid time in loopStartTime input
            document.getElementById('loopStartTime').addEventListener('input', function() {
                const value = this.value.trim();
                // Match M:SS or MM:SS format (complete when 2 digits follow the colon)
                const match = value.match(/^(\d{1,2}):(\d{2})$/);
                if (match) {
                    const newTime = parseTimeToSeconds(value);
                    if (newTime !== null) {
                        // If a loop timer is running, update loopBaseTime
                        if (loopTimerActive) {
                            loopBaseTime = newTime;
                        }
                        // If a duration timer is running, update timerStartTime
                        if (timerTimeout) {
                            timerStartTime = newTime;
                        }
                    }
                }
            });

            // Loop time adjustment buttons (-30s and +30s)
            document.getElementById('loopTimeMinus30').addEventListener('click', function() {
                adjustLoopTime(-30);
            });
            document.getElementById('loopTimePlus30').addEventListener('click', function() {
                adjustLoopTime(30);
            });
            document.getElementById('loopTimePlus5').addEventListener('click', function() {
                adjustLoopTime(5);
            });

            // Clear Saved Times button (in the Saved Times section)
            document.getElementById('clearSavedTimesBtn').addEventListener('click', function() {
                clearAllTimes();
            });

            // Saved time buttons - jump directly to those times
            attachTimeButtonListeners();
        });

        // Attach click listeners to all saved time buttons
        function attachTimeButtonListeners() {
            document.querySelectorAll('.saved-time-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const time = this.dataset.time;

                    // Remove active class from all buttons
                    document.querySelectorAll('.saved-time-btn').forEach(b => b.classList.remove('active'));

                    // Add active class to clicked button
                    this.classList.add('active');

                    // Visual feedback on the button
                    this.style.transform = 'scale(1.15)';
                    this.style.boxShadow = '0 5px 20px rgba(255,255,255,0.6)';

                    // Parse and jump to the time
                    const seconds = parseTimeToSeconds(time);
                    if (seconds !== null) {
                        // Save the clicked timestamp before jumping
                        lastClickedTime = seconds;

                        // Update the loop start time input
                        const loopStartTimeInput = document.getElementById('loopStartTime');
                        if (loopStartTimeInput) {
                            loopStartTimeInput.value = time;
                        }

                        jumpToYouTubeTime(seconds);
                    }

                    // Reset button appearance (but keep the active class)
                    setTimeout(() => {
                        this.style.transform = '';
                        this.style.boxShadow = '';
                    }, 400);
                });
            });
        }


        // Add custom times as buttons
        function addCustomTimes() {
            const input = document.getElementById('customTimesInput');
            const inputValue = input.value.trim();

            if (!inputValue) {
                showStatus('Please enter URL and times: URL, 1:15,2:00,3:10', 'error');
                return;
            }

            // Check if it's a single time (not a URL, just one timestamp)
            const entries = inputValue.split(',').map(t => t.trim()).filter(t => t);
            const firstEntry = entries[0];
            const mediaType = detectMediaType(firstEntry);

            // If no media URL detected and it's just a single time, ADD to existing times
            if (!mediaType && entries.length === 1) {
                const timeStr = firstEntry;
                const seconds = parseTimeToSeconds(timeStr);

                if (seconds === null) {
                    showStatus('Invalid time format. Use MM:SS or H:MM:SS', 'error');
                    return;
                }

                // Get the container and count existing buttons
                const container = document.getElementById('savedTimesButtons');
                const existingButtons = container.querySelectorAll('.saved-time-btn');

                // Color palette for new buttons
                const colors = [
                    'linear-gradient(45deg, #4CAF50, #45a049)',
                    'linear-gradient(45deg, #2196F3, #1976D2)',
                    'linear-gradient(45deg, #9C27B0, #7B1FA2)',
                    'linear-gradient(45deg, #FF9800, #F57C00)',
                    'linear-gradient(45deg, #607D8B, #455A64)',
                    'linear-gradient(45deg, #E91E63, #C2185B)',
                    'linear-gradient(45deg, #00BCD4, #0097A7)',
                    'linear-gradient(45deg, #8BC34A, #689F38)',
                    'linear-gradient(45deg, #FF5722, #E64A19)'
                ];

                // Create and add the new button
                const button = document.createElement('button');
                button.className = 'saved-time-btn time-btn';
                button.dataset.time = timeStr;
                button.textContent = timeStr;
                button.style.background = colors[existingButtons.length % colors.length];

                container.appendChild(button);

                // Re-attach listeners to include the new button
                attachTimeButtonListeners();

                // NOTE: Don't save to IndexedDB when adding single times manually
                // Only save when pasting full sets of times

                showStatus(`Added time: ${timeStr}`, 'success');
                input.value = ''; // Clear input
                return;
            }

            // Otherwise, use the normal behavior (clear and load new times)
            // Don't save to IndexedDB here - only when using Paste button
            processVideoAndTimes(inputValue, false);

            showStatus('Media and times loaded!', 'success');
            input.value = ''; // Clear input
        }

        // Clear all time buttons
        async function clearAllTimes() {
            const container = document.getElementById('savedTimesButtons');
            container.innerHTML = '';
            currentTimeIndex = -1; // Reset cycle index

            // Clear IndexedDB
            try {
                await indexedDBWrapper.delete(DB_NAME, SAVED_TIMES_KEY);
                console.log('üíæ Cleared saved times from IndexedDB');
            } catch (error) {
                console.error('üíæ Error clearing saved times from IndexedDB:', error);
            }

            showStatus('All times cleared', 'info');
        }

        // Copy current URL + saved times to clipboard
        async function copyCurrentStateToClipboard() {
            // Get current URL
            let currentUrl = '';

            if (playerType === 'youtube' && currentVideoId) {
                // Reconstruct YouTube URL
                currentUrl = `https://www.youtube.com/watch?v=${currentVideoId}`;
            } else if ((playerType === 'video' || playerType === 'audio') && currentMediaUrl) {
                // Use the direct media URL
                currentUrl = currentMediaUrl;
            } else {
                showStatus('No media loaded', 'error');
                return;
            }

            // Get all saved times
            const savedTimeButtons = document.querySelectorAll('.saved-time-btn');

            if (savedTimeButtons.length === 0) {
                showStatus('No saved times available', 'error');
                return;
            }

            // Build the format: URL, time1, time2, time3, ...
            const times = Array.from(savedTimeButtons).map(btn => btn.dataset.time);
            const formattedString = `${currentUrl}, ${times.join(', ')}`;

            // Copy to clipboard
            try {
                await navigator.clipboard.writeText(formattedString);
                showStatus('Copied to clipboard!', 'success');

                // Visual feedback on button
                const btn = document.getElementById('copyCurrentStateBtn');
                const originalText = btn.textContent;
                btn.textContent = '‚úÖ Copied!';
                btn.style.transform = 'scale(1.05)';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.transform = '';
                }, 2000);
            } catch (err) {
                console.error('Failed to copy:', err);
                showStatus('Failed to copy to clipboard', 'error');
            }
        }

        // Copy shareable link (full URL with query parameters)
        async function copyShareableLink() {
            // Get current URL
            let currentUrl = '';

            if (playerType === 'youtube' && currentVideoId) {
                // Reconstruct YouTube URL
                currentUrl = `https://www.youtube.com/watch?v=${currentVideoId}`;
            } else if ((playerType === 'video' || playerType === 'audio') && currentMediaUrl) {
                // Use the direct media URL
                currentUrl = currentMediaUrl;
            } else {
                showStatus('No media loaded', 'error');
                return;
            }

            // Get all saved times
            const savedTimeButtons = document.querySelectorAll('.saved-time-btn');

            if (savedTimeButtons.length === 0) {
                showStatus('No saved times available', 'error');
                return;
            }

            // Build the format: URL, time1, time2, time3, ...
            const times = Array.from(savedTimeButtons).map(btn => btn.dataset.time);
            const formattedString = `${currentUrl}, ${times.join(', ')}`;

            // Build the shareable link
            const shareableLink = `${window.location.origin}${window.location.pathname}?${encodeURIComponent(formattedString)}`;

            // Copy to clipboard
            try {
                await navigator.clipboard.writeText(shareableLink);
                showStatus('Shareable link copied!', 'success');

                // Visual feedback on button
                const btn = document.getElementById('copyShareableLinkBtn');
                const originalText = btn.textContent;
                btn.textContent = '‚úÖ Copied!';
                btn.style.transform = 'scale(1.05)';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.transform = '';
                }, 2000);
            } catch (err) {
                console.error('Failed to copy:', err);
                showStatus('Failed to copy shareable link', 'error');
            }
        }

        // Adjust loop time by a given number of seconds
        function adjustLoopTime(deltaSeconds) {
            const loopStartTimeInput = document.getElementById('loopStartTime');
            const currentValue = loopStartTimeInput.value.trim();

            // If empty, treat as 0:00
            let currentSeconds = 0;
            if (currentValue) {
                currentSeconds = parseTimeToSeconds(currentValue);
                if (currentSeconds === null) currentSeconds = 0;
            }

            // Add delta, but don't go below 0
            let newSeconds = Math.max(0, currentSeconds + deltaSeconds);

            // Format back to time string
            const hours = Math.floor(newSeconds / 3600);
            const minutes = Math.floor((newSeconds % 3600) / 60);
            const seconds = Math.floor(newSeconds % 60);

            let timeStr;
            if (hours > 0) {
                timeStr = `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            } else {
                timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }

            loopStartTimeInput.value = timeStr;

            // Cancel any running timer
            if (timerTimeout) {
                clearTimeout(timerTimeout);
                cancelFades();
                resetTimerButton();
                timerTimeout = null;
                timerLoopsRemaining = 0;
                showStatus('Timer cancelled', 'info');
            }

            // Update loop timer state if active
            if (loopTimerActive) {
                loopBaseTime = newSeconds;
            }

            // Jump to the new time
            jumpToYouTubeTime(newSeconds);
        }

        // Parse time string to seconds (supports "1:23" or "83")
        function parseTimeToSeconds(timeStr) {
            timeStr = timeStr.trim();

            // If it's just numbers, treat as seconds
            if (/^\d+$/.test(timeStr)) {
                return parseInt(timeStr);
            }

            // If it's in MM:SS format
            const timeMatch = timeStr.match(/^(\d+):(\d+)$/);
            if (timeMatch) {
                const minutes = parseInt(timeMatch[1]);
                const seconds = parseInt(timeMatch[2]);

                if (seconds >= 60) {
                    return null;
                }

                return (minutes * 60) + seconds;
            }

            // If it's in H:MM:SS format
            const longTimeMatch = timeStr.match(/^(\d+):(\d+):(\d+)$/);
            if (longTimeMatch) {
                const hours = parseInt(longTimeMatch[1]);
                const minutes = parseInt(longTimeMatch[2]);
                const seconds = parseInt(longTimeMatch[3]);

                if (minutes >= 60 || seconds >= 60) {
                    return null;
                }

                return (hours * 3600) + (minutes * 60) + seconds;
            }

            return null;
        }

        // Jump to specific time in any player (YouTube or HTML5)
        function jumpToYouTubeTime(seconds) {
            if (playerType === 'youtube') {
                if (!currentVideoId) {
                    showStatus('No video loaded', 'error');
                    return;
                }

                // Use YouTube Player API to seek to time
                if (player && playerReady && typeof player.seekTo === 'function') {
                    player.seekTo(seconds, true);
                }
            } else {
                // HTML5 video or audio player
                const activePlayer = getActivePlayer();
                if (!activePlayer || !currentMediaUrl) {
                    showStatus('No media loaded', 'error');
                    return;
                }

                activePlayer.currentTime = seconds;
            }

            // If a timer is running, update the timer start position to the new time
            if (timerTimeout && timerLoopsRemaining > 0) {
                timerStartTime = seconds;
                console.log('‚è±Ô∏è Timer start position updated via jump to:', seconds);
            }

            // Format time for display
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const remainingSeconds = seconds % 60;

            let timeStr;
            if (hours > 0) {
                timeStr = `${hours}:${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
            } else if (minutes > 0) {
                timeStr = `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
            } else {
                timeStr = `${remainingSeconds}s`;
            }

            showStatus(`Jumped to ${timeStr}`, 'success');
        }

        // Control functions
        function reloadVideo() {
            if (currentVideoId) {
                player.loadVideoById(currentVideoId);
                showStatus('Video reloaded', 'success');
            }
        }

        function clearVideo() {
            // Clear YouTube player
            if (player && typeof player.destroy === 'function') {
                player.destroy();
            }
            player = null;
            currentVideoId = null;

            // Clear HTML5 players
            if (html5Player) {
                html5Player.pause();
                html5Player.src = '';
            }
            if (audioPlayer) {
                audioPlayer.pause();
                audioPlayer.src = '';
            }
            currentMediaUrl = null;

            // Reset state
            playerReady = false;
            playerType = 'youtube';

            // Update UI
            document.getElementById('youtubeContainer').innerHTML = '<div style="color: #666; text-align: center; padding: 40px;">Video cleared</div>';
            document.getElementById('mediaContainer').style.display = 'none';
            document.getElementById('audioContainer').style.display = 'none';

            stopTimeUpdates();
            document.getElementById('currentTimeDisplay').style.display = 'none';
            document.getElementById('currentTimeValue').textContent = '--:--';

            showStatus('Media cleared', 'info');
        }

        // Show status message
        let statusTimeout = null;
        function showStatus(message, type = 'info', persistent = false) {
            const statusDisplay = document.getElementById('statusDisplay');
            statusDisplay.textContent = message;
            statusDisplay.className = `status-display ${type}`;
            statusDisplay.style.display = 'block';

            if (statusTimeout) {
                clearTimeout(statusTimeout);
                statusTimeout = null;
            }

            if (!persistent) {
                statusTimeout = setTimeout(() => {
                    statusDisplay.style.display = 'none';
                }, 3000);
            }
        }

        // Direct video loading function (bypasses clipboard)
        // autoplay parameter: if true, video will start playing automatically
        function loadMediaFromUrl(url, autoplay = false) {
            if (!url || !url.trim()) {
                showStatus('No URL provided', 'error');
                return;
            }

            const mediaType = detectMediaType(url);

            if (!mediaType) {
                showStatus('Not a valid media URL (YouTube, MP4, MP3, etc.)', 'error');
                return;
            }

            if (mediaType === 'youtube') {
                const videoId = extractVideoId(url);
                if (!videoId) {
                    showStatus('Could not extract YouTube video ID', 'error');
                    return;
                }

                currentVideoId = videoId;
                switchToPlayer('youtube');

                const container = document.getElementById('youtubeContainer');
                container.innerHTML = '<div id="youtube-player"></div>';

                const initPlayer = () => {
                    if (typeof YT !== 'undefined' && YT.Player) {
                        player = new YT.Player('youtube-player', {
                            height: '100%',
                            width: '100%',
                            videoId: videoId,
                            playerVars: {
                                'enablejsapi': 1,
                                'rel': 0,
                                'modestbranding': 1,
                                'iv_load_policy': 3,
                                'autoplay': autoplay ? 1 : 0
                            },
                            events: {
                                'onReady': onPlayerReady,
                                'onStateChange': onPlayerStateChange
                            }
                        });
                    } else {
                        setTimeout(initPlayer, 500);
                    }
                };

                initPlayer();
            } else {
                switchToPlayer(mediaType);
                loadHTML5Media(url, mediaType, autoplay);
            }

            console.log('üé¨ DEBUG: Loaded media directly:', url, 'type:', mediaType);
            showStatus(`${mediaType === 'audio' ? 'Audio' : 'Video'} loaded!`, 'success');
        }

        // Clipboard Loading Function (handles YouTube, Dropbox, and direct media URLs)
        async function loadYouTubeFromClipboard() {
            try {
                const text = await navigator.clipboard.readText();
                console.log('üé¨ DEBUG: Clipboard text:', text);

                if (!text.trim()) {
                    showStatus('Clipboard is empty', 'error');
                    return;
                }

                // Split by comma to check if there are times included
                const entries = text.split(',').map(t => t.trim()).filter(t => t);
                const firstEntry = entries[0];

                // Detect media type
                const mediaType = detectMediaType(firstEntry);

                if (!mediaType) {
                    showStatus('Not a valid media URL (YouTube, MP4, MP3, etc.)', 'error');
                    return;
                }

                if (mediaType === 'youtube') {
                    // Handle YouTube URL
                    const videoId = extractVideoId(firstEntry);
                    if (!videoId) {
                        showStatus('Could not extract YouTube video ID', 'error');
                        return;
                    }

                    currentVideoId = videoId;
                    switchToPlayer('youtube');

                    // Clear the container and create player div
                    const container = document.getElementById('youtubeContainer');
                    container.innerHTML = '<div id="youtube-player"></div>';

                    // Wait for API to be ready then create player
                    const initPlayer = () => {
                        if (typeof YT !== 'undefined' && YT.Player) {
                            player = new YT.Player('youtube-player', {
                                height: '100%',
                                width: '100%',
                                videoId: videoId,
                                playerVars: {
                                    'enablejsapi': 1,
                                    'rel': 0,
                                    'modestbranding': 1,
                                    'iv_load_policy': 3
                                },
                                events: {
                                    'onReady': onPlayerReady,
                                    'onStateChange': onPlayerStateChange
                                }
                            });
                        } else {
                            setTimeout(initPlayer, 500);
                        }
                    };

                    initPlayer();
                } else {
                    // Handle HTML5 media (video or audio)
                    switchToPlayer(mediaType);
                    loadHTML5Media(firstEntry, mediaType);
                }

                // Check if there are times after the URL
                if (entries.length > 1) {
                    const timeEntries = entries.slice(1); // Get all entries after the URL
                    const timesContainer = document.getElementById('savedTimesButtons');

                    // Clear all existing buttons first
                    timesContainer.innerHTML = '';
                    currentTimeIndex = -1; // Reset cycle index when loading new times

                    let addedCount = 0;
                    const colors = [
                        'linear-gradient(45deg, #4CAF50, #45a049)',
                        'linear-gradient(45deg, #2196F3, #1976D2)',
                        'linear-gradient(45deg, #9C27B0, #7B1FA2)',
                        'linear-gradient(45deg, #FF9800, #F57C00)',
                        'linear-gradient(45deg, #607D8B, #455A64)',
                        'linear-gradient(45deg, #E91E63, #C2185B)',
                        'linear-gradient(45deg, #00BCD4, #0097A7)',
                        'linear-gradient(45deg, #8BC34A, #689F38)',
                        'linear-gradient(45deg, #FF5722, #E64A19)'
                    ];

                    timeEntries.forEach((timeEntry, index) => {
                        const timeStr = timeEntry.trim();

                        // Validate the time string
                        const seconds = parseTimeToSeconds(timeStr);
                        if (seconds !== null) {
                            // Create button element
                            const button = document.createElement('button');
                            button.className = 'saved-time-btn time-btn';
                            button.dataset.time = timeStr;
                            button.textContent = timeStr;
                            button.style.background = colors[addedCount % colors.length];

                            timesContainer.appendChild(button);
                            addedCount++;
                        }
                    });

                    if (addedCount > 0) {
                        // Re-attach listeners to new buttons
                        attachTimeButtonListeners();

                        // Save to IndexedDB
                        saveSavedTimesToIndexedDB();

                        console.log(`üé¨ DEBUG: Added ${addedCount} time buttons`);
                    }
                }

                console.log('üé¨ DEBUG: Loaded media from clipboard:', firstEntry, 'type:', mediaType);
                showStatus(`${mediaType === 'audio' ? 'Audio' : 'Video'} loaded from clipboard!`, 'success');

                // Visual feedback
                const btn = document.getElementById('loadYouTubeClipboardBtn');
                const originalText = btn.textContent;
                btn.textContent = '‚úÖ Loaded!';
                btn.style.transform = 'scale(1.05)';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.transform = '';
                }, 2000);

            } catch (err) {
                console.error('üé¨ DEBUG: Failed to read clipboard:', err);
                showStatus('Failed to read clipboard. Please paste manually or grant permission.', 'error');
            }
        }

        // Helper function to check if URL is YouTube
        function isYouTubeURL(url) {
            const youtubePatterns = [
                /(?:https?:\/\/)?(?:www\.)?youtube\.com\/watch\?v=([a-zA-Z0-9_-]+)/,
                /(?:https?:\/\/)?(?:www\.)?youtube\.com\/embed\/([a-zA-Z0-9_-]+)/,
                /(?:https?:\/\/)?youtu\.be\/([a-zA-Z0-9_-]+)/,
                /(?:https?:\/\/)?(?:www\.)?youtube\.com\/shorts\/([a-zA-Z0-9_-]+)/
            ];

            return youtubePatterns.some(pattern => pattern.test(url));
        }

        // Helper function to check if URL is a Dropbox direct link
        function isDropboxURL(url) {
            return url.includes('dropbox.com') && url.includes('raw=1');
        }

        // Helper function to detect media type from URL
        function detectMediaType(url) {
            // Check for YouTube first
            if (isYouTubeURL(url)) {
                return 'youtube';
            }

            // Check for audio extensions
            const audioExtensions = ['.mp3', '.wav', '.ogg', '.m4a', '.aac', '.flac'];
            const hasAudioExt = audioExtensions.some(ext => url.toLowerCase().includes(ext));
            if (hasAudioExt) {
                return 'audio';
            }

            // Check for video extensions (including dropbox)
            const videoExtensions = ['.mp4', '.webm', '.mov', '.avi', '.mkv', '.m4v'];
            const hasVideoExt = videoExtensions.some(ext => url.toLowerCase().includes(ext));
            if (hasVideoExt || isDropboxURL(url)) {
                return 'video';
            }

            return null; // Unknown type
        }

        // Switch between player types
        function switchToPlayer(type) {
            const youtubeContainer = document.getElementById('youtubeContainer');
            const mediaContainer = document.getElementById('mediaContainer');
            const audioContainer = document.getElementById('audioContainer');

            // Hide all players
            youtubeContainer.style.display = 'none';
            mediaContainer.style.display = 'none';
            audioContainer.style.display = 'none';

            // Show the appropriate player
            if (type === 'youtube') {
                youtubeContainer.style.display = 'block';
                playerType = 'youtube';
            } else if (type === 'video') {
                mediaContainer.style.display = 'block';
                playerType = 'video';
                if (!html5Player) {
                    html5Player = document.getElementById('html5-player');
                }
            } else if (type === 'audio') {
                audioContainer.style.display = 'block';
                playerType = 'audio';
                if (!audioPlayer) {
                    audioPlayer = document.getElementById('audio-player');
                }
            }

            console.log('üé¨ Switched to', type, 'player');
        }

        // Get the current active player
        function getActivePlayer() {
            if (playerType === 'youtube') {
                return player;
            } else if (playerType === 'video') {
                return html5Player;
            } else if (playerType === 'audio') {
                return audioPlayer;
            }
            return null;
        }

        // Load HTML5 media (video or audio)
        function loadHTML5Media(url, type, autoplay = false) {
            const mediaElement = type === 'audio' ? audioPlayer : html5Player;

            if (!mediaElement) {
                console.error('Media element not found');
                return;
            }

            currentMediaUrl = url;
            mediaElement.src = url;

            // Setup time tracking for HTML5 media
            mediaElement.addEventListener('loadedmetadata', () => {
                playerReady = true;
                document.getElementById('currentTimeDisplay').style.display = 'flex';
                console.log('üé¨ Media loaded:', url);
                // Autoplay if requested
                if (autoplay) {
                    mediaElement.play().catch(e => console.log('Autoplay prevented:', e));
                }
            }, { once: true });

            mediaElement.addEventListener('play', () => {
                startTimeUpdates();
            });

            mediaElement.addEventListener('pause', () => {
                stopTimeUpdates();
            });

            mediaElement.addEventListener('ended', () => {
                stopTimeUpdates();
            });

            mediaElement.load();
        }


        // Time tracking functions
        function startTimeUpdates() {
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
            }

            timeUpdateInterval = setInterval(() => {
                try {
                    let currentTime = null;

                    if (playerType === 'youtube' && player && playerReady && typeof player.getCurrentTime === 'function') {
                        currentTime = player.getCurrentTime();
                    } else if ((playerType === 'video' || playerType === 'audio') && playerReady) {
                        const activePlayer = getActivePlayer();
                        if (activePlayer && !isNaN(activePlayer.currentTime)) {
                            currentTime = activePlayer.currentTime;
                        }
                    }

                    if (currentTime !== null) {
                        updateTimeDisplay(currentTime);
                    }
                } catch (error) {
                    console.log('üé¨ DEBUG: Error getting current time:', error);
                }
            }, 1000);
        }

        function stopTimeUpdates() {
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
                timeUpdateInterval = null;
            }
        }

        function updateTimeDisplay(currentTimeSeconds) {
            const timeValue = document.getElementById('currentTimeValue');
            const loopStartTimeInput = document.getElementById('loopStartTime');

            if (currentTimeSeconds !== undefined && currentTimeSeconds !== null) {
                const hours = Math.floor(currentTimeSeconds / 3600);
                const minutes = Math.floor((currentTimeSeconds % 3600) / 60);
                const seconds = Math.floor(currentTimeSeconds % 60);

                let timeStr;
                if (hours > 0) {
                    timeStr = `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                } else {
                    timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }

                timeValue.textContent = timeStr;

                // Detect user seeking (time jump greater than threshold)
                const timeDifference = Math.abs(currentTimeSeconds - lastKnownTime);
                if (timeDifference > seekDetectionThreshold && lastKnownTime > 0) {
                    // User manually seeked - update loop start time
                    if (loopStartTimeInput) {
                        loopStartTimeInput.value = timeStr;
                    }

                    // If a timer is running, update and RESTART the timer
                    if (timerTimeout && timerLoopsRemaining > 0) {
                        timerStartTime = currentTimeSeconds;
                        console.log('‚è±Ô∏è Timer restarted from:', timeStr);

                        // Clear the current timer and restart fresh
                        clearTimeout(timerTimeout);
                        startTimerLoop();
                    }
                }

                lastKnownTime = currentTimeSeconds;
            } else {
                timeValue.textContent = '--:--';
            }
        }

        // IndexedDB functions for saved times
        async function saveSavedTimesToIndexedDB() {
            const savedTimeButtons = document.querySelectorAll('.saved-time-btn');
            const times = Array.from(savedTimeButtons).map(btn => btn.dataset.time);

            try {
                await indexedDBWrapper.set(DB_NAME, SAVED_TIMES_KEY, times);
                console.log('üíæ Saved times to IndexedDB:', times);
            } catch (error) {
                console.error('üíæ Error saving times to IndexedDB:', error);
            }
        }

        async function loadSavedTimesFromIndexedDB() {
            try {
                const snapshot = await indexedDBWrapper.get(DB_NAME, SAVED_TIMES_KEY);

                if (!snapshot.exists()) {
                    console.log('üíæ No saved times found in IndexedDB');
                    return null;
                }

                const times = snapshot.val();
                console.log('üíæ Loaded times from IndexedDB:', times);
                return times;
            } catch (error) {
                console.error('üíæ Error loading saved times from IndexedDB:', error);
                return null;
            }
        }

        function renderSavedTimes(times) {
            if (!times || times.length === 0) return;

            const container = document.getElementById('savedTimesButtons');
            container.innerHTML = ''; // Clear existing buttons

            const colors = [
                'linear-gradient(45deg, #4CAF50, #45a049)',
                'linear-gradient(45deg, #2196F3, #1976D2)',
                'linear-gradient(45deg, #9C27B0, #7B1FA2)',
                'linear-gradient(45deg, #FF9800, #F57C00)',
                'linear-gradient(45deg, #607D8B, #455A64)',
                'linear-gradient(45deg, #E91E63, #C2185B)',
                'linear-gradient(45deg, #00BCD4, #0097A7)',
                'linear-gradient(45deg, #8BC34A, #689F38)',
                'linear-gradient(45deg, #FF5722, #E64A19)'
            ];

            times.forEach((timeStr, index) => {
                const button = document.createElement('button');
                button.className = 'saved-time-btn time-btn';
                button.dataset.time = timeStr;
                button.textContent = timeStr;
                button.style.background = colors[index % colors.length];
                container.appendChild(button);
            });

            // Re-attach listeners to new buttons
            attachTimeButtonListeners();

            console.log('‚úÖ Rendered', times.length, 'saved time buttons');
        }

        // Clean transcript: Keep the first timestamp in each minute (starting from minute 1)
        // e.g., skip 0:xx, keep first in 1:xx, first in 2:xx, first in 3:xx, etc.
        function cleanTranscript(text) {
            if (!text || !text.trim()) {
                return '';
            }

            const lines = text.split('\n');
            const result = [];
            let currentText = [];
            let lastKeptMinute = 0; // Start at 0, so we skip minute 0 and start keeping from minute 1

            for (let line of lines) {
                line = line.trim();

                // Skip empty lines
                if (!line) {
                    continue;
                }

                // Check if line is a timestamp (M:SS or H:MM:SS)
                const timeMatch = line.match(/^(\d+):(\d+)(?::(\d+))?$/);

                if (timeMatch) {
                    const hours = timeMatch[3] ? parseInt(timeMatch[1]) : 0;
                    const minutes = timeMatch[3] ? parseInt(timeMatch[2]) : parseInt(timeMatch[1]);
                    const totalMinutes = (hours * 60) + minutes;

                    // Keep this timestamp if it's the first one in a new minute (after minute 0)
                    if (totalMinutes > lastKeptMinute) {
                        // Save previous text block
                        if (currentText.length > 0) {
                            result.push(currentText.join(' '));
                            currentText = [];
                        }

                        // Add the timestamp
                        result.push(line);
                        lastKeptMinute = totalMinutes;
                    }
                    // Otherwise, skip this timestamp (already have one for this minute or it's minute 0)
                } else {
                    // This is text content
                    currentText.push(line);
                }
            }

            // Add any remaining text
            if (currentText.length > 0) {
                result.push(currentText.join(' '));
            }

            return result.join('\n');
        }

        // Loop Timer Functions
        function getLoopInterval() {
            const loopIntervalInput = document.getElementById('loopIntervalInput');
            if (!loopIntervalInput) return 13; // Default if element doesn't exist
            const inputValue = loopIntervalInput.value.trim();
            if (inputValue === '' || isNaN(inputValue) || parseInt(inputValue) < 1) {
                return 13; // Default to 13 seconds
            }
            return parseInt(inputValue) + 1; // Add 1 second for reload delay
        }

        function toggleLoopTimer(intervalSeconds, buttonElement, durationMinutes = 5) {
            if (loopTimerActive) {
                // Timer is running - stop it first, then start new one
                stopLoopTimer();
            }
            startLoopTimer(intervalSeconds, buttonElement, durationMinutes);
        }

        function startLoopTimer(intervalSeconds, buttonElement, durationMinutes = 5) {
            // Get the loop start time from the input
            const loopStartTimeInput = document.getElementById('loopStartTime');
            const timeStr = loopStartTimeInput.value.trim();

            if (!timeStr) {
                showStatus('Please enter a loop start time', 'error');
                return;
            }

            // Parse the time string
            const baseSeconds = parseTimeToSeconds(timeStr);
            if (baseSeconds === null) {
                showStatus('Invalid time format. Use MM:SS or H:MM:SS', 'error');
                return;
            }

            if (!currentVideoId && !currentMediaUrl) {
                showStatus('Please load a video first', 'error');
                return;
            }

            loopBaseTime = baseSeconds;
            loopIntervalSeconds = intervalSeconds;
            currentLoopButton = buttonElement;

            // Start the timer (5 or 25 minutes)
            loopTimerActive = true;
            loopTimerEndTime = Date.now() + (durationMinutes * 60 * 1000);
            loopNextResetTime = Date.now() + (intervalSeconds * 1000);

            // Update UI - show which timer is running
            buttonElement.textContent = `üîÑ ${durationMinutes} min`;
            buttonElement.style.background = 'linear-gradient(45deg, #FF9800, #F57C00)';

            const statusDiv = document.getElementById('loopTimerStatus');
            if (statusDiv) statusDiv.style.display = 'block';

            // Set up display update interval
            loopTimerInterval = setInterval(updateLoopTimerDisplay, 1000);

            // Schedule first loop reset with fade (fire early to allow fade time)
            const fadeAdjustedDelay = Math.max(1000, (intervalSeconds * 1000) - FADE_OUT_DURATION_MS);
            loopResetInterval = setTimeout(resetToLoopTimeWithFade, fadeAdjustedDelay);

            // Jump to the base time immediately
            jumpToYouTubeTime(loopBaseTime);

            const playTime = intervalSeconds - 1;
            console.log(`üîÑ Loop timer started - will return to ${loopBaseTime}s (${timeStr}) every ${intervalSeconds} seconds (${playTime}s play + 1s reload) for ${durationMinutes} minutes`);
            showStatus(`Loop to ${timeStr} every ${playTime}s for ${durationMinutes} min`, 'success');
        }

        function stopLoopTimer() {
            loopTimerActive = false;

            // Clear intervals/timeouts
            if (loopTimerInterval) {
                clearInterval(loopTimerInterval);
                loopTimerInterval = null;
            }
            if (loopResetInterval) {
                clearTimeout(loopResetInterval);  // Changed to clearTimeout
                loopResetInterval = null;
            }

            // Cancel any ongoing fades and restore volume
            cancelFades();

            // Update UI - Reset all buttons
            const loop5minBtn = document.getElementById('loopTimer5minBtn');
            const loop25minBtn = document.getElementById('loopTimer25minBtn');

            if (loop5minBtn) {
                loop5minBtn.textContent = '‚ñ∂Ô∏è 5 min';
                loop5minBtn.style.background = 'linear-gradient(45deg, #4CAF50, #45a049)';
            }

            if (loop25minBtn) {
                loop25minBtn.textContent = '‚ñ∂Ô∏è 25 min';
                loop25minBtn.style.background = 'linear-gradient(45deg, #9C27B0, #7B1FA2)';
            }

            const statusDiv = document.getElementById('loopTimerStatus');
            if (statusDiv) statusDiv.style.display = 'none';

            // Reset variables
            loopTimerEndTime = null;
            loopBaseTime = null;
            loopNextResetTime = null;
            loopIntervalSeconds = 13;
            currentLoopButton = null;

            // Reset page title
            document.title = originalPageTitle;

            console.log('üîÑ Loop timer stopped');
            showStatus('Loop timer stopped', 'info');
        }

        // Shared timer state
        let timerTimeout = null;
        let timerLoopsRemaining = 0;
        let timerStartTime = 0;
        let timerButtonRef = null;
        let timerDurationMs = 0;
        let timerTotalLoops = 0;
        let timerLabel = '';
        let timerDefaultBg = '';

        // Fade state variables
        const FADE_OUT_DURATION_MS = 1500;  // 1.5 second fade out
        const FADE_IN_DURATION_MS = 500;    // 0.5 second fade in
        let fadeOutInterval = null;
        let fadeInInterval = null;
        let fadeOutInProgress = false;
        let fadeInInProgress = false;
        let originalVolume = 100;  // YouTube uses 0-100

        // Get current volume from active player
        function getCurrentVolume() {
            if (player && typeof player.getVolume === 'function') {
                return player.getVolume();  // YouTube: 0-100
            } else if (html5Player) {
                return html5Player.volume * 100;  // HTML5: 0-1 -> 0-100
            } else if (audioPlayer) {
                return audioPlayer.volume * 100;
            }
            return 100;
        }

        // Set volume on active player
        function setPlayerVolume(vol) {
            if (player && typeof player.setVolume === 'function') {
                player.setVolume(vol);  // YouTube: 0-100
            } else if (html5Player) {
                html5Player.volume = vol / 100;  // HTML5: 0-1
            } else if (audioPlayer) {
                audioPlayer.volume = vol / 100;
            }
        }

        // Fade out function - returns a Promise that resolves when fade is complete
        function fadeOut(durationMs = FADE_OUT_DURATION_MS) {
            return new Promise((resolve) => {
                if (fadeOutInProgress) {
                    resolve();
                    return;
                }

                // Cancel any ongoing fade in
                if (fadeInInterval) {
                    clearInterval(fadeInInterval);
                    fadeInInterval = null;
                    fadeInInProgress = false;
                }

                fadeOutInProgress = true;
                const startVolume = getCurrentVolume();
                originalVolume = startVolume;  // Remember for fade in
                const steps = 20;
                const stepDuration = durationMs / steps;
                const volumeStep = startVolume / steps;
                let currentStep = 0;

                console.log(`üîâ Fade out started: ${startVolume} -> 0 over ${durationMs}ms`);

                fadeOutInterval = setInterval(() => {
                    currentStep++;
                    const newVolume = Math.max(0, startVolume - (volumeStep * currentStep));
                    setPlayerVolume(newVolume);

                    if (currentStep >= steps || newVolume <= 0) {
                        clearInterval(fadeOutInterval);
                        fadeOutInterval = null;
                        fadeOutInProgress = false;
                        setPlayerVolume(0);
                        console.log(`üîá Fade out complete`);
                        resolve();
                    }
                }, stepDuration);
            });
        }

        // Fade in function
        function fadeIn(durationMs = FADE_IN_DURATION_MS) {
            if (fadeInInProgress) return;

            // Cancel any ongoing fade out
            if (fadeOutInterval) {
                clearInterval(fadeOutInterval);
                fadeOutInterval = null;
                fadeOutInProgress = false;
            }

            fadeInInProgress = true;
            setPlayerVolume(0);  // Start silent
            const targetVolume = originalVolume || 100;
            const steps = 20;
            const stepDuration = durationMs / steps;
            const volumeStep = targetVolume / steps;
            let currentStep = 0;

            console.log(`üîä Fade in started: 0 -> ${targetVolume} over ${durationMs}ms`);

            fadeInInterval = setInterval(() => {
                currentStep++;
                const newVolume = Math.min(targetVolume, volumeStep * currentStep);
                setPlayerVolume(newVolume);

                if (currentStep >= steps || newVolume >= targetVolume) {
                    clearInterval(fadeInInterval);
                    fadeInInterval = null;
                    fadeInInProgress = false;
                    setPlayerVolume(targetVolume);
                    console.log(`üîä Fade in complete`);
                }
            }, stepDuration);
        }

        // Cancel any ongoing fades and restore volume
        function cancelFades() {
            if (fadeOutInterval) {
                clearInterval(fadeOutInterval);
                fadeOutInterval = null;
            }
            if (fadeInInterval) {
                clearInterval(fadeInInterval);
                fadeInInterval = null;
            }
            fadeOutInProgress = false;
            fadeInInProgress = false;
            setPlayerVolume(originalVolume || 100);
        }

        function getRepeatCount() {
            const radio = document.querySelector('input[name="timerRepeat"]:checked');
            return radio ? parseInt(radio.value) : 1;
        }

        function resetTimerButton() {
            if (timerButtonRef) {
                // Check if it's the custom select dropdown
                if (timerButtonRef.tagName === 'SELECT') {
                    timerButtonRef.value = '';
                    timerButtonRef.style.background = 'linear-gradient(45deg, #E1BEE7, #CE93D8)';
                } else {
                    timerButtonRef.textContent = timerLabel;
                    timerButtonRef.style.background = timerDefaultBg;
                }
            }
        }

        function startTimerLoop() {
            const currentLoop = timerTotalLoops - timerLoopsRemaining + 1;

            // Update button/select to show progress
            if (timerButtonRef.tagName === 'SELECT') {
                // For select, just change background to indicate running
                timerButtonRef.style.background = 'linear-gradient(45deg, #FF5722, #E64A19)';
            } else if (timerTotalLoops > 1) {
                timerButtonRef.textContent = `‚èπÔ∏è ${currentLoop}/${timerTotalLoops}`;
                timerButtonRef.style.background = 'linear-gradient(45deg, #FF5722, #E64A19)';
            } else {
                timerButtonRef.textContent = '‚èπÔ∏è Stop';
                timerButtonRef.style.background = 'linear-gradient(45deg, #FF5722, #E64A19)';
            }

            if (timerTotalLoops > 1) {
                showStatus(`Playing ${timerLabel.replace('‚è±Ô∏è ', '')} loop ${currentLoop} of ${timerTotalLoops}...`, 'info', true);
            } else {
                showStatus(`Playing for ${timerLabel.replace('‚è±Ô∏è ', '')}...`, 'info', true);
            }

            // Focus the loopStartTime input so user can type a new time while watching
            const loopInput = document.getElementById('loopStartTime');
            loopInput.focus();
            loopInput.select();

            // Calculate when to start fade out (before the loop ends)
            const fadeStartDelay = Math.max(0, timerDurationMs - FADE_OUT_DURATION_MS);

            // Set timeout to start fade out before the loop ends
            timerTimeout = setTimeout(function() {
                // Start fade out, then handle loop completion
                fadeOut().then(() => {
                    timerLoopsRemaining--;

                    // Rewind to start
                    const rewindTime = Math.max(0, timerStartTime);
                    jumpToYouTubeTime(rewindTime);

                    if (timerLoopsRemaining > 0) {
                        // More loops - restore volume and restart
                        fadeIn();
                        showStatus(`Loop ${timerTotalLoops - timerLoopsRemaining} complete. Starting next...`, 'info', true);
                        startTimerLoop();
                    } else {
                        // All done - pause (volume already at 0 from fade out)
                        if (player && typeof player.pauseVideo === 'function') {
                            player.pauseVideo();
                        } else if (html5Player) {
                            html5Player.pause();
                        } else if (audioPlayer) {
                            audioPlayer.pause();
                        }

                        // Restore volume for next play
                        setPlayerVolume(originalVolume || 100);

                        resetTimerButton();
                        timerTimeout = null;

                        if (timerTotalLoops > 1) {
                            showStatus(`All ${timerTotalLoops} loops complete! Rewound to ${formatSecondsToTime(rewindTime)}`, 'success');
                        } else {
                            showStatus('Paused and rewound to ' + formatSecondsToTime(rewindTime), 'success');
                        }
                    }
                });
            }, fadeStartDelay);
        }

        // 30-second play then rewind function
        function play30sThenRewind(buttonElement) {
            // If this timer is already running, cancel it
            if (timerTimeout && timerButtonRef === buttonElement) {
                clearTimeout(timerTimeout);
                timerTimeout = null;
                timerLoopsRemaining = 0;
                buttonElement.textContent = '‚è±Ô∏è 30s';
                buttonElement.style.background = 'linear-gradient(45deg, #00BCD4, #0097A7)';
                showStatus('30s timer cancelled', 'info');
                return;
            }

            // If other timer is running, cancel it first
            if (timerTimeout) {
                clearTimeout(timerTimeout);
                resetTimerButton();
            }

            // Setup timer
            timerLabel = '‚è±Ô∏è 30s';
            timerDefaultBg = 'linear-gradient(45deg, #00BCD4, #0097A7)';
            timerDurationMs = 30000;
            timerTotalLoops = getRepeatCount();
            timerLoopsRemaining = timerTotalLoops;
            timerButtonRef = buttonElement;

            // Get start time from loopStartTime input
            const loopStartTimeInput = document.getElementById('loopStartTime');
            const timeStr = loopStartTimeInput.value.trim();
            timerStartTime = parseTimeToSeconds(timeStr);
            if (timerStartTime === null) {
                timerStartTime = 0;
            }

            // Jump to the start time immediately
            jumpToYouTubeTime(timerStartTime);

            startTimerLoop();
        }

        // 1-minute play then rewind function
        function play60sThenRewind(buttonElement) {
            // If this timer is already running, cancel it
            if (timerTimeout && timerButtonRef === buttonElement) {
                clearTimeout(timerTimeout);
                timerTimeout = null;
                timerLoopsRemaining = 0;
                buttonElement.textContent = '‚è±Ô∏è 1m';
                buttonElement.style.background = 'linear-gradient(45deg, #8BC34A, #689F38)';
                showStatus('1min timer cancelled', 'info');
                return;
            }

            // If other timer is running, cancel it first
            if (timerTimeout) {
                clearTimeout(timerTimeout);
                resetTimerButton();
            }

            // Setup timer
            timerLabel = '‚è±Ô∏è 1m';
            timerDefaultBg = 'linear-gradient(45deg, #8BC34A, #689F38)';
            timerDurationMs = 60000;
            timerTotalLoops = getRepeatCount();
            timerLoopsRemaining = timerTotalLoops;
            timerButtonRef = buttonElement;

            // Get start time from loopStartTime input
            const loopStartTimeInput = document.getElementById('loopStartTime');
            const timeStr = loopStartTimeInput.value.trim();
            timerStartTime = parseTimeToSeconds(timeStr);
            if (timerStartTime === null) {
                timerStartTime = 0;
            }

            // Jump to the start time immediately
            jumpToYouTubeTime(timerStartTime);

            startTimerLoop();
        }

        // 3-minute play then rewind function
        function play3minThenRewind(buttonElement) {
            // If this timer is already running, cancel it
            if (timerTimeout && timerButtonRef === buttonElement) {
                clearTimeout(timerTimeout);
                timerTimeout = null;
                timerLoopsRemaining = 0;
                buttonElement.textContent = '‚è±Ô∏è 3m';
                buttonElement.style.background = 'linear-gradient(45deg, #FF9800, #F57C00)';
                showStatus('3min timer cancelled', 'info');
                return;
            }

            // If other timer is running, cancel it first
            if (timerTimeout) {
                clearTimeout(timerTimeout);
                resetTimerButton();
            }

            // Setup timer
            timerLabel = '‚è±Ô∏è 3m';
            timerDefaultBg = 'linear-gradient(45deg, #FF9800, #F57C00)';
            timerDurationMs = 180000;
            timerTotalLoops = getRepeatCount();
            timerLoopsRemaining = timerTotalLoops;
            timerButtonRef = buttonElement;

            // Get start time from loopStartTime input
            const loopStartTimeInput = document.getElementById('loopStartTime');
            const timeStr = loopStartTimeInput.value.trim();
            timerStartTime = parseTimeToSeconds(timeStr);
            if (timerStartTime === null) {
                timerStartTime = 0;
            }

            // Jump to the start time immediately
            jumpToYouTubeTime(timerStartTime);

            startTimerLoop();
        }

        // Custom duration play then rewind function
        function playCustomThenRewind(selectElement, seconds) {
            const customLabel = `‚è±Ô∏è ${seconds}s`;
            const customBg = 'linear-gradient(45deg, #9C27B0, #7B1FA2)';

            // If timer is already running, cancel it
            if (timerTimeout && timerButtonRef === selectElement) {
                clearTimeout(timerTimeout);
                timerTimeout = null;
                timerLoopsRemaining = 0;
                selectElement.value = '';
                selectElement.style.background = 'linear-gradient(45deg, #E1BEE7, #CE93D8)';
                showStatus(`${seconds}s timer cancelled`, 'info');
                return;
            }

            // If other timer is running, cancel it first
            if (timerTimeout) {
                clearTimeout(timerTimeout);
                resetTimerButton();
            }

            // Setup timer
            timerLabel = customLabel;
            timerDefaultBg = customBg;
            timerDurationMs = seconds * 1000;
            timerTotalLoops = getRepeatCount();
            timerLoopsRemaining = timerTotalLoops;
            timerButtonRef = selectElement;

            // Get start time from loopStartTime input
            const loopStartTimeInput = document.getElementById('loopStartTime');
            const timeStr = loopStartTimeInput.value.trim();
            timerStartTime = parseTimeToSeconds(timeStr);
            if (timerStartTime === null) {
                timerStartTime = 0;
            }

            // Jump to the start time immediately
            jumpToYouTubeTime(timerStartTime);

            startTimerLoop();
        }

        // New version with fade out/in for smooth loop transitions
        function resetToLoopTimeWithFade() {
            if (!loopTimerActive || loopBaseTime === null) {
                return;
            }

            // Check if the main timer is still running
            if (Date.now() >= loopTimerEndTime) {
                // Timer is ending - fade out, then stop
                fadeOut().then(() => {
                    showStatus('Loop timer completed!', 'success');
                    // Play beep sound when timer completes
                    beepSound.play().catch(err => console.log('Beep sound failed:', err));
                    stopLoopTimer();
                });
                return;
            }

            // Fade out, then jump and fade in
            fadeOut().then(() => {
                // Jump back to the loop time
                jumpToYouTubeTime(loopBaseTime);

                // Fade back in
                fadeIn();

                // Set next reset time for display purposes
                loopNextResetTime = Date.now() + (loopIntervalSeconds * 1000);

                // Schedule next reset with fade
                const fadeAdjustedDelay = Math.max(1000, (loopIntervalSeconds * 1000) - FADE_OUT_DURATION_MS);
                loopResetInterval = setTimeout(resetToLoopTimeWithFade, fadeAdjustedDelay);

                console.log(`üîÑ Reset to loop time ${loopBaseTime}s with fade`);
            });
        }

        // Original version without fade (kept for compatibility)
        function resetToLoopTime() {
            if (!loopTimerActive || loopBaseTime === null) {
                return;
            }

            // Check if the main timer is still running
            if (Date.now() >= loopTimerEndTime) {
                showStatus('Loop timer completed!', 'success');
                // Play beep sound when timer completes
                beepSound.play().catch(err => console.log('Beep sound failed:', err));
                stopLoopTimer();
                return;
            }

            // Jump back to the loop time
            jumpToYouTubeTime(loopBaseTime);

            // Set next reset time
            loopNextResetTime = Date.now() + (loopIntervalSeconds * 1000);

            console.log(`üîÑ Reset to loop time ${loopBaseTime}s`);
        }

        function updateLoopTimerDisplay() {
            if (!loopTimerActive) return;

            const statusDiv = document.getElementById('loopTimerStatus');
            const remainingTime = loopTimerEndTime - Date.now();
            const nextResetTime = loopNextResetTime - Date.now();

            if (remainingTime <= 0) {
                document.title = `‚úÖ Timer Complete! | ${originalPageTitle}`;
                setTimeout(() => {
                    document.title = originalPageTitle;
                }, 3000);

                // Play beep sound when timer completes
                beepSound.play().catch(err => console.log('Beep sound failed:', err));
                stopLoopTimer();
                showStatus('Loop timer completed!', 'success');
                return;
            }

            const minutes = Math.floor(remainingTime / 60000);
            const seconds = Math.floor((remainingTime % 60000) / 1000);
            const nextResetSeconds = Math.max(0, Math.floor(nextResetTime / 1000));

            const timeRemaining = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

            // Update status display
            if (statusDiv) statusDiv.textContent = `Loop Timer: ${timeRemaining} remaining | Next reset in: ${nextResetSeconds}s`;

            // Update page title
            document.title = `üîÑ ${timeRemaining} left | Next: ${nextResetSeconds}s | ${originalPageTitle}`;
        }

        // ========== Memorize - Line Reader with TTS Functions ==========

        // Memorize State
        let memorizeLines = [];
        let memorizeLastStart = null;
        let memorizeLastEnd = null;
        let memorizeIsSpeaking = false;
        let memorizeUtterance = null;

        // Initialize TTS for Memorize
        if ('speechSynthesis' in window) {
            speechSynthesis.addEventListener('voiceschanged', () => {
                speechSynthesis.getVoices();
            });
        }

        // Memorize TTS Toggle
        const memorizeTtsToggle = document.getElementById('memorize-ttsToggle');
        const memorizeTtsLabel = document.getElementById('memorize-ttsLabel');

        if (memorizeTtsToggle) {
            memorizeTtsToggle.addEventListener('change', function() {
                if (this.checked) {
                    memorizeTtsLabel.textContent = 'TTS ON';
                } else {
                    memorizeTtsLabel.textContent = 'TTS OFF';
                    memorizeStopSpeaking();
                }
            });
        }

        // Memorize Paste from clipboard
        async function memorizePasteFromClipboard() {
            try {
                const text = await navigator.clipboard.readText();
                if (!text.trim()) {
                    memorizeShowStatus('Clipboard is empty');
                    return;
                }

                memorizeLines = text.split('\n');
                document.getElementById('memorize-totalLines').textContent = memorizeLines.length;

                memorizeRenderContent(null, null, true);
                document.getElementById('memorize-toggleDisplayBtn').textContent = 'Hide Content';
                memorizeShowStatus(`Loaded ${memorizeLines.length} lines from clipboard`);
            } catch (err) {
                memorizeShowStatus('Failed to read clipboard. Please allow clipboard access.');
                console.error('Memorize clipboard error:', err);
            }
        }

        // Memorize Render content with line numbers
        function memorizeRenderContent(highlightStart = null, highlightEnd = null, forceShow = false) {
            const display = document.getElementById('memorize-contentDisplay');
            const wasHidden = display.classList.contains('memorize-hidden');

            if (memorizeLines.length === 0) {
                display.classList.add('memorize-hidden');
                return;
            }

            let html = '';
            memorizeLines.forEach((line, index) => {
                const lineNum = index + 1;
                const isHighlighted = highlightStart !== null &&
                    lineNum >= highlightStart && lineNum <= highlightEnd;

                html += `<div class="memorize-line ${isHighlighted ? 'highlighted' : ''}">
                    <span class="memorize-line-num">${lineNum}</span>
                    <span class="memorize-line-text">${memorizeEscapeHtml(line)}</span>
                </div>`;
            });

            display.innerHTML = html;

            if (forceShow || !wasHidden) {
                display.classList.remove('memorize-hidden');
            }
        }

        // Memorize Show all lines
        function memorizeShowAllLines() {
            const display = document.getElementById('memorize-contentDisplay');
            display.classList.toggle('full');
            display.classList.remove('memorize-hidden');
            document.getElementById('memorize-toggleDisplayBtn').textContent = 'Hide Content';
            memorizeRenderContent(null, null, true);
        }

        // Memorize Toggle content display visibility
        function memorizeToggleContentDisplay() {
            const display = document.getElementById('memorize-contentDisplay');
            const btn = document.getElementById('memorize-toggleDisplayBtn');

            if (display.classList.contains('memorize-hidden')) {
                display.classList.remove('memorize-hidden');
                btn.textContent = 'Hide Content';
            } else {
                display.classList.add('memorize-hidden');
                btn.textContent = 'Show Content';
            }
        }

        // Memorize Clear content
        function memorizeClearContent() {
            memorizeLines = [];
            memorizeLastStart = null;
            memorizeLastEnd = null;
            document.getElementById('memorize-totalLines').textContent = '0';
            document.getElementById('memorize-contentDisplay').classList.add('memorize-hidden');
            document.getElementById('memorize-selectedText').classList.add('memorize-hidden');
            document.getElementById('memorize-rangeInput').value = '';
            memorizeStopSpeaking();
            memorizeShowStatus('Cleared');
        }

        // Memorize Read range
        function memorizeReadRange() {
            const input = document.getElementById('memorize-rangeInput').value.trim();

            if (!input) {
                memorizeShowStatus('Enter a range (e.g., 1-4 or 5)');
                return;
            }

            // Handle special commands
            if (input.toLowerCase() === 'r') {
                memorizeRepeatLast();
                return;
            }
            if (input.toLowerCase() === 'catn') {
                memorizeShowAllLines();
                return;
            }
            if (input.toLowerCase() === 'clr' || input.toLowerCase() === 'clear') {
                memorizeClearContent();
                return;
            }

            // Parse range
            let start, end;
            if (input.includes('-')) {
                const parts = input.split('-');
                start = parseInt(parts[0]);
                end = parseInt(parts[1]);
            } else {
                start = parseInt(input);
                end = start;
            }

            // Validate
            if (isNaN(start) || isNaN(end)) {
                memorizeShowStatus('Invalid format. Use: 3-4 or 5');
                return;
            }

            if (start < 1 || end > memorizeLines.length || start > end) {
                memorizeShowStatus(`Invalid range. Lines available: 1-${memorizeLines.length}`);
                return;
            }

            // Save for repeat
            memorizeLastStart = start;
            memorizeLastEnd = end;

            // Display and speak
            memorizeDisplaySelectedLines(start, end);
        }

        // Memorize Repeat last range
        function memorizeRepeatLast() {
            if (memorizeLastStart === null) {
                memorizeShowStatus('No previous range to repeat');
                return;
            }
            memorizeDisplaySelectedLines(memorizeLastStart, memorizeLastEnd);
        }

        // Memorize Display selected lines
        function memorizeDisplaySelectedLines(start, end) {
            const selectedText = document.getElementById('memorize-selectedText');
            const selectedLines = memorizeLines.slice(start - 1, end);

            let html = '';
            selectedLines.forEach((line, index) => {
                const lineNum = start + index;
                html += `<div class="memorize-line">
                    <span class="memorize-line-num">${lineNum}</span>
                    <span class="memorize-line-text">${memorizeEscapeHtml(line)}</span>
                </div>`;
            });

            selectedText.innerHTML = html;
            selectedText.classList.remove('memorize-hidden');

            // Highlight in main display
            memorizeRenderContent(start, end);

            // Speak if TTS is on
            if (memorizeTtsToggle && memorizeTtsToggle.checked) {
                memorizeSpeakText(selectedLines.join('\n'));
            }

            memorizeShowStatus(`Reading lines ${start}-${end}`);
        }

        // Memorize Text-to-Speech
        function memorizeSpeakText(text) {
            if (!('speechSynthesis' in window)) {
                memorizeShowStatus('Text-to-Speech not supported in this browser');
                return;
            }

            // Stop any current speech
            memorizeStopSpeaking();

            memorizeUtterance = new SpeechSynthesisUtterance(text);
            memorizeUtterance.rate = parseFloat(document.getElementById('memorize-speedSelect').value);
            memorizeUtterance.pitch = 1;
            memorizeUtterance.volume = 1;
            memorizeUtterance.lang = 'en-US';

            // Try to get a good voice
            const voices = speechSynthesis.getVoices();
            if (voices.length > 0) {
                const englishVoice = voices.find(voice =>
                    (voice.lang.includes('en-') && voice.name.includes('Enhanced')) ||
                    (voice.lang.includes('en-') && voice.name.includes('Premium')) ||
                    voice.lang.includes('en-')
                );
                if (englishVoice) {
                    memorizeUtterance.voice = englishVoice;
                }
            }

            memorizeUtterance.onstart = () => {
                memorizeIsSpeaking = true;
            };

            memorizeUtterance.onend = () => {
                memorizeIsSpeaking = false;
                memorizeShowStatus('Finished reading');
            };

            memorizeUtterance.onerror = (event) => {
                memorizeIsSpeaking = false;
                if (event.error !== 'interrupted') {
                    memorizeShowStatus('Speech error: ' + event.error);
                }
            };

            // Small delay to ensure clean start
            setTimeout(() => {
                speechSynthesis.speak(memorizeUtterance);
            }, 100);
        }

        // Memorize Stop speaking
        function memorizeStopSpeaking() {
            if ('speechSynthesis' in window) {
                speechSynthesis.cancel();
            }
            memorizeIsSpeaking = false;
        }

        // Memorize Show status message
        function memorizeShowStatus(message) {
            const status = document.getElementById('memorize-status');
            status.textContent = message;
            status.classList.remove('memorize-hidden');

            setTimeout(() => {
                status.classList.add('memorize-hidden');
            }, 3000);
        }

        // Memorize Escape HTML
        function memorizeEscapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Memorize Keyboard shortcuts
        const memorizeRangeInput = document.getElementById('memorize-rangeInput');
        if (memorizeRangeInput) {
            memorizeRangeInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    memorizeReadRange();
                }
            });
        }

        // ========== Link Extractor & Bilingual Display Functions ==========

        let extractedLink = null;
        let isSwapped = false;
        let parsedLines = [];

        async function pasteToExtractor() {
            try {
                const text = await navigator.clipboard.readText();
                document.getElementById('linkExtractorTextarea').value = text;
                showStatus('Pasted from clipboard', 'success');
            } catch (err) {
                console.error('Failed to read clipboard:', err);
                showStatus('Failed to paste from clipboard', 'error');
            }
        }

        function extractLinkFromTextarea() {
            const content = document.getElementById('linkExtractorTextarea').value.trim();
            const displayDiv = document.getElementById('extractedLinkDisplay');
            const anchor = document.getElementById('extractedLinkAnchor');

            if (!content) {
                extractedLink = null;
                displayDiv.style.display = 'none';
                showStatus('No content in textarea', 'error');
                return null;
            }

            // Find first URL using regex
            const urlRegex = /(https?:\/\/[^\s]+)/;
            const match = content.match(urlRegex);

            if (!match) {
                extractedLink = null;
                displayDiv.style.display = 'none';
                showStatus('No link found in textarea', 'error');
                return null;
            }

            // Extract and clean the URL (remove trailing punctuation)
            extractedLink = match[0].replace(/[.,;!?]+$/, '');

            // Display the extracted link
            anchor.href = extractedLink;
            anchor.textContent = extractedLink;
            displayDiv.style.display = 'block';

            console.log('extractedLink:', extractedLink);
            showStatus('Link extracted: ' + extractedLink, 'success');
            return extractedLink;
        }

        function loadExtractedLink() {
            // Extract link if not already extracted
            if (!extractedLink) {
                extractLinkFromTextarea();
            }

            if (!extractedLink) {
                showStatus('No link to load. Extract a link first.', 'error');
                return;
            }

            // Extract video ID from the URL
            const videoId = extractVideoId(extractedLink);

            if (!videoId) {
                showStatus('Invalid YouTube URL', 'error');
                return;
            }

            // Load the video
            currentVideoId = videoId;
            switchToPlayer('youtube');

            // Clear the container and create player div
            const container = document.getElementById('youtubeContainer');
            container.innerHTML = '<div id="youtube-player"></div>';

            // Wait for API to be ready then create player
            const initPlayer = () => {
                if (typeof YT !== 'undefined' && YT.Player) {
                    player = new YT.Player('youtube-player', {
                        height: '100%',
                        width: '100%',
                        videoId: videoId,
                        playerVars: {
                            'enablejsapi': 1,
                            'rel': 0,
                            'modestbranding': 1,
                            'iv_load_policy': 3
                        },
                        events: {
                            'onReady': onPlayerReady,
                            'onStateChange': onPlayerStateChange
                        }
                    });
                } else {
                    setTimeout(initPlayer, 500);
                }
            };

            initPlayer();
            showStatus('Loaded extracted video', 'success');
        }

        function processAndDisplayBilingual() {
            const content = document.getElementById('linkExtractorTextarea').value.trim();
            const displaySection = document.getElementById('bilingualDisplaySection');
            const bilingualContent = document.getElementById('bilingualContent');

            if (!content) {
                displaySection.style.display = 'none';
                showStatus('No content to display', 'error');
                return;
            }

            const lines = content.split('\n');
            parsedLines = [];
            let html = '';
            let rowNum = 0;

            for (const line of lines) {
                if (!line.trim()) {
                    // Empty line - add spacing
                    html += '<div style="height: 15px;"></div>';
                    parsedLines.push({ left: '', right: '', isEmpty: true });
                    continue;
                }

                // Split by pipe
                const parts = line.split('|');

                if (parts.length >= 2) {
                    rowNum++;
                    // Remove glossed words in parentheses (e.g., "vida(life)" or "conto (tale)")
                    const left = parts[0].trim().replace(/\s*\([^)]+\)/g, '');
                    const right = parts.slice(1).join('|').trim();

                    parsedLines.push({ left, right, isEmpty: false });

                    const displayLeft = isSwapped ? right : left;
                    const displayRight = isSwapped ? left : right;

                    html += `
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; padding: 10px 0; border-bottom: 1px solid #eee;">
                            <div style="padding-right: 15px; border-right: 2px solid #e0e0e0;">
                                <span style="display: inline-block; background: #2196F3; color: white; width: 22px; height: 22px; border-radius: 50%; text-align: center; line-height: 22px; font-size: 11px; margin-right: 8px; font-weight: bold;">${rowNum}</span>
                                ${escapeHtml(displayLeft)}
                            </div>
                            <div style="padding-left: 15px; color: #555;">${escapeHtml(displayRight)}</div>
                        </div>
                    `;
                } else {
                    // No pipe found - show on left side only
                    rowNum++;
                    const content = line.trim();
                    parsedLines.push({ left: content, right: '', isEmpty: false });

                    html += `
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; padding: 10px 0; border-bottom: 1px solid #eee;">
                            <div style="padding-right: 15px; border-right: 2px solid #e0e0e0;">
                                <span style="display: inline-block; background: #2196F3; color: white; width: 22px; height: 22px; border-radius: 50%; text-align: center; line-height: 22px; font-size: 11px; margin-right: 8px; font-weight: bold;">${rowNum}</span>
                                ${escapeHtml(content)}
                            </div>
                            <div style="padding-left: 15px; color: #999; font-style: italic;">(no translation)</div>
                        </div>
                    `;
                }
            }

            bilingualContent.innerHTML = html || '<div style="color: #999; text-align: center; padding: 20px;">No piped text found</div>';
            displaySection.style.display = 'block';
            showStatus('Displayed ' + rowNum + ' lines', 'success');
        }

        function swapLanguages() {
            isSwapped = !isSwapped;

            // Swap headers
            const leftHeader = document.getElementById('leftHeader');
            const rightHeader = document.getElementById('rightHeader');

            if (isSwapped) {
                leftHeader.textContent = 'English';
                rightHeader.textContent = 'Portuguese';
            } else {
                leftHeader.textContent = 'Portuguese';
                rightHeader.textContent = 'English';
            }

            // Re-process to update display
            if (parsedLines.length > 0) {
                processAndDisplayBilingual();
            }

            showStatus('Languages swapped', 'success');
        }

        function clearExtractor() {
            document.getElementById('linkExtractorTextarea').value = '';
            document.getElementById('extractedLinkDisplay').style.display = 'none';
            document.getElementById('bilingualDisplaySection').style.display = 'none';
            extractedLink = null;
            parsedLines = [];
            showStatus('Extractor cleared', 'info');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Global access to extractedLink
        window.getExtractedLink = () => extractedLink;

        // ========== METRONOME FUNCTIONALITY ==========
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        let metronomeContext = null;
        let metronomeTimer = null;
        let metronomeNoteCount = 0;
        let metronomeCounting = false;
        let metronomeAccentPitch = 380;
        let metronomeOffBeatPitch = 200;
        let metronomeCurTime = 0.0;
        let metronomeDelta = 0;

        // Initialize audio context on first user interaction
        function initMetronomeContext() {
            if (!metronomeContext) {
                metronomeContext = new AudioContext();
            }
        }

        function metronomeSchedule() {
            while (metronomeCurTime < metronomeContext.currentTime + 0.1) {
                metronomePlayNote(metronomeCurTime);
                metronomeUpdateTime();
            }
            metronomeTimer = window.setTimeout(metronomeSchedule, 100);
        }

        function metronomeUpdateTime() {
            const bpm = parseInt(document.getElementById('metronomeBpm').value, 10) || 60;
            metronomeCurTime += 60.0 / bpm;
            metronomeNoteCount++;
        }

        function metronomePlayNote(t) {
            const note = metronomeContext.createOscillator();
            const beat = parseInt(document.getElementById('metronomeBeat').value, 10) || 4;

            if (metronomeNoteCount >= beat) {
                metronomeNoteCount = 0;
            }

            const dots = document.querySelectorAll('#metronomeCounter .dot');
            const currentDot = dots[metronomeNoteCount];

            if (currentDot && currentDot.classList.contains('active')) {
                note.frequency.value = metronomeAccentPitch;
            } else {
                note.frequency.value = metronomeOffBeatPitch;
            }

            note.connect(metronomeContext.destination);
            note.start(t);
            note.stop(t + 0.05);

            // Visual feedback
            dots.forEach(dot => {
                dot.style.transform = '';
                dot.style.background = dot.classList.contains('active') ? '#5ec2ff' : '#FFF';
            });

            if (currentDot) {
                currentDot.style.transform = 'translateY(-8px)';
                currentDot.style.background = '#F75454';
            }
        }

        function metronomeCountDown() {
            const timerInput = document.getElementById('metronomeTimer');
            const currentVal = parseInt(timerInput.value, 10);

            if (currentVal > 0 && metronomeCounting) {
                timerInput.value = currentVal - 1;
                window.setTimeout(metronomeCountDown, 1000);
            } else {
                document.getElementById('metronomePlay').click();
                timerInput.value = 60;
            }
        }

        // Update dots when beat changes
        function updateMetronomeDots() {
            const counter = document.getElementById('metronomeCounter');
            const beat = parseInt(document.getElementById('metronomeBeat').value, 10) || 4;
            counter.innerHTML = '';

            for (let i = 0; i < beat; i++) {
                const dot = document.createElement('div');
                dot.className = 'dot' + (i === 0 ? ' active' : '');
                dot.addEventListener('click', function() {
                    this.classList.toggle('active');
                });
                counter.appendChild(dot);
            }
        }

        // Metronome Event listeners
        document.getElementById('metronomeBeat').addEventListener('change', updateMetronomeDots);

        document.querySelector('.bpm-minus').addEventListener('click', function() {
            const input = document.getElementById('metronomeBpm');
            input.value = Math.max(1, parseInt(input.value, 10) - 1);
        });

        document.querySelector('.bpm-plus').addEventListener('click', function() {
            const input = document.getElementById('metronomeBpm');
            input.value = parseInt(input.value, 10) + 1;
        });

        document.getElementById('metronomeTap').addEventListener('click', function() {
            const d = new Date();
            const temp = d.getTime();
            const bpm = Math.ceil(60000 / (temp - metronomeDelta));
            if (bpm > 0 && bpm < 300) {
                document.getElementById('metronomeBpm').value = bpm;
            }
            metronomeDelta = temp;
        });

        document.getElementById('metronomePlay').addEventListener('click', function() {
            initMetronomeContext();

            if (this.dataset.playing === 'true') {
                // Stop
                metronomeCounting = false;
                window.clearTimeout(metronomeTimer);
                document.querySelectorAll('#metronomeCounter .dot').forEach(dot => {
                    dot.style.transform = '';
                    dot.style.background = dot.classList.contains('active') ? '#5ec2ff' : '#FFF';
                });
                this.dataset.playing = 'false';
                this.textContent = 'Play';
                this.style.background = '#D6E26D';
                this.style.color = '#3d430d';
            } else {
                // Play
                if (document.getElementById('metronome-timer-check').checked) {
                    metronomeCounting = true;
                    metronomeCountDown();
                }

                metronomeCurTime = metronomeContext.currentTime;
                metronomeNoteCount = parseInt(document.getElementById('metronomeBeat').value, 10) || 4;
                metronomeSchedule();

                this.dataset.playing = 'true';
                this.textContent = 'Stop';
                this.style.background = '#F75454';
                this.style.color = '#FFF';
            }
        });

        // Click dots to toggle accent
        document.querySelectorAll('#metronomeCounter .dot').forEach(dot => {
            dot.addEventListener('click', function() {
                this.classList.toggle('active');
            });
        });

        // ============================================
        // CLOUD NOTES FEATURE (Inline)
        // ============================================
        const CLOUD_NOTES_CODE = '123';
        const CLOUD_NOTES_FILENAME = 'cloud_notes.txt';

        // Toggle section visibility
        document.getElementById('cloudNotesToggleBtn').addEventListener('click', function() {
            const section = document.getElementById('cloudNotesSection');
            section.style.display = section.style.display === 'none' ? 'block' : 'none';
        });

        // Load from cloud
        document.getElementById('cloudNotesLoadBtn').addEventListener('click', async function() {
            const statusEl = document.getElementById('cloudNotesStatus');
            const textarea = document.getElementById('cloudNotesTextarea');

            statusEl.textContent = 'Loading...';
            statusEl.style.color = '#FFC107';

            try {
                const response = await fetch('/api/files');
                if (response.ok) {
                    const data = await response.json();
                    textarea.value = data.files?.[CLOUD_NOTES_FILENAME] || '';
                    statusEl.textContent = 'Loaded ‚úì';
                    statusEl.style.color = '#4CAF50';
                } else {
                    statusEl.textContent = 'Load failed';
                    statusEl.style.color = '#f44336';
                }
            } catch (err) {
                statusEl.textContent = 'Error: ' + err.message;
                statusEl.style.color = '#f44336';
            }
        });

        // Save to cloud
        document.getElementById('cloudNotesSaveBtn').addEventListener('click', async function() {
            const statusEl = document.getElementById('cloudNotesStatus');
            const textarea = document.getElementById('cloudNotesTextarea');
            const saveBtn = this;

            saveBtn.disabled = true;
            statusEl.textContent = 'Saving...';
            statusEl.style.color = '#FFC107';

            try {
                const response = await fetch('/api/files', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        filename: CLOUD_NOTES_FILENAME,
                        content: textarea.value,
                        accessCode: CLOUD_NOTES_CODE
                    })
                });

                if (response.ok) {
                    statusEl.textContent = 'Saved ‚úì';
                    statusEl.style.color = '#4CAF50';
                } else {
                    statusEl.textContent = 'Save failed';
                    statusEl.style.color = '#f44336';
                }
            } catch (err) {
                statusEl.textContent = 'Save failed';
                statusEl.style.color = '#f44336';
            } finally {
                saveBtn.disabled = false;
            }
        });
    </script>
</body>
</html>


